<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>图形学入门笔记3:Path Tracing-Games101作业7</title>
      <link href="/hexo_zh/2022/10/05/gamegraphics/tu-xing-xue-ru-men-bi-ji-3-path-tracing/"/>
      <url>/hexo_zh/2022/10/05/gamegraphics/tu-xing-xue-ru-men-bi-ji-3-path-tracing/</url>
      
        <content type="html"><![CDATA[<p>Path tracing笔记以及Games101作业7代码相关解读以及实现。笔记包括</p><ol type="1"><li>辐射度量学相关概念</li><li>渲染方程</li><li>蒙特卡洛积分</li><li>Path Tracing逻辑。</li></ol><p><span id="more"></span></p><h3 id="辐射度量学-radiometry">辐射度量学 (Radiometry)</h3><ul><li><p>辐射通量 (Radiant flux (power)) <span class="math inline">\(\Phi=\frac{\mathrm{d}Q}{\mathrm{d}t}\)</span> Energy per unit time，表示单位时间内光穿过一个截面的光能。</p></li><li><p>辐射强度 (Radiant intensity)，<span class="math inline">\(I(\omega)=\frac{\mathrm{d}\Phi}{\mathrm{d}\omega}\)</span> Power per unit solid angle，表示单位立体角上的辐射通量。</p></li><li><p>辐射率 (Radiance)，<span class="math inline">\(L(\mathrm p,\omega)=\frac{\mathrm d^2\Phi(p,\omega)}{\mathrm d \omega\cdot\mathrm dA\cos\theta}\)</span> Power emitted, reflected, transmitted or received by a surface, per unit solid angle, per projected unit area，表示单位立体角，单位投影面积上的辐射通量。这里多出来一个<span class="math inline">\(\cos \theta\)</span>是因为Lamber's Cosine Law，即阳光在斜照的时候强度会由于倾角变成原来的<span class="math inline">\(\cos \theta\)</span>倍。</p></li><li><p>辐照度 (Irradiance)，<span class="math inline">\(E(\mathrm{x})=\frac{\mathrm d\Phi(\mathrm x)}{\mathrm d A}\)</span> Power per unit area incident on a surface point，表示单位面积上的辐射通量。这里有一种记忆方法，在Games104上学到的，将Irradiance拆分成Ir(In)和Radiance记为进入到表面的光照强度。</p></li><li><p>立体角 (Solid Angles)</p><p><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/image-20221005201356513.png" /></p></li></ul><h3 id="bidirectional-reflectance-distribution-function-brdf">Bidirectional Reflectance Distribution Function (BRDF)</h3><ul><li>渲染方程 (Rendering Equation) <span class="math display">\[L_o(p,\omega_0)=L_e(p,\omega_0)+\int_{\Omega+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_0)(n\cdot\omega_i)\mathrm d\omega_i\]</span> 其中第一项表示物体本身的发出的光照强度，第二项的积分所包括的内容就是我们的反射函数 (Reflection Function)，即 <span class="math display">\[L_r(\mathrm p, \omega_r)=\int_{\Omega+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_0)\cos\theta_i\mathrm d\omega_i\]</span> 其中第一项为入射方向的Radiance，代表从单位立体角方向入射到单位面积上的光照强度，第二项就是双向反射分布函数，他表示以下比值 <span class="math display">\[f_r(\omega_i\rightarrow\omega_r)=\frac{\mathrm dL_r(\omega_r)}{\mathrm dE_i(\omega_i)}=\frac{\mathrm dL_r(\omega_r)}{L_i(\omega_i)\cos\theta_i\mathrm d\omega_i}~~[\frac{1}{\text{sr}}]\]</span> 也就是出射光Radiance与入射光Irradiance的比值，也就是代表了在各个方向上多少光照会被反射出去。这里的积分是对入射光的Radiance进行积分，得到的就是入射光在半球面上的Irradiance，然后和BRDF相乘得到的就是反射出的在单位立体角上的Radiance。</li></ul><h3 id="蒙特卡洛积分-monte-carlo-integration">蒙特卡洛积分 (Monte Carlo Integration)</h3><ul><li>Monte Carlo estimator <span class="math inline">\(F_N=\frac{1}{N}\sum^N_{i=1}\frac{f(X_i)}{p(X_i)}\)</span>, Example, Basic (Uniform) Monte Carlo estimator <span class="math inline">\(F_N=\frac{b-a}{N}\sum_{i=1}^Nf(X_i)\)</span></li><li>Monte Carlo Integration <span class="math inline">\(\int f(x)\mathrm dx=\frac{1}{N}\sum_{i=1}^N\frac{f(X_i)}{p(X_i)}\)</span> The more samples, the less variance.</li></ul><h3 id="路径追踪-path-tracing">路径追踪 (Path Tracing)</h3><p>Whitted-style 光线追踪始终采用镜面反射，在光线与diffuse表面相交时停止反射，这一假设会造成一些问题。首先，比如说诸如Glossy (感觉类似磨砂)的效果就无法表现出来。其次，由于不在diffuse表面进行反射，物体之间由于光线反射形成的现象比如说康奈尔Box中的墙面会映射出左右两面墙的红绿两种颜色(如下图)就无法表现出来。</p><p><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/image-20221005213331204.png" /></p><p>Path tracing使用Rendering Equation进行光照的计算。在计算Rendering Equation中的积分部分时，我们就可以使用Monte Carlo Integration计算。一个简单的Monte Carlo的方法如下图所示 (Direct Illumination)，其中的pdf最直观的办法我们可以视为uniform的，也就是<span class="math inline">\(\mathrm{pdf}=\frac{1}{2\pi}\)</span>。</p><p><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/image-20221005214101763.png" /></p><p>以上是最简单的直接光照的蒙特卡洛积分，然后我们再加上递归的间接光照以及控制递归深度就完成了最终的Path Tracing。为了控制深度，我们使用一种叫做俄罗斯轮盘赌 (Russian Roulette)的方法。非常简单，这种方法就是在每次光线进行反射的时候进行一次随机选择，p的概率继续递归，(1-p)的概率停止，如果继续反射，则我们计算反射的光照强度为<span class="math inline">\(\frac{L_r(p,\omega_r)}{p}\)</span>，这样我们最后根据数学期望得到的光照强度仍然是<span class="math inline">\(L_r(p,\omega_r)\)</span>。使用后RR的Path Tracing伪代码如下所示。</p><p><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/image-20221005225016368.png" /></p><p>最后还有一个问题需要解决，使用以上方法进行采样的效率实际上是不高的，因为很多光线实际上是反射不到光源上的，那样就会造成很多浪费。因此，我们可以使用另外一种采样方式，Sampling the Light，从光源处采样。为了实现光源采样，我们可以重写反射方程，将对入射角度<span class="math inline">\(\omega\)</span>的积分转化为对光源面积<span class="math inline">\(A\)</span>的积分，由于<span class="math inline">\(\mathrm d\omega=\frac{\mathrm dA\cos\theta&#39;}{\Vert x&#39;-x\Vert^2}\)</span> (由立体角的定义得出)，因此 <span class="math display">\[\begin{align}L_r(\mathrm p,\omega_r)&amp;=\int_{\Omega+}L_i(x,\omega_i)f_r(x,\omega_i,\omega_0)\cos\theta_i\mathrm d\omega_i \\    &amp;=\int_{A}L_i(x,\omega_i)f_r(p,\omega_i,\omega_0)\frac{\cos\theta_i\cos\theta&#39;_i}{\Vert x&#39;-x\Vert^2}\mathrm d\omega_i\end{align}\]</span> <img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/image-20221005230600428.png" /></p><p>最终版的Path Tracing伪代码如下</p><p><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/image-20221005230708399.png" /></p><h3 id="作业7">作业7</h3><p>首先，我们需要将上一次作业的几个函数的实现复制粘贴到这里来，包括<code>Triangle::getIntersection()</code> in Triangle.hpp，<code>IntersectP(const Ray&amp; ray, const Vector3f&amp; invDir, const std::array&lt;int, 3&gt;&amp; dirIsNeg)</code> in Bounds3.hpp以及<code>getIntersection(BVHBuildNode* node, const Ray ray)</code> in BVH.cpp。代码如下所示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Triangle.hpp</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Intersection <span class="title">Triangle::getIntersection</span><span class="params">(Ray ray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Intersection inter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dotProduct</span>(ray.direction, normal) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> inter;</span><br><span class="line">    <span class="keyword">double</span> u, v, t_tmp = <span class="number">0</span>;</span><br><span class="line">    Vector3f pvec = <span class="built_in">crossProduct</span>(ray.direction, e2);</span><br><span class="line">    <span class="keyword">double</span> det = <span class="built_in">dotProduct</span>(e1, pvec);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(det) &lt; EPSILON)</span><br><span class="line">        <span class="keyword">return</span> inter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> det_inv = <span class="number">1.</span> / det;</span><br><span class="line">    Vector3f tvec = ray.origin - v0;</span><br><span class="line">    u = <span class="built_in">dotProduct</span>(tvec, pvec) * det_inv;</span><br><span class="line">    <span class="keyword">if</span> (u &lt; <span class="number">0</span> || u &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> inter;</span><br><span class="line">    Vector3f qvec = <span class="built_in">crossProduct</span>(tvec, e1);</span><br><span class="line">    v = <span class="built_in">dotProduct</span>(ray.direction, qvec) * det_inv;</span><br><span class="line">    <span class="keyword">if</span> (v &lt; <span class="number">0</span> || u + v &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> inter;</span><br><span class="line">    t_tmp = <span class="built_in">dotProduct</span>(e2, qvec) * det_inv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find ray triangle intersection</span></span><br><span class="line">    <span class="keyword">if</span> (t_tmp &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> inter;</span><br><span class="line">    inter.happened = <span class="literal">true</span>;</span><br><span class="line">    inter.distance = t_tmp;</span><br><span class="line">    inter.coords = <span class="built_in">ray</span>(t_tmp);</span><br><span class="line">    inter.normal = normal;</span><br><span class="line">    inter.obj = <span class="keyword">this</span>;</span><br><span class="line">    inter.m = m;</span><br><span class="line">    <span class="keyword">return</span> inter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bounds3.hpp</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Bounds3::IntersectP</span><span class="params">(<span class="keyword">const</span> Ray&amp; ray, <span class="keyword">const</span> Vector3f&amp; invDir,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">const</span> std::array&lt;<span class="keyword">int</span>, <span class="number">3</span>&gt;&amp; dirIsNeg)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// invDir: ray direction(x,y,z), invDir=(1.0/x,1.0/y,1.0/z), use this because Multiply is faster that Division</span></span><br><span class="line">    <span class="comment">// dirIsNeg: ray direction(x,y,z), dirIsNeg=[int(x&gt;0),int(y&gt;0),int(z&gt;0)], use this to simplify your logic</span></span><br><span class="line">    <span class="comment">// test if ray bound intersects</span></span><br><span class="line">    Vector3f t_min = (<span class="keyword">this</span>-&gt;pMin - ray.origin) * invDir;</span><br><span class="line">    Vector3f t_max = (<span class="keyword">this</span>-&gt;pMax - ray.origin) * invDir;</span><br><span class="line">    <span class="keyword">if</span> (!dirIsNeg[<span class="number">0</span>]) std::<span class="built_in">swap</span>(t_min.x, t_max.x);</span><br><span class="line">    <span class="keyword">if</span> (!dirIsNeg[<span class="number">1</span>]) std::<span class="built_in">swap</span>(t_min.y, t_max.y);</span><br><span class="line">    <span class="keyword">if</span> (!dirIsNeg[<span class="number">2</span>]) std::<span class="built_in">swap</span>(t_min.z, t_max.z);</span><br><span class="line">    <span class="keyword">float</span> t_enter = <span class="built_in">fmax</span>(t_min.x, <span class="built_in">fmax</span>(t_min.y, t_min.z));</span><br><span class="line">    <span class="keyword">float</span> t_exit = <span class="built_in">fmin</span>(t_max.x, <span class="built_in">fmin</span>(t_max.y, t_max.z));</span><br><span class="line">    <span class="keyword">return</span> t_enter &lt;= t_exit &amp;&amp; t_exit &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BVH.cpp</span></span><br><span class="line"><span class="function">Intersection <span class="title">BVHAccel::getIntersection</span><span class="params">(BVHBuildNode* node, <span class="keyword">const</span> Ray&amp; ray)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Intersection inter;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> inter;</span><br><span class="line">    std::array&lt;<span class="keyword">int</span>, 3&gt; dirIsNeg = &#123;<span class="built_in"><span class="keyword">int</span></span>(ray.direction.x &gt; <span class="number">0</span>), <span class="built_in"><span class="keyword">int</span></span>(ray.direction.y &gt; <span class="number">0</span>), <span class="built_in"><span class="keyword">int</span></span>(ray.direction.z &gt; <span class="number">0</span>)&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!node-&gt;bounds.<span class="built_in">IntersectP</span>(ray, ray.direction_inv, dirIsNeg))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> inter; <span class="comment">// No intersection in the current node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;object == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;NULL Object Error&quot;</span>);</span><br><span class="line">        inter = node-&gt;object-&gt;<span class="built_in">getIntersection</span>(ray);</span><br><span class="line">        <span class="keyword">return</span> inter;</span><br><span class="line">    &#125;</span><br><span class="line">    Intersection left_inter = <span class="built_in">getIntersection</span>(node-&gt;left, ray);</span><br><span class="line">    Intersection right_inter = <span class="built_in">getIntersection</span>(node-&gt;right, ray);</span><br><span class="line">    <span class="keyword">return</span> left_inter.distance &lt; right_inter.distance ? left_inter : right_inter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成后确保编译运行都没有问题后，我们再正式开始这次作业的实现，我们只需要对<code>castRay(const Ray ray, int depth)</code> in Scene.cpp进行实现，代码如下所示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector3f <span class="title">Scene::castRay</span><span class="params">(<span class="keyword">const</span> Ray &amp;ray, <span class="keyword">int</span> depth)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector3f L_dir = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, L_indir = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    Intersection intersection = Scene::<span class="built_in">intersect</span>(ray);</span><br><span class="line">    <span class="keyword">if</span> (!intersection.happened)</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (intersection.m-&gt;<span class="built_in">hasEmission</span>())</span><br><span class="line">        <span class="keyword">return</span> intersection.m-&gt;<span class="built_in">getEmission</span>();</span><br><span class="line"></span><br><span class="line">    Intersection light_pos;</span><br><span class="line">    <span class="keyword">float</span> light_pdf = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="built_in">sampleLight</span>(light_pos, light_pdf);</span><br><span class="line">    Vector3f collision_light = light_pos.coords - intersection.coords;</span><br><span class="line">    <span class="keyword">float</span> dis = <span class="built_in">dotProduct</span>(collision_light, collision_light);</span><br><span class="line">    Vector3f collision_light_dir = collision_light.<span class="built_in">normalized</span>();</span><br><span class="line">    <span class="function">Ray <span class="title">light_to_object_ray</span><span class="params">(intersection.coords, collision_light_dir)</span></span>;</span><br><span class="line">    Intersection light_ray_inter = Scene::<span class="built_in">intersect</span>(light_to_object_ray);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> f_r = intersection.m -&gt; <span class="built_in">eval</span>(ray.direction, collision_light_dir, intersection.normal);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Pay attention to the precision here</span></span><br><span class="line">    <span class="keyword">if</span> (light_ray_inter.distance - collision_light.<span class="built_in">norm</span>() &gt; <span class="number">-0.005</span>)&#123;</span><br><span class="line">        L_dir = light_pos.emit * f_r * <span class="built_in">dotProduct</span>(collision_light_dir, intersection.normal)</span><br><span class="line">                * <span class="built_in">dotProduct</span>(-collision_light_dir, light_pos.normal) / dis / light_pdf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">get_random_float</span>() &gt; RussianRoulette)</span><br><span class="line">        <span class="keyword">return</span> L_dir;</span><br><span class="line"></span><br><span class="line">    Vector3f w0 = intersection.m -&gt; <span class="built_in">sample</span>(ray.direction, intersection.normal).<span class="built_in">normalized</span>();</span><br><span class="line">    <span class="function">Ray <span class="title">object_to_object_ray</span><span class="params">(intersection.coords, w0)</span></span>;</span><br><span class="line">    Intersection islight = Scene::<span class="built_in">intersect</span>(object_to_object_ray);</span><br><span class="line">    <span class="keyword">if</span> (islight.happened &amp;&amp; !islight.m-&gt;<span class="built_in">hasEmission</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> pdf = intersection.m-&gt;<span class="built_in">pdf</span>(ray.direction, w0, intersection.normal);</span><br><span class="line">        f_r = intersection.m-&gt;<span class="built_in">eval</span>(ray.direction, w0, intersection.normal);</span><br><span class="line">        L_indir = <span class="built_in">castRay</span>(object_to_object_ray, depth + <span class="number">1</span>) * f_r * <span class="built_in">dotProduct</span>(w0, intersection.normal) / pdf / RussianRoulette;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L_dir + L_indir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终生成的图片，这里为了效果好一点我跑了128的SPP，大概需要跑几个小时，如下图</p><p><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/output-128.jpg" /></p><h3 id="未完待续">未完待续</h3><p>生成一张这样的图片几个小时确实有点太慢了，提高篇要求我们使用多线程来提高渲染的速度，并且采用微表面模型的材质。这也是十分重要的概念，不过还是没有深入理解，准备等到以后学习完Games202之后再回来看看如何实现。</p><h3 id="参考资料">参考资料</h3><p><a href="https://blog.csdn.net/qq_41765657/article/details/121942469">GAMES101:作业7_南酒猫的博客-CSDN博客_games101作业7</a></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE5风格化渲染</title>
      <link href="/hexo_zh/2022/09/30/gamegraphics/ue5-feng-ge-hua-xuan-ran/"/>
      <url>/hexo_zh/2022/09/30/gamegraphics/ue5-feng-ge-hua-xuan-ran/</url>
      
        <content type="html"><![CDATA[<h1 id="ue5-风格化渲染">UE5 风格化渲染</h1><p>风格化渲染主要需要有以下几个部分</p><ol type="1"><li>风格化描边</li><li>Diffuse, Specular 等效果的处理</li></ol><p>未完待续</p><span id="more"></span><h2 id="风格化描边">风格化描边</h2><p>从搜集到的资料来看，具体有一下几种做法</p><ol type="1"><li>通过计算像素与四周的差异来判断是否为需要勾边的边缘（可以是场景深度，法线等）</li><li>使用Fresnel实现边缘光照（黑色光照），以此来实现描边的效果，关于菲涅尔节点可以参考UE官方文档<a href="https://docs.unrealengine.com/4.26/zh-CN/RenderingAndGraphics/Materials/HowTo/Fresnel/">在材质中使用菲涅尔效果 | 虚幻引擎文档 (unrealengine.com)</a>。</li><li>使用一个稍大的纯黑模型与原始模型摆放在同一个位置，通过back culling隐藏遮挡的部分。</li></ol><h2 id="实现效果">实现效果</h2><p>一下效果参考自<a href="https://www.bilibili.com/video/BV1SP4y1b76D">4</a>，由于没有法向贴图的资源，以及没有调参，所以效果可能没有那么明显。</p><figure><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/image-20220801101624617.png" alt="image-20220801101624617" /><figcaption aria-hidden="true">image-20220801101624617</figcaption></figure><h2 id="参考资料">参考资料</h2><ol type="1"><li>[<a href="https://zhuanlan.zhihu.com/p/338549713">译文]Unreal Engine 4 卡通着色（Cel Shading）教程 - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/352347502">程序干货：日式卡通渲染基础技术（上） - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/c_1215952152252121088">从零开始的卡通渲染 - 知乎 (zhihu.com)</a></li><li><a href="https://www.bilibili.com/video/BV1SP4y1b76D">（UE教程）萌新教你在UE4中制作一个风格化水墨场景_哔哩哔哩_bilibili</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Unreal Engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal Engine </tag>
            
            <tag> Rendering </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex的使用详解笔记(常用数学符号、图片表格等)持续更新</title>
      <link href="/hexo_zh/2022/09/30/other/latex-notes/"/>
      <url>/hexo_zh/2022/09/30/other/latex-notes/</url>
      
        <content type="html"><![CDATA[<p>本篇笔记用来记录在使用LaTeX过程中经常碰到的LaTeX数学符号以及一些基础的常用的操作比如添加图片，添加代码，如果有的话还会收藏一些比较实用的模板比如CV模板，作业模板论文模板等等。持续更新……</p><p><span id="more"></span></p><h1 id="latex-数学"><span class="math inline">\(\LaTeX\)</span> 数学</h1><p>为了使用 AMS-LaTeX 提供的数学功能，我们需要在导言区加载 <code>amsmath</code> 宏包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\usepackage&#123;amsmath&#125;</span><br></pre></td></tr></table></figure><p>LaTeX 的数学模式有两种：行内模式 (inline) 和行间模式 (display)。前者在正文的行文中，插入数学公式；后者独立排列单独成行，并自动居中。</p><p>在行文中，使用<strong><code>$ ... $</code> 可以插入行内公式</strong>，使用 <code>\[ ... \]</code> 可以插入行间公式，如果需要对行间公式进行编号，则可以使用 <code>equation</code> 环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;equation&#125;</span><br><span class="line">...</span><br><span class="line">\end&#123;equation&#125;</span><br></pre></td></tr></table></figure><h2 id="一些比较常用的特殊符号整理">一些比较常用的特殊符号整理</h2><ul><li><p>各类希腊字母编辑表</p><table><thead><tr class="header"><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr class="odd"><td>α</td><td>β</td><td>ω</td><td><span class="math inline">\(\Theta\)</span></td><td><span class="math inline">\(\Gamma\)</span></td><td><span class="math inline">\(\Omega\)</span></td></tr></tbody></table></li><li><p>上下标</p><p>​ 上标： ^ 如 <span class="math inline">\(x^2\)</span> ​ 下标： _ 如 <span class="math inline">\(x_2\)</span> ​ 上下标如果多于一个字母或符号,需要用一对 {} 括起来。</p></li><li><p>根号： 如<code>$sqrt[n]&#123;5&#125;</code>为<span class="math inline">\(\sqrt[n]5\)</span></p></li><li><p>省略号：<code>$\dots \cdots$</code>分别为<span class="math inline">\(\dots \cdots\)</span></p></li><li><p>运算符 小的运算符(operator)例如 + - * /等可以直接输入，其他特殊的有</p><table><thead><tr class="header"><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr class="odd"><td>±</td><td>×</td><td>÷</td><td>⋅</td><td>∩</td><td>∪</td><td>≥</td><td>≤</td><td>≠</td><td>≈</td><td>≡</td></tr></tbody></table><p>求和：<code>\sum_1^n</code>: <span class="math inline">\(\sum_1^n\)</span> 积分：<code>\int_1^n</code>: <span class="math inline">\(\int_1^n\)</span> 极限：<code>lim_&#123;x \to \infty&#125;</code>: <span class="math inline">\(lim_{x \to \infty}\)</span> 分数的表示：<code>\frac&#123;&#125;&#123;&#125;</code>如 <span class="math inline">\(\frac{3}{8}\)</span></p></li><li><p>字母的特殊标记</p><p>平均数: <code>\overline&#123;mean&#125;</code> or <code>\bar x</code>: <span class="math inline">\(\overline{mean} \text{ or } \bar m\)</span></p><p>Hat: <code>\hat&#123;\theta&#125;</code>: <span class="math inline">\(\hat{\theta}\)</span></p></li><li><p>矩阵与行列式 <code>$$\begin&#123;matrix&#125;…\end&#123;matrix&#125;$$</code>，使用&amp;分隔同行元素，。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">    1 &amp; x &amp; x^2 \\</span><br><span class="line">    1 &amp; y &amp; y^2 \\</span><br><span class="line">    1 &amp; z &amp; z^2 \\</span><br><span class="line">    \end&#123;matrix&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p><span class="math display">\[\begin{matrix}    1 &amp; x &amp; x^2 \\\\    1 &amp; y &amp; y^2 \\\\    1 &amp; z &amp; z^2 \\\\\end{matrix}\]</span> 行列式</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">X=\left|</span><br><span class="line">    \begin&#123;matrix&#125;</span><br><span class="line">        x_&#123;11&#125; &amp; x_&#123;12&#125; &amp; \cdots &amp; x_&#123;1d&#125;\\</span><br><span class="line">        x_&#123;21&#125; &amp; x_&#123;22&#125; &amp; \cdots &amp; x_&#123;2d&#125;\\</span><br><span class="line">        \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\</span><br><span class="line">        x_&#123;m1&#125; &amp; x_&#123;m2&#125; &amp; \cdots &amp; x_&#123;md&#125;\\</span><br><span class="line">    \end&#123;matrix&#125;</span><br><span class="line">\right|</span><br><span class="line">$$</span><br></pre></td></tr></table></figure></p><p><span class="math display">\[X=\left|\begin{matrix}x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1d}\\\\x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2d}\\\\\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\\\x_{m1} &amp; x_{m2} &amp; \cdots &amp; x_{md}\\\\\end{matrix}\right|\]</span></p></li><li><p>分隔符 各种括号用 <code>() [] &#123;&#125;</code> <code>\langle</code> <code>\rangle</code> (<span class="math inline">\(\langle\rangle\)</span>)等命令表示,注意花括号通常用来输入命令和环境的参数,所以在数学公式中它们前面要加 \。可以在上述分隔符前面加 \big \Big \bigg \Bigg 等命令来调整大小。</p></li><li><p>方程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;equation&#125;</span><br><span class="line">E=mc^2</span><br><span class="line">\end&#123;equation&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\begin{equation} E=mc^2 \end{equation}\]</span></p></li><li><p>分段函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f(n) =</span><br><span class="line">\begin&#123;cases&#125;</span><br><span class="line">n/2,  &amp; \text&#123;if $n$ is even&#125; \\</span><br><span class="line">3n+1, &amp; \text&#123;if $n$ is odd&#125;</span><br><span class="line">\end&#123;cases&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[ f(n) = \begin{cases} n/2,  &amp; \text{if $n$ is even} \\\\ 3n+1, &amp; \text{if $n$ is odd} \end{cases}\]</span></p></li><li><p>方程组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\left\&#123; </span><br><span class="line">\begin&#123;array&#125;&#123;c&#125;</span><br><span class="line">    a_1x+b_1y+c_1z=d_1 \\ </span><br><span class="line">    a_2x+b_2y+c_2z=d_2 \\ </span><br><span class="line">    a_3x+b_3y+c_3z=d_3</span><br><span class="line">\end&#123;array&#125;</span><br><span class="line">\right</span><br></pre></td></tr></table></figure><p><span class="math display">\[\left\{  \begin{array}{c}     a_1x+b_1y+c_1z=d_1 \\\\     a_2x+b_2y+c_2z=d_2 \\\\     a_3x+b_3y+c_3z=d_3 \end{array} \right.\]</span></p></li></ul><h2 id="常用公式">常用公式</h2><ul><li><p>线性模型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h(\theta) = \sum_&#123;j = 0&#125; ^n \theta_j x_j</span><br></pre></td></tr></table></figure><p><span class="math display">\[h(\theta) = \sum_{j = 0} ^n \theta_j x_j\]</span></p></li><li><p>均方误差</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">J(\theta) = \frac&#123;1&#125;&#123;2m&#125;\sum_&#123;i = 0&#125; ^m(y^i - h_\theta (x^i))^2</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p><span class="math display">\[J(\theta) = \frac{1}{2m}\sum_{i = 0} ^m(y^i - h_\theta (x^i))^2\]</span></p></li><li><p>批量梯度下降</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\frac&#123;\partial J(\theta)&#125;&#123;\partial\theta_j&#125;=\frac1m\sum_&#123;i=0&#125;^m(y^i-h_\theta(x^i))x^i_j</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p><span class="math display">\[\frac{\partial J(\theta)}{\partial\theta_j}=-\frac1m\sum_{i=0}^m(y^i-h_\theta(x^i))x^i_j\]</span></p></li><li><p>推导过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;align&#125;</span><br><span class="line">\frac&#123;\partial J(\theta)&#125;&#123;\partial\theta_j&#125;</span><br><span class="line">&amp; = -\frac1m\sum_&#123;i=0&#125;^m(y^i-h_\theta(x^i)) \frac&#123;\partial&#125;&#123;\partial\theta_j&#125;(y^i-h_\theta(x^i)) \\</span><br><span class="line">&amp; = -\frac1m\sum_&#123;i=0&#125;^m(y^i-h_\theta(x^i)) \frac&#123;\partial&#125;&#123;\partial\theta_j&#125;(\sum_&#123;j=0&#125;^n\theta_jx_j^i-y^i) \\</span><br><span class="line">&amp; = -\frac1m\sum_&#123;i=0&#125;^m(y^i-h_\theta(x^i))x^i_j</span><br><span class="line">\end&#123;align&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p><span class="math display">\[\begin{align}\frac{\partial J(\theta)}{\partial\theta_j}&amp; = -\frac1m\sum_{i=0}^m(y^i-h_\theta(x^i)) \frac{\partial}{\partial\theta_j}(y^i-h_\theta(x^i)) \\\\&amp; = -\frac1m\sum_{i=0}^m(y^i-h_\theta(x^i)) \frac{\partial}{\partial\theta_j}(\sum_{j=0}^n\theta_jx_j^i-y^i) \\\\&amp; = -\frac1m\sum_{i=0}^m(y^i-h_\theta(x^i))x^i_j\end{align}\]</span></p></li><li><p>组合数：<span class="math inline">\(\tbinom{n}{m}\)</span><code>$\tbinom&#123;n&#125;&#123;m&#125;$</code> 或者 <span class="math inline">\(C^m_n\)</span></p></li><li><p>线性回归的解析解 <span class="math display">\[\begin{align}\theta_1 &amp;= \frac{\sum_{i=1}^m{(x^{(i)}-\bar{x})(y^{(i)}-\bar{y})}}{\sum^m_{i=1}{(x^{(i)}-\bar{x})^2}} \\\theta_0 &amp;= \bar{y}-\theta_1\bar{x}\end{align}\]</span></p><p><span class="math display">\[\hat{\Theta}=\Theta^*=(\mathbf{X}^T\mathbf{X})^{-1}X^TY\]</span></p></li></ul><h2 id="参考资料">参考资料</h2><ol type="1"><li><p><a href="https://liam.page/2014/09/08/latex-introduction/">一份其实很短的 LaTeX 入门文档</a></p></li><li><p><a href="https://blog.csdn.net/baidu_38060633/article/details/79183905">试试LaTeX插入数学公式</a></p></li><li><p><a href="https://www.cnblogs.com/Sinte-Beuve/p/6160905.html">在博客中使用LaTeX插入数学公式</a></p></li><li><p><a href="https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">MathJax basic tutorial and quick reference</a></p></li></ol><h1 id="在latex中插入图片">在<span class="math inline">\(\LaTeX\)</span>中插入图片</h1><h2 id="单张图片插入">单张图片插入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;figure&#125;[H]</span><br><span class="line">    \centering% 设置居中</span><br><span class="line">    \includegraphics[width=10cm]&#123;fig/Figure_2.png&#125;% 图片路径和大小设置</span><br><span class="line">    \caption&#123;PDF derived from CHNS&#x27;s data &#125;% 图片下文字(caption)</span><br><span class="line">\end&#123;figure&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/06/taCXRdc7gUiYHb6.png" /></p><p>[注]：</p><ol type="1"><li><p>所需要的宏包：<code>\usepackage&#123;graphicx&#125;</code></p></li><li><p>[htbp] 为调整图片排版位置选项，说明如下：</p><p>[h]当前位置。将图形放置在正文文本中给出该图形环境的地方。如果本页所剩的页面不够，这一参数将不起作用。 [t]顶部。将图形放置在页面的顶部。 [b]底部。将图形放置在页面的底部。 [p]浮动页。将图形放置在一只允许有浮动对象的页面上。</p></li><li><p>[htbp]选项是<span class="math inline">\(\LaTeX\)</span>自动排版的，会导致后来写的文本自动紧接着前面的文本。如果需要指定图片在当前位置，就需要</p><ol type="1"><li>引入宏包<code>\usepackage&#123;float&#125;</code></li><li><code>\begin&#123;figure&#125;[H]</code></li></ol></li></ol><h2 id="排版两张图片在同一行">排版两张图片在同一行</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;figure&#125;[H]</span><br><span class="line">    \centering</span><br><span class="line">    \begin&#123;minipage&#125;[t]&#123;0.48\textwidth&#125;</span><br><span class="line">    \centering</span><br><span class="line">    \includegraphics[width=6cm]&#123;fig/Figure3-Female-Height.png&#125;</span><br><span class="line">    \label&#123;fig_22&#125;</span><br><span class="line">    \caption&#123;Female Height&#125;</span><br><span class="line">    \end&#123;minipage&#125;</span><br><span class="line">    \begin&#123;minipage&#125;[t]&#123;0.48\textwidth&#125;</span><br><span class="line">    \centering</span><br><span class="line">    \includegraphics[width=6cm]&#123;fig/Figure2-Male-Height.png&#125;</span><br><span class="line">    \caption&#123;Male Height&#125;</span><br><span class="line">    \label&#123;fig_23&#125;</span><br><span class="line">    \end&#123;minipage&#125;</span><br><span class="line">\end&#123;figure&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/06/Wk1q9j3bBhGlT2Y.png" /></p><p>基本用法和插入单张图片非常相似，主要的区别是多了<code>minipage</code>的使用。</p><h2 id="参考资料-1">参考资料</h2><p><a href="https://blog.csdn.net/qq_38526623/article/details/103737589">Latex如何插入图片</a></p><p><a href="https://blog.csdn.net/weixin_42141390/article/details/103773143">Latex 并排插入两张图片</a></p><p><a href="https://blog.csdn.net/weixin_39278265/article/details/108781140">[LaTeX] 用minipage来排版多张图片（子图片）！ （以及用subfigure而不是subfloat来排版代码型图片）</a></p><h1 id="latex定理引理证明"><span class="math inline">\(\LaTeX\)</span>定理、引理、证明</h1><h2 id="定理">定理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\newtheorem&#123;thm&#125;&#123;\bf Theorem&#125;[section]</span><br><span class="line">\begin&#123;thm&#125;\label&#123;thm1&#125;</span><br><span class="line">    Let $f_1$ and $f_2$ be normal densities with respective means $\mu_1$ and $\mu_2$ and common variance $\sigma^2$, and let $f$ be the </span><br><span class="line">    mixture density $0.5 f_1+0.5 f_2$. Then $f$ is unimodal if and only if $|\mu_2-\mu_1 | \leq  2\sigma$. [4]</span><br><span class="line">\end&#123;thm&#125; </span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/06/jko9lMg8feHp4zA.png" /></p><h2 id="证明">证明</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;proof&#125;</span><br><span class="line">    A normal density is concave down between its inflection points $\mu \pm \sigma$ and concave up elsewhere. Note that $f$ is symmetric </span><br><span class="line">    around $m=(\mu_1+\mu_2)/2$ . Now if $|\mu_2-\mu_1 |&gt;2\sigma$, then both $f_1$ and $f_2$ are concave up at $m$, hence so is $f$. Therefore f has a </span><br><span class="line">    local minimum at $m$, which implies that $f$ is bimodal. Conversely, if $|\mu_2-\mu_1 |&lt;2\sigma$, then both $f_1$ and $f_2$ are concave down </span><br><span class="line">    at $m$, hence so is $f$. Thus, $f$ has a local maximum at $m$ and is therefore unimodal. In the borderline case $|\mu_2-\mu_1 |=2\sigma$ the </span><br><span class="line">    second derivative of $f$ vanishes, but the fourth derivative can be used to show that $f$ has a maximum at $m$ and thus is unimodal. [2]</span><br><span class="line">    \begin&#123;figure&#125;[H]</span><br><span class="line">        \centering</span><br><span class="line">        \includegraphics[width=14cm]&#123;fig/proof.png&#125;</span><br><span class="line">        \caption&#123;Two cases in the theorem &#123;[2]&#125;&#125;</span><br><span class="line">    \end&#123;figure&#125;</span><br><span class="line">\end&#123;proof&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/06/QHlbVTNd6vcpeK9.png" /></p><h2 id="参考资料-2">参考资料</h2><p><a href="https://blog.csdn.net/miracle_fans/article/details/78255650">Latex中定理、引理、证明、假设</a></p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：最小生成树(Minimum Spanning Tree)</title>
      <link href="/hexo_zh/2022/09/28/algorithms/suan-fa-minimum-spanning-tree/"/>
      <url>/hexo_zh/2022/09/28/algorithms/suan-fa-minimum-spanning-tree/</url>
      
        <content type="html"><![CDATA[<p>生成树指的是一个连通图G的覆盖所有顶点的无环子图，最小生成树指的是所有支撑树中加权和最小的生成树。</p><blockquote><p>最小生成树的应用：聚类分析、网络架构设计、VLSI布线设计等诸多实际应用问题，都可转化并描述为最小支 撑树的构造问题。在这些应用中，边的权重大多对应于某种可量化的成本，因此作为对应优化问 题的基本模型，最小支撑树的价值不言而喻。——《数据结构C++版》</p></blockquote><p>求最小支撑树的算法主要采用贪心算法，最著名的两个算法分别是Prim算法和Kruskal算法。</p><p>本篇主要参考<a href="https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/">Kruskal’s Minimum Spanning Tree Algorithm | Greedy Algo-2 - GeeksforGeeks</a>以及以及<a href="https://www.geeksforgeeks.org/prims-minimum-spanning-tree-mst-greedy-algo-5/?ref=lbp">Prim’s Minimum Spanning Tree (MST) | Greedy Algo-5 - GeeksforGeeks</a>，GeeksforGeeks上的数据结构今天刚好搜到了，确实讲的不错，转载收藏一下作为笔记。</p><p><span id="more"></span></p><h3 id="prim算法">Prim算法</h3><p>使用Prim算法之前，需要了解图论中的一个概念。割(Cut or Cross edges )指的是连接两个子图的边。Prim算法从图中的任意一个点出发，选出所有割中的最小边加入到MST中，直到所有的顶点都在MST中。算法的思想很简单，代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A C++ program for Prim&#x27;s Minimum</span></span><br><span class="line"><span class="comment">// Spanning Tree (MST) algorithm. The program is</span></span><br><span class="line"><span class="comment">// for adjacency matrix representation of the graph</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Number of vertices in the graph</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> V 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A utility function to find the vertex with</span></span><br><span class="line"><span class="comment">// minimum key value, from the set of vertices</span></span><br><span class="line"><span class="comment">// not yet included in MST</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minKey</span><span class="params">(<span class="keyword">int</span> key[], <span class="keyword">bool</span> mstSet[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Initialize min value</span></span><br><span class="line">    <span class="keyword">int</span> min = INT_MAX, min_index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++)</span><br><span class="line">        <span class="keyword">if</span> (mstSet[v] == <span class="literal">false</span> &amp;&amp; key[v] &lt; min)</span><br><span class="line">            min = key[v], min_index = v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min_index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A utility function to print the</span></span><br><span class="line"><span class="comment">// constructed MST stored in parent[]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMST</span><span class="params">(<span class="keyword">int</span> parent[], <span class="keyword">int</span> graph[V][V])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Edge \tWeight\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; V; i++)</span><br><span class="line">        cout &lt;&lt; parent[i] &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; \t&quot;</span></span><br><span class="line">             &lt;&lt; graph[i][parent[i]] &lt;&lt; <span class="string">&quot; \n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to construct and print MST for</span></span><br><span class="line"><span class="comment">// a graph represented using adjacency</span></span><br><span class="line"><span class="comment">// matrix representation</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primMST</span><span class="params">(<span class="keyword">int</span> graph[V][V])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Array to store constructed MST</span></span><br><span class="line">    <span class="keyword">int</span> parent[V];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Key values used to pick minimum weight edge in cut</span></span><br><span class="line">    <span class="keyword">int</span> key[V];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// To represent set of vertices included in MST</span></span><br><span class="line">    <span class="keyword">bool</span> mstSet[V];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize all keys as INFINITE</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">        key[i] = INT_MAX, mstSet[i] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Always include first 1st vertex in MST.</span></span><br><span class="line">    <span class="comment">// Make key 0 so that this vertex is picked as first</span></span><br><span class="line">    <span class="comment">// vertex.</span></span><br><span class="line">    key[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    parent[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// First node is always root of MST</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The MST will have V vertices</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; V - <span class="number">1</span>; count++) &#123;</span><br><span class="line">        <span class="comment">// Pick the minimum key vertex from the</span></span><br><span class="line">        <span class="comment">// set of vertices not yet included in MST</span></span><br><span class="line">        <span class="keyword">int</span> u = <span class="built_in">minKey</span>(key, mstSet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add the picked vertex to the MST Set</span></span><br><span class="line">        mstSet[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update key value and parent index of</span></span><br><span class="line">        <span class="comment">// the adjacent vertices of the picked vertex.</span></span><br><span class="line">        <span class="comment">// Consider only those vertices which are not</span></span><br><span class="line">        <span class="comment">// yet included in MST</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// graph[u][v] is non zero only for adjacent</span></span><br><span class="line">            <span class="comment">// vertices of m mstSet[v] is false for vertices</span></span><br><span class="line">            <span class="comment">// not yet included in MST Update the key only</span></span><br><span class="line">            <span class="comment">// if graph[u][v] is smaller than key[v]</span></span><br><span class="line">            <span class="keyword">if</span> (graph[u][v] &amp;&amp; mstSet[v] == <span class="literal">false</span></span><br><span class="line">                &amp;&amp; graph[u][v] &lt; key[v])</span><br><span class="line">                parent[v] = u, key[v] = graph[u][v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print the constructed MST</span></span><br><span class="line">    <span class="built_in">printMST</span>(parent, graph);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Driver&#x27;s code</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Let us create the following graph</span></span><br><span class="line"><span class="comment">        2 3</span></span><br><span class="line"><span class="comment">    (0)--(1)--(2)</span></span><br><span class="line"><span class="comment">    | / \ |</span></span><br><span class="line"><span class="comment">    6| 8/ \5 |7</span></span><br><span class="line"><span class="comment">    | / \ |</span></span><br><span class="line"><span class="comment">    (3)-------(4)</span></span><br><span class="line"><span class="comment">            9 */</span></span><br><span class="line">    <span class="keyword">int</span> graph[V][V] = &#123; &#123; <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span> &#125;,</span><br><span class="line">                        &#123; <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span> &#125;,</span><br><span class="line">                        &#123; <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span> &#125;,</span><br><span class="line">                        &#123; <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span> &#125;,</span><br><span class="line">                        &#123; <span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">0</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Print the solution</span></span><br><span class="line">    <span class="built_in">primMST</span>(graph);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code is contributed by rathbhupendra</span></span><br></pre></td></tr></table></figure><p>这里的代码主要使用的是图的邻接矩阵表示，采用的思想是维护一个与剩余的子图相连的割的数组，在添加边的时候更新这个数组，每次添加的时候就可以从这个数组中寻找最小的割，时间复杂度为O(V^2)，还有另外一种邻接表的表示方法，使用邻接表和优先队列可以将时间复杂度降为O(E log V)，更加复杂一些，参考<a href="https://www.geeksforgeeks.org/prims-mst-for-adjacency-list-representation-greedy-algo-6/">Prim’s MST for Adjacency List Representation | Greedy Algo-6 - GeeksforGeeks</a>。</p><h3 id="kruskal算法">Kruskal算法</h3><p>首先，将G中的所有边E按照权重从小到大进行排序，然后依次遍历，如果将当前的边加入当前的子图中不会产生环，那么就加入当前的边，否则继续遍历下一个最小边，直到所有的边都被遍历。这里产生的一个问题就是如何判断是否是有环图，这里我们可以是用压缩路径的并查集算法，参考<a href="https://www.geeksforgeeks.org/union-find-algorithm-set-2-union-by-rank/">Union-Find Algorithm | Set 2 (Union By Rank and Path Compression) - GeeksforGeeks</a>，代码如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> rank;</span><br><span class="line">    <span class="keyword">int</span> parent;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Union</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    node *nodes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        nodes = <span class="keyword">new</span> node[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            nodes[i].rank = <span class="number">1</span>;</span><br><span class="line">            nodes[i].parent = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Union</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes[i].parent != i)</span><br><span class="line">            nodes[i].parent = <span class="built_in">find</span>(nodes[i].parent);</span><br><span class="line">        <span class="keyword">return</span> nodes[i].parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i_root = <span class="built_in">find</span>(i);</span><br><span class="line">        <span class="keyword">int</span> j_root = <span class="built_in">find</span>(j);</span><br><span class="line">        <span class="keyword">if</span> (nodes[i_root].rank &lt; nodes[j_root].rank) &#123;</span><br><span class="line">            nodes[i_root].parent = nodes[j_root].parent;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodes[i_root].rank &gt; nodes[j_root].rank) &#123;</span><br><span class="line">            nodes[j_root].parent = nodes[i_root].parent;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodes[i_root].parent != nodes[j_root].parent) &#123;</span><br><span class="line">            nodes[j_root].parent = nodes[i_root].parent;</span><br><span class="line">            nodes[i_root].rank += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; edgelist;</span><br><span class="line">    <span class="keyword">int</span> V;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123; <span class="keyword">this</span>-&gt;V = v; &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">get_edgelist</span>() <span class="keyword">const</span> &#123; <span class="keyword">return</span> edgelist; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> V; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> source, <span class="keyword">int</span> destination, <span class="keyword">int</span> weight)</span> </span>&#123; edgelist.<span class="built_in">push_back</span>(&#123;weight, source, destination&#125;); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; edge)</span> </span>&#123; edgelist.<span class="built_in">push_back</span>(edge); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_total_weights</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt; edge : edgelist) &#123;</span><br><span class="line">           sum += edge[<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Graph <span class="title">kruskals_mst</span><span class="params">(<span class="keyword">const</span> Graph&amp; graph)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; edgelist = graph.<span class="built_in">get_edgelist</span>();</span><br><span class="line">        <span class="built_in">sort</span>(edgelist.<span class="built_in">begin</span>(), edgelist.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">Union <span class="title">s</span><span class="params">(graph.get_size())</span></span>;</span><br><span class="line">        Graph mst = <span class="built_in">Graph</span>(graph.<span class="built_in">get_size</span>());</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt; edge: edgelist) &#123;</span><br><span class="line">            <span class="comment">// determine whether put the edge into mst will cause a cycle</span></span><br><span class="line">            <span class="comment">// if the two vertices do not belong to the same root</span></span><br><span class="line">            <span class="comment">// they will introduce a cycle</span></span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">find</span>(edge[<span class="number">1</span>]) != s.<span class="built_in">find</span>(edge[<span class="number">2</span>])) &#123;</span><br><span class="line">                <span class="comment">// merge the two subsets together</span></span><br><span class="line">                s.<span class="built_in">merge</span>(edge[<span class="number">1</span>], edge[<span class="number">2</span>]);</span><br><span class="line">                mst.<span class="built_in">add_edge</span>(edge);</span><br><span class="line">                cout &lt;&lt; edge[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; -- &quot;</span> &lt;&lt; edge[<span class="number">2</span>] &lt;&lt; <span class="string">&quot; == &quot;</span> &lt;&lt; edge[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Let us create following weighted graph</span></span><br><span class="line"><span class="comment">                   10</span></span><br><span class="line"><span class="comment">              0--------1</span></span><br><span class="line"><span class="comment">              |  \     |</span></span><br><span class="line"><span class="comment">             6|   5\   |15</span></span><br><span class="line"><span class="comment">              |      \ |</span></span><br><span class="line"><span class="comment">              2--------3</span></span><br><span class="line"><span class="comment">                  4       */</span></span><br><span class="line">    <span class="function">Graph <span class="title">g</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    g.<span class="built_in">add_edge</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    g.<span class="built_in">add_edge</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">15</span>);</span><br><span class="line">    g.<span class="built_in">add_edge</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    g.<span class="built_in">add_edge</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">    g.<span class="built_in">add_edge</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Function call</span></span><br><span class="line">    Graph::<span class="built_in">kruskals_mst</span>(g);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考资料">参考资料</h3><ol type="1"><li>《数据结构C++版-邓俊辉》6.11 最小支撑树</li><li><a href="https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/">Kruskal’s Minimum Spanning Tree Algorithm | Greedy Algo-2 - GeeksforGeeks</a></li><li><a href="https://www.geeksforgeeks.org/prims-minimum-spanning-tree-mst-greedy-algo-5/?ref=lbp">Prim’s Minimum Spanning Tree (MST) | Greedy Algo-5 - GeeksforGeeks</a></li><li><a href="https://www.geeksforgeeks.org/union-find-algorithm-set-2-union-by-rank/">Union-Find Algorithm | Set 2 (Union By Rank and Path Compression) - GeeksforGeeks</a></li><li><a href="https://www.geeksforgeeks.org/prims-mst-for-adjacency-list-representation-greedy-algo-6/">Prim’s MST for Adjacency List Representation | Greedy Algo-6 - GeeksforGeeks</a></li><li><a href="https://zhuanlan.zhihu.com/p/93647900">算法学习笔记(1) : 并查集 - 知乎 (zhihu.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch Inplace Operation Notes</title>
      <link href="/hexo_zh/2022/09/25/bug/pytorch-inplace-operation-notes/"/>
      <url>/hexo_zh/2022/09/25/bug/pytorch-inplace-operation-notes/</url>
      
        <content type="html"><![CDATA[<p>最近在跑实验的时候遇到了这样一个Bug花了很久才解决，记录一下学习一波以免以后再遇到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RuntimeError: one of the variables needed for gradient computation has been modified by an inplace operation: [torch.cuda.FloatTensor [3</span><br><span class="line">, 64, 7, 7]] is at version 2; expected version 1 instead. Hint: enable anomaly detection to find the operation that failed to compute it</span><br><span class="line">s gradient, with torch.autograd.set_detect_anomaly(True).</span><br></pre></td></tr></table></figure><p><span id="more"></span></p><h3 id="关于inplace-operation">关于Inplace Operation</h3><p>首先，这个问题从报错中可以看到是由于inplace operation导致的。经过查找，inplace operation指的就是PyTorch在计算一个值的时候不创建新的变量进行复制，而是直接改变原来的变量的值。比如以下代码，第一个就不是inplace operation而后两个就是inplace operation。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = torch.rand(<span class="number">2</span>)</span><br><span class="line">y = torch.rand(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># non-inplace operation</span></span><br><span class="line">z = x + y</span><br><span class="line"><span class="comment"># inplace operation</span></span><br><span class="line">x.add_(y)</span><br><span class="line">x += y</span><br></pre></td></tr></table></figure><h3 id="解决过程">解决过程</h3><p>首先在网上搜到的资料都是说尽量移除掉所有的inplace operation，包括把Activation Layer的<code>inplace=True</code>去掉等等，但是都无法解决。然后就根据报错中的提示，使用<code>torch.autograd.set_detect_anomaly(True)</code>查找在哪里发生了inplace operation (参考<a href="https://github.com/pytorch/pytorch/issues/15803">Debugging feature for "modified by an inplace operation" errors · Issue #15803 · pytorch/pytorch · GitHub</a>)，最后提示如下报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[W python_anomaly_mode.cpp:104] Warning: Error detected in CudnnConvolutionBackward. Traceback of forward call that caused the error:</span><br><span class="line">  File &quot;./train.py&quot;, line 44, in &lt;module&gt;</span><br><span class="line">    model.optimize_parameters()</span><br><span class="line">  File &quot;xxxx.py&quot;, line 374, in optimize_parameters</span><br><span class="line">    self.backward_all_net()</span><br><span class="line">  File &quot;xxxx.py&quot;, line 273, in backward_all_net</span><br><span class="line">    _, _, _, fake_B_x6_processed = self.pixelnet(fake_B_x6)</span><br><span class="line">  File &quot;/usr/local/lib/python3.6/dist-packages/torch/nn/modules/module.py&quot;, line 1051, in _call_impl</span><br><span class="line">    return forward_call(*input, **kwargs)</span><br><span class="line">  File &quot;xxxx.py&quot;, line 282, in forward</span><br><span class="line">    output = self.model_3(feature_256)</span><br><span class="line">  File &quot;/usr/local/lib/python3.6/dist-packages/torch/nn/modules/module.py&quot;, line 1051, in _call_impl</span><br><span class="line">    return forward_call(*input, **kwargs)</span><br><span class="line">  File &quot;/usr/local/lib/python3.6/dist-packages/torch/nn/modules/container.py&quot;, line 139, in forward</span><br><span class="line">    input = module(input)</span><br><span class="line">  File &quot;/usr/local/lib/python3.6/dist-packages/torch/nn/modules/module.py&quot;, line 1051, in _call_impl</span><br><span class="line">    return forward_call(*input, **kwargs)</span><br><span class="line">  File &quot;/usr/local/lib/python3.6/dist-packages/torch/nn/modules/conv.py&quot;, line 443, in forward</span><br><span class="line">    return self._conv_forward(input, self.weight, self.bias)</span><br><span class="line">  File &quot;/usr/local/lib/python3.6/dist-packages/torch/nn/modules/conv.py&quot;, line 440, in _conv_forward</span><br><span class="line">    self.padding, self.dilation, self.groups)</span><br><span class="line"> (function _print_stack)</span><br><span class="line">RuntimeError: one of the variables needed for gradient computation has been modified by an inplace operation: [torch.cuda.FloatTensor [3</span><br><span class="line">, 64, 7, 7]] is at version 2; expected version 1 instead. Hint: the backtrace further above shows the operation that failed to compute i</span><br><span class="line">ts gradient. The variable in question was changed in there or anywhere later. Good luck!</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后发现貌似是在conv层发生了inplace operation，但是实在没有头绪，最后又找到一篇博文与我的情况非常类似(<a href="https://www.cnblogs.com/js2hou/p/13923089.html">RuntimeError: one of the variables needed for gradient computation has been modified by an inplace operation - Js2Hou - 博客园 (cnblogs.com)</a>)，最后发现是代码执行的顺序问题，原本的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">optimize_parameters</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">    self.backward_all_net()        </span><br><span class="line">    </span><br><span class="line">    self.optimizer_gridnet.zero_grad()</span><br><span class="line">    self.loss_gridnet.backward(retain_graph=<span class="literal">True</span>)</span><br><span class="line">    self.optimizer_gridnet.step()</span><br><span class="line"></span><br><span class="line">    self.optimizer_pixelnet.zero_grad()</span><br><span class="line">    self.loss_pixelnet.backward(retain_graph=<span class="literal">True</span>)</span><br><span class="line">    self.optimizer_pixelnet.step()</span><br><span class="line"></span><br><span class="line">    self.optimizer_depixelnet.zero_grad()</span><br><span class="line">    self.loss_depixelnet.backward()</span><br><span class="line">    self.optimizer_depixelnet.step()<span class="comment"># 出错处</span></span><br><span class="line"></span><br><span class="line">    self.optimizer_D_gridnet.zero_grad()</span><br><span class="line">    self.backward_D_gridnet()</span><br><span class="line">    self.optimizer_D_gridnet.step()</span><br><span class="line"></span><br><span class="line">    self.optimizer_D_pixelnet.zero_grad()</span><br><span class="line">    self.backward_D_pixelnet()</span><br><span class="line">    self.optimizer_D_pixelnet.step()</span><br><span class="line"></span><br><span class="line">    self.optimizer_D_depixelnet.zero_grad()</span><br><span class="line">    self.backward_D_depixelnet()</span><br><span class="line">    self.optimizer_D_depixelnet.step()</span><br></pre></td></tr></table></figure><p>修改后的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">optimize_parameters</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.optimizer_gridnet.zero_grad()</span><br><span class="line">    self.optimizer_pixelnet.zero_grad()</span><br><span class="line">    self.optimizer_depixelnet.zero_grad()</span><br><span class="line">    self.optimizer_D_gridnet.zero_grad()</span><br><span class="line">    self.optimizer_D_pixelnet.zero_grad()</span><br><span class="line">    self.optimizer_D_depixelnet.zero_grad()</span><br><span class="line"></span><br><span class="line">    self.backward_all_net()        </span><br><span class="line"></span><br><span class="line">    self.loss_gridnet.backward(retain_graph=<span class="literal">True</span>)</span><br><span class="line">    self.loss_pixelnet.backward(retain_graph=<span class="literal">True</span>)</span><br><span class="line">    self.loss_depixelnet.backward()</span><br><span class="line"></span><br><span class="line">    self.optimizer_gridnet.step()</span><br><span class="line">    self.optimizer_pixelnet.step()</span><br><span class="line">    self.optimizer_depixelnet.step()</span><br><span class="line"></span><br><span class="line">    self.backward_D_gridnet()</span><br><span class="line">    self.backward_D_pixelnet()</span><br><span class="line">    self.backward_D_depixelnet()</span><br><span class="line"></span><br><span class="line">    self.optimizer_D_gridnet.step()</span><br><span class="line">    self.optimizer_D_pixelnet.step()</span><br><span class="line">    self.optimizer_D_depixelnet.step()</span><br></pre></td></tr></table></figure><p>终于顺利解决！！！</p><h3 id="参考资料">参考资料</h3><ol type="1"><li><p><a href="https://zhuanlan.zhihu.com/p/38475183">关于 pytorch inplace operation, 需要知道的几件事 - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://blog.csdn.net/york1996/article/details/81835873">在PyTorch中in-place operation的含义_York1996的博客-CSDN博客_inplace operation</a></p></li><li><p><a href="https://github.com/pytorch/pytorch/issues/15803">Debugging feature for "modified by an inplace operation" errors · Issue #15803 · pytorch/pytorch · GitHub</a></p></li><li><p><a href="https://www.cnblogs.com/js2hou/p/13923089.html">RuntimeError: one of the variables needed for gradient computation has been modified by an inplace operation - Js2Hou - 博客园 (cnblogs.com)</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug </tag>
            
            <tag> PyTorch </tag>
            
            <tag> CV </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE脚本方案UnLua入门</title>
      <link href="/hexo_zh/2022/08/10/gamegraphics/ue-jiao-ben-fang-an-unlua-ru-men/"/>
      <url>/hexo_zh/2022/08/10/gamegraphics/ue-jiao-ben-fang-an-unlua-ru-men/</url>
      
        <content type="html"><![CDATA[<p>在实际的游戏开发中，由于C++编译需要比较长的时间，蓝图使用连线的方式也会产生一些问题，比如说蓝图节点太多比较混乱，对于习惯写代码的程序员们并不是特别友好，并且蓝图以及C++都需要进行编译，在实际游戏开发过程中还会有热更新的需求，这个时候脚本语言的优势就体现出来了。Lua是游戏开发中一个非常重要的脚本语言，其中UnLua是腾讯开源的为UE提供脚本支持的框架，已经在很多项目中使用。本篇主要是记录一下UnLua的使用过程中所遇到的问题，作为一篇学习笔记。UnLua入门的教程可以参考 <a href="https://github.com/Tencent/UnLua">Tencent/UnLua: A feature-rich, easy-learning and highly optimized Lua scripting plugin for UE. (github.com)</a>中的文档进行学习。</p><p><span id="more"></span></p><h2 id="unlua功能特性总结">UnLua功能特性总结</h2><p>从功能上来看，基本上只要是蓝图中能够做到的事情，UnLua基本上都可以替代完成。包括以下几类功能</p><ol type="1"><li>动画系统 (AnimNotify)</li><li>UMG UI系统 (UI的逻辑控制)</li><li>游戏的基本组成部分PlayerCharacter, PlayerController, GameMode</li><li>......</li></ol><p>UnLua对于UE中的一些特殊类和对象使用lua的接口重新实现了一遍，比如说UE中的容器，<code>UWorld</code>，<code>Delegate</code>，<code>UClass</code>, <code>UObject</code>等对象，具体路径实现在<code>/Plugins/UnLua/Private/BaseLib</code>下。</p><p>从特性上看，UnLua主要实现了以下特性。</p><ol type="1"><li>绑定Delegate/Event (目前只支持Dynamic Delegate)</li><li>继承关系</li><li>Lua动态加载UObject/UClass</li><li>Lua调用蓝图/c++</li><li>UE原生容器类</li><li>IInterface和Lua</li><li>垃圾回收机制</li><li>自定义Lua加载器</li></ol><h2 id="lua中动态创建对象和加载资源">Lua中动态创建对象和加载资源</h2><h3 id="创建umg-object">创建UMG Object</h3><ol type="1"><li><p>lua 中调用 NewObject 以及动态绑定：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> ProxyObj = NewObject(ObjClass, <span class="built_in">self</span>, <span class="literal">nil</span>, <span class="string">&quot;Objects.ProxyObject&quot;</span>)</span><br></pre></td></tr></table></figure><p>UnLua 中的 NewObject 可以接收四个参数，依次是：创建的 UClass、Outer、Name，以及动态绑定的 Lua 脚本路径。动态绑定即不在Editor中进行UnLua Bind，而是在创建对象的时候指定绑定的Lua脚本。动态绑定无法覆写蓝图中的事件，如<code>ReceiveBeginplay</code>，只是相当于对于蓝图的扩充，可以实现一些辅助性的功能。</p></li><li><p>创建 UMG 首先需要获取到 UI 的 UClass，然后使用 UWidgetBlueprintLibrary::Create 来创建，与 C++ 一致：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> UMG_C = UE4.UClass.Load(<span class="string">&quot;/Game/Test/BPUI_TestMain.BPUI_TestMain_C&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> UMG_TestMain_Ins = UE4.UWidgetBlueprintLibrary.Create(<span class="built_in">self</span>,UMG_C)</span><br><span class="line">UMG_TestMain_Ins:AddToViewport()</span><br></pre></td></tr></table></figure></li></ol><h3 id="load资产">Load资产</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> SoundObj = UE.UObject.Load(FootSoundAsset) <span class="comment">-- 加载对象</span></span><br><span class="line"><span class="keyword">local</span> ObjectClass = UE.UClass.Load(ClassPath) <span class="comment">-- 加载类</span></span><br></pre></td></tr></table></figure><h3 id="datatable在unlua中的使用">DataTable在UnLua中的使用</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UE.UDataTableFunctionLibrary.GetRowDataStructure(<span class="built_in">self</span>.VoiceeDataTable, row_name)</span><br></pre></td></tr></table></figure><h2 id="unlua遇到的一些坑">UnLua遇到的一些坑</h2><ol type="1"><li><p>UnLua比较大的局限性就在于它所调用的函数都必须是UFUNCTION，并且是在蓝图中可以访问的UFUNCTION，所以很多C++中经常调用的函数并非是UFUNCTION，在Lua中就没有办法调用到，比如说CreateWidget(), CreateDefaultSubobject()，等等，包括含有模板类的函数在Lua中也无法调用，所以我们在生成对象的时候一般使用NewObject创建对象。</p></li><li><p>一个可能导致UnLua绑定失效的错误：如果Lua中的函数定义冒号前的module名称有写错的，就会导致UnLua失效。比如在BP_Test_C.lua中如果存在于个<code>function BP_FalseTest_C:FuncName()</code>的函数，<code>BP_Test_C.lua</code>就会失效。</p></li><li><p>在使用UnLua中的<code>self.Overriden</code>的时候，一定要注意需要把参数写正确，如果不正确就很容易会crash，很浪费时间orz，其实也不是很复杂，但是一旦写错crash也不会有什么关键提示，比较耽误时间。正确写法如下</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 注意两个都是点(.)不是冒号(:)</span></span><br><span class="line"><span class="comment">-- 第一个参数是self，一定要写，后面跟着原函数的其他的参数</span></span><br><span class="line"><span class="comment">-- 参数不正确就会导致参数检查的时候crash，所以参数一定要写正确</span></span><br><span class="line"><span class="built_in">self</span>.Overridden.AddBackpackItem(<span class="built_in">self</span>, item_name)</span><br></pre></td></tr></table></figure></li><li><p>由于Lua中的Array默认的下标都是从1开始计数，所以UnLua的TArray也跟随了Lua这一习惯，下标从1开始，可能会导致写代码的时候有些混乱。</p></li></ol><h2 id="参考资料">参考资料</h2><ol type="1"><li><a href="https://github.com/Tencent/UnLua">Tencent/UnLua: A feature-rich, easy-learning and highly optimized Lua scripting plugin for UE. (github.com)</a></li><li><a href="https://imzlp.com/posts/36659/">UE 热更新：基于 UnLua 的 Lua 编程指南 | 循迹研究室 (imzlp.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Unreal Engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal Engine </tag>
            
            <tag> Lua </tag>
            
            <tag> Script Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UELogSystem</title>
      <link href="/hexo_zh/2022/07/27/gamegraphics/uelogsystem/"/>
      <url>/hexo_zh/2022/07/27/gamegraphics/uelogsystem/</url>
      
        <content type="html"><![CDATA[<h2 id="日志系统">日志系统</h2><h3 id="设置项目自定义日志category">设置项目自定义日志Category</h3><p>在ProjName.h中添加<code>DECLARE_LOG_CATEGORY_EXTERN(CategoryName, DefaultVerbosity, CompileTimeVerbosity);</code>，在ProjName.cpp中添加<code>DEFINE_LOG_CATEGORY(CategoryName);</code>。 实际上这两行宏展开后就是在头文件中申明了一个外部的结构体，然后在cpp文件中定义这个结构体</p><p><span id="more"></span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DECLARE_LOG_CATEGORY_EXTERN</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">FLogCategory</span>##<span class="title">CategoryName</span> :</span> <span class="keyword">public</span> FLogCategory&lt;ELogVerbosity::DefaultVerbosity, ELogVerbosity::CompileTimeVerbosity&gt; \</span><br><span class="line">&#123; \</span><br><span class="line">    FORCEINLINE FLogCategory##<span class="built_in">CategoryName</span>() : <span class="built_in">FLogCategory</span>(<span class="built_in">TEXT</span>(#CategoryName)) &#123;&#125; \</span><br><span class="line">&#125; CategoryName;\</span><br><span class="line"></span><br><span class="line"><span class="comment">// DEFINE_LOG_CATEGORY</span></span><br><span class="line">FLogCategory##CategoryName CategoryName;</span><br></pre></td></tr></table></figure><p>其中，参数<code>DefaultVerbosity</code>表示默认的级别，比改级别更高的都不会被Log，<code>CompileTimeVerbosity</code>表示编译代码的最高级别，任何比该级别高的Log代码都不会被编译。</p><h3 id="ue-log系统">UE Log系统</h3><table><thead><tr class="header"><th>Verbosity Level</th><th>Printed in Console?</th><th>Printed in Editor's Log?</th><th>Notes</th></tr></thead><tbody><tr class="odd"><td>Fatal</td><td>Yes</td><td>N/A</td><td>Crashes the session, even if logging is disabled</td></tr><tr class="even"><td>Error</td><td>Yes</td><td>Yes</td><td>Log text is coloured red</td></tr><tr class="odd"><td>Warning</td><td>Yes</td><td>Yes</td><td>Log text is coloured yellow</td></tr><tr class="even"><td>Display</td><td>Yes</td><td>Yes</td><td>Log text is coloured grey</td></tr><tr class="odd"><td>Log</td><td>No</td><td>Yes</td><td>Log text is coloured grey</td></tr><tr class="even"><td>Verbose</td><td>No</td><td>No</td><td></td></tr><tr class="odd"><td>VeryVerbose</td><td>No</td><td>No</td><td></td></tr></tbody></table><p>UE_LOG宏展开后如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; \</span><br><span class="line">    <span class="built_in">CA_CONSTANT_IF</span>((ELogVerbosity::Verbosity &amp; ELogVerbosity::VerbosityMask) &lt;= ELogVerbosity::COMPILED_IN_MINIMUM_VERBOSITY &amp;&amp; (ELogVerbosity::Warning &amp; ELogVerbosity::VerbosityMask) &lt;= FLogCategory##CategoryName::CompileTimeVerbosity) \</span><br><span class="line">    &#123; \</span><br><span class="line">        <span class="built_in">UE_INTERNAL_LOG_IMPL</span>(CategoryName, Verbosity, Format, ##__VA_ARGS__); \</span><br><span class="line">    &#125; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过Verbosity的层级判断是否需要进行Compile Log，然后调用UE_INTERNAL_LOG_IMPL宏：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">static_assert</span></span>(TIsArrayOrRefOfType&lt;<span class="keyword">decltype</span>(Format), TCHAR&gt;::Value, <span class="string">&quot;Formatting string must be a TCHAR array.&quot;</span>); \</span><br><span class="line"><span class="built_in"><span class="keyword">static_assert</span></span>((ELogVerbosity::Verbosity &amp; ELogVerbosity::VerbosityMask) &lt; ELogVerbosity::NumVerbosity &amp;&amp; ELogVerbosity::Verbosity &gt; <span class="number">0</span>, <span class="string">&quot;Verbosity must be constant and in range.&quot;</span>); \</span><br><span class="line"><span class="built_in">UE_LOG_EXPAND_IS_FATAL</span>(Verbosity, PREPROCESSOR_NOTHING, <span class="keyword">if</span> (!CategoryName.<span class="built_in">IsSuppressed</span>(ELogVerbosity::Verbosity))) \</span><br><span class="line">    &#123; \</span><br><span class="line">        <span class="built_in">DispatchCheckVerify</span>([] (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; LCategoryName, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; LFormat, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;... UE_LOG_Args) FORCENOINLINE \</span><br><span class="line">        &#123; \</span><br><span class="line">            <span class="built_in">TRACE_LOG_MESSAGE</span>(LCategoryName, Verbosity, LFormat, UE_LOG_Args...) \</span><br><span class="line">            <span class="built_in">UE_LOG_EXPAND_IS_FATAL</span>(Verbosity, \</span><br><span class="line">                &#123; \</span><br><span class="line">                    FMsg::<span class="built_in">Logf_Internal</span>(<span class="built_in">UE_LOG_SOURCE_FILE</span>(__FILE__), __LINE__, LCategoryName.<span class="built_in">GetCategoryName</span>(), ELogVerbosity::Verbosity, LFormat, UE_LOG_Args...); \</span><br><span class="line">                    _DebugBreakAndPromptForRemote(); \</span><br><span class="line">                    FDebug::<span class="built_in">ProcessFatalError</span>(<span class="built_in">PLATFORM_RETURN_ADDRESS</span>()); \</span><br><span class="line">                &#125;, \</span><br><span class="line">                &#123; \</span><br><span class="line">                    FMsg::<span class="built_in">Logf_Internal</span>(<span class="literal">nullptr</span>, <span class="number">0</span>, LCategoryName.<span class="built_in">GetCategoryName</span>(), ELogVerbosity::Verbosity, LFormat, UE_LOG_Args...); \</span><br><span class="line">                &#125; \</span><br><span class="line">            ) \</span><br><span class="line">        &#125;, CategoryName, Format, ##__VA_ARGS__); \</span><br><span class="line">        <span class="built_in">UE_LOG_EXPAND_IS_FATAL</span>(Verbosity, <span class="built_in">CA_ASSUME</span>(<span class="literal">false</span>);, PREPROCESSOR_NOTHING) \</span><br><span class="line">    &#125; \</span><br></pre></td></tr></table></figure><p><code>UE_LOG_EXPAND_IS_FATAL</code>宏用来指定Fatal和其他各自执行的代码，若不是Fatal，则会进行后面的判断，<code>IsSuppressed</code>函数用来判断当前Verbosity层级是否应该Log，也就是自定义中设定的DefaultVerbosity。最后的实际的Log代码就是<code>FMsg::Logf_Internal</code>函数，在这个函数中根据<code>OutputDevice</code>Log在相应的设备上。具体设备的输出通过<code>Serialize</code>接口实现。</p><h2 id="unlua-command-console接口">UnLua Command Console接口</h2><p>UE提供了一下几种自定义Console Command的方式：</p><ol type="1"><li><p>在GameMode，PlayerController，Pawn（Character）中重载<code>ProcessConsoleExec</code>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AMyGameModeBase::ProcessConsoleExec</span><span class="params">(<span class="keyword">const</span> TCHAR* Cmd, FOutputDevice&amp; Ar, UObject* Executor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FPlatformString::<span class="built_in">Stricmp</span>(Cmd, <span class="built_in">TEXT</span>(<span class="string">&quot;Test4&quot;</span>)) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (TObjectIterator&lt;UObject&gt; It; It; ++It)</span><br><span class="line">        &#123;</span><br><span class="line">            UObject* <span class="keyword">const</span> Obj = *It;</span><br><span class="line">            UWorld <span class="keyword">const</span>* <span class="keyword">const</span> ObjWorld = Obj-&gt;<span class="built_in">GetWorld</span>();</span><br><span class="line">            <span class="keyword">if</span> (ObjWorld == <span class="built_in">GetWorld</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">bool</span> bSucceeded = Obj-&gt;<span class="built_in">CallFunctionByNameWithArguments</span>(Cmd, Ar, <span class="literal">nullptr</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Super::<span class="built_in">ProcessConsoleExec</span>(Cmd, Ar, Executor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在GameMode，PlayerController，Pawn (Character)中直接定义<code>UFUNCTION(Exec)</code>函数，就可以在Console中输入FunctionName直接调用。</p></li><li><p>在关卡蓝图中添加Custom Event，在Console中使用ce+eventName的方式调用。</p></li><li><p>在任意蓝图类添加Custom Event，在Console中使用ke + &lt;Class Name&gt; + &lt;Function Name&gt;的方式调用，UE会匹配到相应的蓝图类（支持正则），在找到的所有蓝图类中找到所有相同事件名称的事件进行调用。</p></li></ol><p>通过第二种方式在C++中定义一个接口，通过蓝图实现这个接口，就可以在UnLua中实现command相应的操作</p><h2 id="参考资料">参考资料</h2><ol type="1"><li><a href="https://unrealcommunity.wiki/logging-lgpidy6i">Logging-Unreal Community Wiki</a></li><li><a href="https://blog.csdn.net/maxiaosheng521/article/details/107788415">UE4 使用自定义的Console Command</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Unreal Engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal Engine </tag>
            
            <tag> Log System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unreal Engine 学习资料收藏</title>
      <link href="/hexo_zh/2022/07/21/gamegraphics/unreal-engine-xue-xi-zi-liao-shou-cang/"/>
      <url>/hexo_zh/2022/07/21/gamegraphics/unreal-engine-xue-xi-zi-liao-shou-cang/</url>
      
        <content type="html"><![CDATA[<p>用于记录Unreal Engine的学习路线以及资料收藏，持续更新，每学习一部分记录一下，作为学习游戏开发以及图形学的路线经历。</p><p>Unreal Engine学习路线参考<a href="https://www.zhihu.com/question/459078565/answer/1886346828">UE4技术方向学习路线如何安排</a></p><p>对于一个模块而言，Unreal Engine<a href="https://docs.unrealengine.com/5.0/zh-CN/">官方的教程以及文档</a>已经包括了很多的内容，初学可以从这些教程入手，开始熟悉每一个模块。另外，官方UE4以及UE5都有一些示例，可以去看这些示例里的实现进行学习。</p><p><span id="more"></span></p><h3 id="c基础">C++基础</h3><ol type="1"><li>《C++ Primer》</li><li><a href="https://www.runoob.com/cplusplus/cpp-tutorial.html">C++ 教程 | 菜鸟教程 (runoob.com)</a></li><li>对于UE中的C++编程，可以看UE4 Cook Book (Unreal Engine4 Scripting With C++)这本书，虽然是全英文的，但是讲的也比较容易，大概跟着敲一敲代码也不会难度太大。</li><li>官方文档C++教程</li></ol><h3 id="蓝图入门">蓝图入门</h3><p>目前网上蓝图的资料比较丰富，因为可能连线比较容易入门一些，可以先从一些简单的官方文档入手。</p><ol type="1"><li><p>了解蓝图与蓝图之间的通信方式<a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/Blueprints/UserGuide/BlueprintCommsUsage/">蓝图通信用法 | 虚幻引擎文档 (unrealengine.com)</a></p><ul><li><p>直接蓝图通信</p></li><li><p>事件分配器</p></li><li><p>蓝图接口</p></li><li><p>蓝图投射</p></li></ul></li><li><p>了解蓝图与C++、Lua之间的互相调用</p></li><li><p>剩下的就是熟悉蓝图函数，多上手操练，熟能生巧</p></li></ol><h3 id="脚本语言unluasluapurets">脚本语言（UnLua，slua，PureTS）</h3><ol type="1"><li>选择一个脚本语言框架进行学习即可，我学习的是UnLua，sLua现在似乎已经不再更新了，UnLua目前还在继续更新当中。</li><li>UnLua的基本使用。<a href="https://github.com/Tencent/UnLua">Github-UnLua</a></li><li>使用插件(EmmyLua, LuaPanda)进行UnLua代码智能提示以及Debug。<a href="https://github.com/EmmyLua">EmmyLua-Github</a></li><li>了解UnLua原理，阅读UnLua源码。</li></ol><h3 id="角色3c控制">角色3C控制</h3><p>PlayerCharacter, PlayerController, PlayerCamera</p><h3 id="动画">动画</h3><h3 id="umg">UMG</h3><h3 id="材质球">材质球</h3><h3 id="游戏ai行为树">游戏AI行为树</h3><h3 id="游戏引擎架构">游戏引擎架构</h3><ol type="1"><li>《游戏引擎架构》</li><li>InsideUE5 - 知乎 (zhihu.com)](https://www.zhihu.com/column/insideue4) 知乎专栏，讲解UE架构比较详细。</li></ol><h3 id="设计模式">设计模式</h3><p><a href="https://gpp.tkchu.me/">游戏编程模式</a>。掌握常见的设计模式，单例模式，工厂模式，观察者模式，组件模式等等，学习中。</p><h3 id="图形学">图形学</h3><p><a href="https://learnopengl.com/">Learn OpenGL, extensive tutorial resource for learning Modern OpenGL</a> OpenGL推荐学习网站，图形API的学习，也能够学到很多图形学的基础知识，理论与实践相结合</p><p><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">GAMES101: 现代计算机图形学入门 (ucsb.edu)</a> 图形学入门课程，大神老师闫令琪授课，讲的通俗易懂，比较适合作为教程学习图形学，完成作业差不多就算是完成了几个比较简单的小型渲染器了，还是比较有意思的。</p><p><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games202.html">GAMES202: 高质量实时渲染 (ucsb.edu)</a> Games101的进阶课程，正在学习当中。</p><p><a href="https://games104.boomingtech.com/sc/">Games 104: 现代游戏引擎：从入门到实践 (boomingtech.com)</a> 王希老师的游戏引擎课程，个人感觉难度还是比较大的，准备学习完202之后再回过头来看，如果直接上手看的话可能只能当做introduction听一听，因为游戏引擎的内容还是比较多的。</p>]]></content>
      
      
      <categories>
          
          <category> Unreal Engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal Engine </tag>
            
            <tag> Study Route </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理-颜色距离</title>
      <link href="/hexo_zh/2022/07/10/computervision/tu-xiang-chu-li-yan-se-ju-chi/"/>
      <url>/hexo_zh/2022/07/10/computervision/tu-xiang-chu-li-yan-se-ju-chi/</url>
      
        <content type="html"><![CDATA[<p>颜色距离是衡量颜色与颜色之间相似程度的一个概念。颜色距离越近代表了两个颜色越接近，最简单的一种表示就是两个颜色在RGB颜色空间中的欧式距离，但是由于人眼感知的问题，衍生出了RGB以外的一些计算颜色距离的方式。 <span id="more"></span></p><h2 id="rgb-距离">RGB 距离</h2><p><span class="math inline">\(\Delta_{RGB}=\sqrt{(R_2-R_1)^2+(G_2-G_1)^2+(B_2-B_1)^2}\)</span></p><p>根据维基百科，我们还可以加上一定的权重使得结果更加符合人类的感知，比如说2、4、3（虽然我也不知道这是怎么来的）<span class="math inline">\(\Delta_{RGB}=\sqrt{2(R_2-R_1)^2+4(G_2-G_1)^2+3(B_2-B_1)^2}\)</span></p><p>当然联想到欧式距离，自然就会联想到曼哈顿距离，个人认为也可以算作是一种计算颜色距离的方式<span class="math inline">\(\Delta_{RGB}=|R_2-R_1|+|G_2-G_1|+|B_2-B_1|\)</span></p><h2 id="cielab-距离">CIELAB 距离</h2><p>颜色空间不仅仅只有RGB，还有XYZ，CMYK，LAB，SRGB，HSV等等，理论上说每一种都可以使用欧式距离作为颜色空间，但其中CIELAB是专门为了符合人类感官而设定的颜色空间。</p><blockquote><p>L<em>”代表感知的亮度、“a</em>”和“b*”代表人类视觉的四种独特颜色：红色、绿色、蓝色和黄色。——《维基百科》</p></blockquote><p>然后事情就变得容易起来了，我们只需要将我们的RGB颜色转化为LAB颜色就可以了。在维基百科上还看到了很多CIE颜色距离的版本，最简单的是CIE76，即LAB空间中的欧式距离，其他的还有CIE94，CIEDE2000等，比较复杂这里就不再讨论，有兴趣可以自行研究。</p><h3 id="rgb-to-lab">RGB to LAB</h3><p>如何将RGB=&gt;Lab呢，可以很简单的使用一行OpenCV进行实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lab_image = cv2.cvtColor(input_image, cv2.COLOR_RGB2LAB)</span><br></pre></td></tr></table></figure><p>具体的实现原理在OpenCV官方文档里有相关介绍，具体的我们需要先将RGB转化为XYZ，然后再通过以下公式最终得到LAB颜色</p><figure><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/image-20220908234421818.png" alt="image-20220908234421818" /><figcaption aria-hidden="true">image-20220908234421818</figcaption></figure><h2 id="参考资料">参考资料</h2><ol type="1"><li><a href="https://zh.m.wikipedia.org/zh-hans/颜色差异">颜色差异 - 维基百科，自由的百科全书 (wikipedia.org)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像像素画生成方法总结（图像下采样）</title>
      <link href="/hexo_zh/2022/07/10/computervision/tu-pian-xia-cai-yang-duo-chong-fang-fa-zong-jie/"/>
      <url>/hexo_zh/2022/07/10/computervision/tu-pian-xia-cai-yang-duo-chong-fang-fa-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>图片的上采样和下采样分别对应图片的放大和缩小，在对图像进行采样的过程中会造成不同程度的模糊。图像的像素画生成采用的方法就是图片下采用的方法。本文会对图像像素化的方法进行总结。</p><span id="more"></span><h1 id="传统的插值方法">传统的插值方法</h1><p>首先，从<code>OpenCV</code>中的<code>cv2.resize()</code>中所采用的方法来看，传统的图片采样方法主要分为以下几种 (括号中为在<code>OpenCV</code>中的插值Flag)： 1. Nearest Neighbor (INTER_NEAREST) 2. Linear Interpolation (INTER_LINEAR) 3. Bicubic Interpolation (INTER_CUBIC) 4. Area Interpolation (INTER_AREA) 5. Lanczos interpolation (INTER_LANCZOS4)</p><p>我们定义一张图片为一个<code>ndarray</code>，image width <span class="math inline">\(= W\)</span>, image height <span class="math inline">\(= H\)</span>, 所以<code>image.shape = (W, H, 3)</code>, 目标图片的image width <span class="math inline">\(= TW\)</span>, image height <span class="math inline">\(= TH\)</span>, <code>output.shape = (TW, TH, 3)</code>。得出长和宽的缩放比分别为<span class="math inline">\(TW/W, TH/H\)</span>。 ## 最近插值 (Nearest Neighbor) 最简单直观的一种插值方法。只需要从目标图像的坐标映射到原图像后，找到临近的坐标即可。比如对于target image的<span class="math inline">\((i,j)\)</span>像素，映射到原图像上就是<span class="math inline">\((i\times\frac{W}{TW}, j\times\frac{H}{TH})\)</span>，然后四舍五入就是对应的原图像的像素坐标。</p><h2 id="线性插值-linear-interpolation">线性插值 (Linear Interpolation)</h2><p>比较常见的插值算法。得到原图像上对应的坐标后，使用双线性插值，得到对应的像素值。下图为双线性插值的示意图。 <img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/20220710205724.png" /> ## 双三次插值 (Bicubic Interpolation) 双三次插值就更加复杂一些。比起线性插值的根据周围四个点进行插值，双三次插值需要用到周围的16个点进行加权。 ## 区域插值法 (Area Interpolation) Area Interpolation对我个人来说实际上更加符合直觉，也就是根据图片的缩放比，找到生成的目标的图像所对应的一块区域，对该区域进行加权平均，事实上这种方法在缩放普通图像的时候感觉能够较好的保留原本图像的特征，缺点就是边缘会显得非常模糊，所以不是很利于对图像进行像素化。 ## Lanczos重采样 Lanczos在形式上和双三次插值有着相似之处，通过一个内核函数计算每个像素对应的权重。<a href="https://en.wikipedia.org/wiki/Lanczos_resampling">Lanczos resampling-维基百科</a>。</p><h1 id="其他进行像素画的方法">其他进行像素画的方法</h1><p>除了传统的插值方法，还有以下几种方法进行图片下采样生成像素画。 1. Content-Adaptive [^2^](https://johanneskopf.de/publications/downscaling) 2. Perceptual based downscaling [^3^](https://dl.acm.org/doi/10.1145/2766891) 3. Image Abstraction Method [^4^](https://gfx.cs.princeton.edu/pubs/Gerstner_2012_PIA/index.php) 4. Deep Unsupervised Downscaling [^5^](https://www.cse.cuhk.edu.hk/~ttwong/papers/pixel/pixel.html)，使用深度学习GAN的方式进行图片生成，可以较好的保留图片的边缘，减少由于边界所造成的模糊效果。</p><p>未完待续</p><h1 id="参考资料">参考资料</h1><ol type="1"><li><a href="https://docs.opencv.org/4.5.1/da/d54/group__imgproc__transform.html#ga5bb5a1fea74ea38e1a5445ca803ff121">OpenCV-Geometric Image Transformations</a></li><li><a href="https://johanneskopf.de/publications/downscaling/">Content-Adaptive Image Downscaling</a></li><li><a href="https://dl.acm.org/doi/10.1145/2766891">Perceptually based downscaling of images</a></li><li><a href="https://gfx.cs.princeton.edu/pubs/Gerstner_2012_PIA/index.php">Pixelated Image Abstraction</a></li><li><a href="https://www.cse.cuhk.edu.hk/~ttwong/papers/pixel/pixel.html">Deep Unsupervised Pixelization</a></li><li><a href="https://blog.csdn.net/u010468553/article/details/79359488">Lanczos 重采样 - CSDN</a></li><li><a href="https://zh.m.wikipedia.org/zh-hans/%E5%8F%8C%E4%B8%89%E6%AC%A1%E6%8F%92%E5%80%BC">双三次插值-维基百科</a></li><li><a href="https://www.youtube.com/watch?v=poY_nGzEEWM">一个Bicubic讲的很清楚的youtube-Bicubic Interpolation - Computerphile</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> CV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Rider和Emmylua进行UnLua配置</title>
      <link href="/hexo_zh/2022/06/27/gamegraphics/shi-yong-rider-he-emmylua-jin-xing-unlua-pei-zhi/"/>
      <url>/hexo_zh/2022/06/27/gamegraphics/shi-yong-rider-he-emmylua-jin-xing-unlua-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p>在Rider中配置UnLua环境就可以使用同一个IDE同时进行c++和Lua的开发，不用切换vscode和Visual Studio，并且Rider更加美观，操作逻辑和代码提示也比Visual Studio加番茄插件更加好用。所以还是非常推荐使用Rider进行UE的开发的。</p><span id="more"></span><h3 id="emmylua配置intellisence">Emmylua配置IntelliSence</h3><p>首先在Rider中下载插件EmmyLua，EmmyLua提供了代码提示语法检查等功能。然后打开项目，如果按照UnLua仓库中的指示正确安装插件后，UE的界面就会出现下图中的图标，点击Generate IntelliSense，UnLua就会生成出代码智能提示文件夹。</p><p><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/20220627232545.png" /></p><p>然后，在Rider中点击Solution面板中的Show All Files按钮即可显示所有文件，</p><p><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/20220627232907.png" /></p><p>找到项目的Lua文件夹(Content/Scipts)以及IntelliSense文件夹(Plugins/Unlua/Intermediate/IntelliSense)，分别右键，Tools-&gt;Attach to Solution就可以添加到Solution中进行Index，这样子代码自动补全功能就配置完成了。之后取消Show All Files就可以再次隐藏不需要的文件但是Scripts文件夹还是在的。</p><p><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/20220627233258.png" /></p><h3 id="使用emmylua进行debug">使用EmmyLua进行Debug</h3><p>目前还没有成功用EmmyLua进行Debug过orz，不知道为什么就是没法Debug，最后还是放弃了，换回了VSCode+LuaHelper，使用LuaPanda进行Debug，没有那么麻烦。似乎LuaHelper的注解功能好像有增强，用下来还是不错的，不过在一个IDE里写代码的想法破灭了lol。</p><p>（2022.7.10 更新）最后发现Luahelper的代码提示时不时会抽搐，会显示错误或者显示不出来，vscode就只用来debug用了，实际开发写代码的时候还是选择使用Rider在一个IDE中写代码还是更爽！</p>]]></content>
      
      
      <categories>
          
          <category> Unreal Engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal Engine </tag>
            
            <tag> IDE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch计算两组三维坐标两两之间的距离</title>
      <link href="/hexo_zh/2022/03/01/computervision/pytorch-ji-suan-liang-zu-san-wei-zuo-biao-liang-liang-zhi-jian-de-ju-chi/"/>
      <url>/hexo_zh/2022/03/01/computervision/pytorch-ji-suan-liang-zu-san-wei-zuo-biao-liang-liang-zhi-jian-de-ju-chi/</url>
      
        <content type="html"><![CDATA[<p>最近需要实现一项功能，就是给定两组三维点云坐标，对两组点的距离进行两两计算，并找出在一定阈值内的点的组合。如果使用暴力运算，时间复杂度就是O(N^2)，显然速度太慢了，所以我们尝试直接使用torch进行计算，大大提高速度。</p><span id="more"></span><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">a = torch.rand(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">b = torch.rand(<span class="number">10</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">a[:, None, :] - b进行了broadcast,得到的就是坐标两两相减后的值</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">distance = torch.sqrt(torch.<span class="built_in">sum</span>((a[:, <span class="literal">None</span>, :] - b) ** <span class="number">2</span>, dim=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;distance&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(distance)</span><br><span class="line"></span><br><span class="line">mask = distance &lt; <span class="number">0.5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mask&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(mask)</span><br><span class="line"></span><br><span class="line">index = torch.nonzero(mask) <span class="comment"># 返回非0的下标</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;index&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(index)</span><br></pre></td></tr></table></figure><blockquote><p>代码运行结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">tensor([[0.2741, 0.8714, 0.5854],</span><br><span class="line">        [0.8175, 0.8641, 0.2401],</span><br><span class="line">        [0.1289, 0.9932, 0.3749],</span><br><span class="line">        [0.3695, 0.4058, 0.2191],</span><br><span class="line">        [0.6861, 0.1120, 0.3103]])</span><br><span class="line">b</span><br><span class="line">tensor([[0.9155, 0.1202, 0.9625],</span><br><span class="line">        [0.0423, 0.4589, 0.2079],</span><br><span class="line">        [0.9433, 0.1332, 0.2282],</span><br><span class="line">        [0.1004, 0.3019, 0.7923],</span><br><span class="line">        [0.2260, 0.8069, 0.7035],</span><br><span class="line">        [0.8703, 0.1508, 0.0516],</span><br><span class="line">        [0.2816, 0.5019, 0.8916],</span><br><span class="line">        [0.6481, 0.6959, 0.8508],</span><br><span class="line">        [0.6603, 0.8579, 0.1735],</span><br><span class="line">        [0.9677, 0.2180, 0.4303]])</span><br><span class="line">distance</span><br><span class="line">tensor([[1.0573, 0.6052, 1.0585, 0.6303, 0.1429, 1.0770, 0.4800, 0.4911, 0.5648,</span><br><span class="line">         0.9654],</span><br><span class="line">        [1.0415, 0.8753, 0.7417, 1.0655, 0.7536, 0.7397, 0.9181, 0.6558, 0.1709,</span><br><span class="line">         0.6900],</span><br><span class="line">        [1.3138, 0.5664, 1.1935, 0.8081, 0.3900, 1.1679, 0.7292, 0.7646, 0.5842,</span><br><span class="line">         1.1435],</span><br><span class="line">        [0.9655, 0.3316, 0.6354, 0.6417, 0.6451, 0.5865, 0.6850, 0.7489, 0.5395,</span><br><span class="line">         0.6616],</span><br><span class="line">        [0.6914, 0.7384, 0.2708, 0.7820, 0.9216, 0.3200, 0.8085, 0.7966, 0.7588,</span><br><span class="line">         0.3239]])</span><br><span class="line">mask</span><br><span class="line">tensor([[False, False, False, False,  True, False,  True,  True, False, False],</span><br><span class="line">        [False, False, False, False, False, False, False, False,  True, False],</span><br><span class="line">        [False, False, False, False,  True, False, False, False, False, False],</span><br><span class="line">        [False,  True, False, False, False, False, False, False, False, False],</span><br><span class="line">        [False, False,  True, False, False,  True, False, False, False,  True]])</span><br><span class="line">index</span><br><span class="line">tensor([[0, 4],</span><br><span class="line">        [0, 6],</span><br><span class="line">        [0, 7],</span><br><span class="line">        [1, 8],</span><br><span class="line">        [2, 4],</span><br><span class="line">        [3, 1],</span><br><span class="line">        [4, 2],</span><br><span class="line">        [4, 5],</span><br><span class="line">        [4, 9]])</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> Pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
            <tag> Python </tag>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学入门笔记2：Basic Ray Tracing-Games101作业5</title>
      <link href="/hexo_zh/2022/02/28/gamegraphics/tu-xing-xue-ru-men-bi-ji-2-basic-ray-tracing-games101-zuo-ye-5/"/>
      <url>/hexo_zh/2022/02/28/gamegraphics/tu-xing-xue-ru-men-bi-ji-2-basic-ray-tracing-games101-zuo-ye-5/</url>
      
        <content type="html"><![CDATA[<p>Games101作业5实现笔记以及Witted Style Ray Tracing和Moller Trumbore Algorithm笔记</p><span id="more"></span><h2 id="witted-style-光线追踪">Witted Style 光线追踪</h2><p>最基础最原始的光线追踪算法。根据光路的可逆性，我们从眼睛处朝着像素点发射一道光线，这道光线与场景中的物体相交会发生反射和折射，这里我们默认反射是镜面反射，产生的两道光线会继续和场景中的物体相交产生新的折射光线和反射光线，这就是光线追踪的基本原理。如果不加以限制，光路的反射和折射会不断进行下去，所以我们需要设置一个反射深度限制。</p><p><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/image-20220912001300536.png" /></p><p>接下来就是如何与场景中的物体求交的问题了，光线的方程为<span class="math inline">\(\mathbf{r}(t)=\mathbf{o}+t\mathbf{d}\)</span>，<span class="math inline">\(\mathbf{o}\)</span>表示发射出光线的点，<span class="math inline">\(\mathbf{d}\)</span>表示光线发射的方向单位向量，<span class="math inline">\(t(t&gt;0 )\)</span>可以理解为“时间”，代表从发射光线的点到交点的距离。如果是和规则的可以用方程表示出来的物体比如说球型等进行求交，那么可以直接联立光线和物体表面的方程算出解即可。但是实际情况中大部分的物体都是采用Mesh的方式，所以我们的光线就需要和场景中的一个个三角形表面进行求交，这个时候就需要用到Moller Trumbore Algorithm。 $$ <span class="math display">\[\begin{align}\vec{\mathbf{O}}+t\vec{\mathbf{D}}&amp;=(1-b_1-b_2)\vec{\mathbf{P_0}}+b_1\vec{\mathbf{P_1}}+b_2\vec{\mathbf{P_2}} \\\left[      \begin{matrix}        t \\        b_1 \\        b_2     \end{matrix}\right] &amp;=\frac{1}{\mathbf{\vec{S_1}\cdot\vec{E_1}}}\left[    \begin{matrix}        \mathbf{\vec{S_2}\cdot\vec{E_2}} \\        \mathbf{\vec{S_1}\cdot\vec{S}} \\        \mathbf{\vec{S_2}\cdot\vec{D}} \\    \end{matrix}\right], \\\text{where } \vec{\mathbf{E_1}} &amp;=\mathbf{\vec{P_1}-\vec{P_0}}, \\\vec{\mathbf{E_2}} &amp;= \vec{\mathbf{P_2}}-\vec{\mathbf{P_0}},\\\vec{\mathbf{S}} &amp;= \vec{\mathbf{O}}-\vec{\mathbf{P_0}},\\\vec{\mathbf{S_1}} &amp;= \vec{\mathbf{D}}-\vec{\mathbf{E_2}},\\\vec{\mathbf{S_2}} &amp;= \vec{\mathbf{S}}-\vec{\mathbf{E_1}},\\\end{align}\]</span> $$</p><p>其中<span class="math inline">\(P_0,P_1,P_2\)</span>是三角形的三个顶点，这里使用了重心坐标来表示三角形内的任意一点。利用这个等式解出正数<span class="math inline">\(t\)</span>，就可以得到交点坐标，这也就是作业5中我们需要实现的算法。</p><h2 id="作业5相关代码实现">作业5相关代码实现</h2><p>本次作业主要实现两个函数</p><ol type="1"><li><p><code>Triangle.hpp</code>的<code>rayTriangleIntersect()</code>函数，这个函数就是用来计算光线和三角形求交的，代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">rayTriangleIntersect</span><span class="params">(<span class="keyword">const</span> Vector3f&amp; v0, <span class="keyword">const</span> Vector3f&amp; v1, <span class="keyword">const</span> Vector3f&amp; v2, <span class="keyword">const</span> Vector3f&amp; orig,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">const</span> Vector3f&amp; dir, <span class="keyword">float</span>&amp; tnear, <span class="keyword">float</span>&amp; u, <span class="keyword">float</span>&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Implement this function that tests whether the triangle</span></span><br><span class="line">    <span class="comment">// that&#x27;s specified bt v0, v1 and v2 intersects with the ray (whose</span></span><br><span class="line">    <span class="comment">// origin is *orig* and direction is *dir*)</span></span><br><span class="line">    <span class="comment">// Also don&#x27;t forget to update tnear, u and v.</span></span><br><span class="line">    <span class="keyword">auto</span> S = orig - v0;</span><br><span class="line">    <span class="keyword">auto</span> E_1 = v1 - v0;</span><br><span class="line">    <span class="keyword">auto</span> E_2 = v2 - v0;</span><br><span class="line">    <span class="keyword">auto</span> S_1 = <span class="built_in">crossProduct</span>(dir, E_2);</span><br><span class="line">    <span class="keyword">auto</span> S_2 = <span class="built_in">crossProduct</span>(S, E_1);</span><br><span class="line">    <span class="keyword">auto</span> S1E1  = <span class="built_in">dotProduct</span>(S_1, E_1);</span><br><span class="line">    <span class="keyword">float</span> t = <span class="built_in">dotProduct</span>(S_2, E_2) / S1E1;</span><br><span class="line">    <span class="keyword">float</span> b_1 = <span class="built_in">dotProduct</span>(S_1, S) / S1E1;</span><br><span class="line">    <span class="keyword">float</span> b_2 = <span class="built_in">dotProduct</span>(S_2, dir) / S1E1;</span><br><span class="line">    <span class="keyword">if</span> (t &gt;= <span class="number">0.0f</span> &amp;&amp; b_1 &gt;= <span class="number">0.0f</span> &amp;&amp; b_2 &gt;= <span class="number">0.0f</span> &amp;&amp; (<span class="number">1</span> - b_1 - b_2) &gt;= <span class="number">0.0f</span>) &#123;</span><br><span class="line">        tnear = t;</span><br><span class="line">        u = b_1;</span><br><span class="line">        v = b_2;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二个函数是<code>Renderer.cpp</code>中的<code>Render()</code>，主要是考察屏幕空间和世界空间之间的转化问题，代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [comment]</span></span><br><span class="line"><span class="comment">// The main render function. This where we iterate over all pixels in the image, generate</span></span><br><span class="line"><span class="comment">// primary rays and cast these rays into the scene. The content of the framebuffer is</span></span><br><span class="line"><span class="comment">// saved to a file.</span></span><br><span class="line"><span class="comment">// [/comment]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Renderer::Render</span><span class="params">(<span class="keyword">const</span> Scene&amp; scene)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;Vector3f&gt; <span class="title">framebuffer</span><span class="params">(scene.width * scene.height)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> scale = std::<span class="built_in">tan</span>(<span class="built_in">deg2rad</span>(scene.fov * <span class="number">0.5f</span>));</span><br><span class="line">    <span class="keyword">float</span> imageAspectRatio = scene.width / (<span class="keyword">float</span>)scene.height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use this variable as the eye position to start your rays.</span></span><br><span class="line">    <span class="function">Vector3f <span class="title">eye_pos</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; scene.height; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; scene.width; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// generate primary ray direction</span></span><br><span class="line">            <span class="comment">// Find the x and y positions of the current pixel to get the direction</span></span><br><span class="line">            <span class="comment">// vector that passes through it.</span></span><br><span class="line">            <span class="comment">// Also, don&#x27;t forget to multiply both of them with the variable *scale*, and</span></span><br><span class="line">            <span class="comment">// x (horizontal) variable with the *imageAspectRatio*</span></span><br><span class="line">            <span class="keyword">float</span> x = (<span class="number">2</span> * (i + <span class="number">0.5f</span>) / (<span class="keyword">float</span>)(scene.width<span class="number">-1</span>) - <span class="number">1.0f</span>) * imageAspectRatio * scale;</span><br><span class="line">            <span class="keyword">float</span> y = (<span class="number">1</span> - <span class="number">2</span> * (j + <span class="number">0.5f</span>) / (<span class="keyword">float</span>)(scene.height<span class="number">-1</span>)) * scale;</span><br><span class="line"></span><br><span class="line">            Vector3f dir = <span class="built_in">normalize</span>(<span class="built_in">Vector3f</span>(x, y, <span class="number">-1</span>)); <span class="comment">// Don&#x27;t forget to normalize this direction!</span></span><br><span class="line">            framebuffer[m++] = <span class="built_in">castRay</span>(eye_pos, dir, scene, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">UpdateProgress</span>(j / (<span class="keyword">float</span>)scene.height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save framebuffer to file</span></span><br><span class="line">    FILE* fp = <span class="built_in">fopen</span>(<span class="string">&quot;binary-test.ppm&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    (<span class="keyword">void</span>)<span class="built_in">fprintf</span>(fp, <span class="string">&quot;P6\n%d %d\n255\n&quot;</span>, scene.width, scene.height);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; scene.height * scene.width; ++i) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> color[<span class="number">3</span>];</span><br><span class="line">        color[<span class="number">0</span>] = (<span class="keyword">char</span>)(<span class="number">255</span> * <span class="built_in">clamp</span>(<span class="number">0</span>, <span class="number">1</span>, framebuffer[i].x));</span><br><span class="line">        color[<span class="number">1</span>] = (<span class="keyword">char</span>)(<span class="number">255</span> * <span class="built_in">clamp</span>(<span class="number">0</span>, <span class="number">1</span>, framebuffer[i].y));</span><br><span class="line">        color[<span class="number">2</span>] = (<span class="keyword">char</span>)(<span class="number">255</span> * <span class="built_in">clamp</span>(<span class="number">0</span>, <span class="number">1</span>, framebuffer[i].z));</span><br><span class="line">        <span class="built_in">fwrite</span>(color, <span class="number">1</span>, <span class="number">3</span>, fp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fclose</span>(fp);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>最终生成的结果如下</p><p><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/output.jpg" /></p><h2 id="参考资料">参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/431092843">Games101-作业5 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode编译.cpp文件出现中文乱码解决方案</title>
      <link href="/hexo_zh/2022/02/25/bug/g-bian-yi.cpp-wen-jian-chu-xian-zhong-wen-luan-ma-jie-jue-fang-an/"/>
      <url>/hexo_zh/2022/02/25/bug/g-bian-yi.cpp-wen-jian-chu-xian-zhong-wen-luan-ma-jie-jue-fang-an/</url>
      
        <content type="html"><![CDATA[<h1 id="vscode编译.cpp文件出现中文乱码解决方案">vscode编译.cpp文件出现中文乱码解决方案</h1><p>在vscode中编译.cpp文件，可以使用vscode中的插件code runner点击按钮运行，如果熟悉如何使用g++的命令也可以直接使用命令行语句编译运行。但是如果文件中出现了中文字符，就会出现编译之后生成乱码的问题。比如这一段代码（来源于<a href="https://www.runoob.com/cplusplus/cpp-data-types.html">菜鸟教程</a>）</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;type: \t\t&quot;</span> &lt;&lt; <span class="string">&quot;************size**************&quot;</span>&lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;bool: \t\t&quot;</span> &lt;&lt; <span class="string">&quot;所占字节数：&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">bool</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最大值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="keyword">bool</span>&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t\t最小值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="keyword">bool</span>&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;char: \t\t&quot;</span> &lt;&lt; <span class="string">&quot;所占字节数：&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最大值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="keyword">char</span>&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t\t最小值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="keyword">char</span>&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;signed char: \t&quot;</span> &lt;&lt; <span class="string">&quot;所占字节数：&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">signed</span> <span class="keyword">char</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最大值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="keyword">signed</span> <span class="keyword">char</span>&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t\t最小值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="keyword">signed</span> <span class="keyword">char</span>&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;unsigned char: \t&quot;</span> &lt;&lt; <span class="string">&quot;所占字节数：&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最大值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t\t最小值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wchar_t: \t&quot;</span> &lt;&lt; <span class="string">&quot;所占字节数：&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">wchar_t</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最大值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="keyword">wchar_t</span>&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t\t最小值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="keyword">wchar_t</span>&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;short: \t\t&quot;</span> &lt;&lt; <span class="string">&quot;所占字节数：&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">short</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最大值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="keyword">short</span>&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t\t最小值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="keyword">short</span>&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int: \t\t&quot;</span> &lt;&lt; <span class="string">&quot;所占字节数：&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最大值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="keyword">int</span>&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最小值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="keyword">int</span>&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;unsigned: \t&quot;</span> &lt;&lt; <span class="string">&quot;所占字节数：&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">unsigned</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最大值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="keyword">unsigned</span>&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最小值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="keyword">unsigned</span>&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;long: \t\t&quot;</span> &lt;&lt; <span class="string">&quot;所占字节数：&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">long</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最大值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="keyword">long</span>&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最小值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="keyword">long</span>&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;unsigned long: \t&quot;</span> &lt;&lt; <span class="string">&quot;所占字节数：&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最大值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最小值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;double: \t&quot;</span> &lt;&lt; <span class="string">&quot;所占字节数：&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">double</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最大值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="keyword">double</span>&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最小值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="keyword">double</span>&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;long double: \t&quot;</span> &lt;&lt; <span class="string">&quot;所占字节数：&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">long</span> <span class="keyword">double</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最大值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最小值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;float: \t\t&quot;</span> &lt;&lt; <span class="string">&quot;所占字节数：&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>); </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最大值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="keyword">float</span>&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最小值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="keyword">float</span>&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size_t: \t&quot;</span> &lt;&lt; <span class="string">&quot;所占字节数：&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">size_t</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最大值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="keyword">size_t</span>&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最小值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="keyword">size_t</span>&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;string: \t&quot;</span> &lt;&lt; <span class="string">&quot;所占字节数：&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(string) &lt;&lt; endl;  </span><br><span class="line">    <span class="comment">// &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;string&gt;::max)() &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;string&gt;::min)() &lt;&lt; endl;  </span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;type: \t\t&quot;</span> &lt;&lt; <span class="string">&quot;************size**************&quot;</span>&lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果直接运行的话结果是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type:           ************size**************</span><br><span class="line">bool:           鎵€鍗犲瓧鑺傛暟锛?</span><br></pre></td></tr></table></figure><p>程序运行到乱码的部分就直接结束了，这个问题可以通过以下方法解决。</p><h3 id="更改文件编码类型">1. 更改文件编码类型</h3><p>在vscode左下角有一个选择编码的按钮，默认是<code>utf-8</code>编码，点击之后再点击通过编码重新打开，一般情况下第一个选项后面会有'通过文件内容猜测'，如果没有，可以搜索GBK，将编码设置为GBK（汉字编码），注意：这个时候如果再更改回utf-8，所有的中文在编辑器中显示都会是乱码，但是编译还是没有问题的。还有一种改变编码的方式，就是用记事本打开，然后另存为，在编码一栏里选择ANSI，然后编译运行就可以了。（这个时候在vscode中的代码还是会乱码的，所以还是建议使用上一种方法）</p><h3 id="命令行操作">2. 命令行操作</h3><p>如果不改变代码的编码类型，可以在编译的时候设置编译的编码类型。在运行时使用一下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -fexec-charset=GBK test.cpp -o test</span><br></pre></td></tr></table></figure><p>使用GBK编码生成一个可执行文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.exe</span><br></pre></td></tr></table></figure><p>运行这个可执行文件</p><p>得到结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">type:         ************size**************</span><br><span class="line">bool:         所占字节数：1    最大值：1        最小值：0</span><br><span class="line">char:         所占字节数：1    最大值：        最小值：?</span><br><span class="line">signed char:     所占字节数：1    最大值：        最小值：?</span><br><span class="line">unsigned char:     所占字节数：1    最大值：?        最小值：</span><br><span class="line">wchar_t:     所占字节数：4    最大值：2147483647        最小值：-2147483648</span><br><span class="line">short:         所占字节数：2    最大值：32767        最小值：-32768</span><br><span class="line">int:         所占字节数：4    最大值：2147483647    最小值：-2147483648</span><br><span class="line">unsigned:     所占字节数：4    最大值：4294967295    最小值：0</span><br><span class="line">long:         所占字节数：8    最大值：9223372036854775807    最小值：-9223372036854775808</span><br><span class="line">unsigned long:     所占字节数：8    最大值：18446744073709551615    最小值：0</span><br><span class="line">double:     所占字节数：8    最大值：1.79769e+308    最小值：2.22507e-308</span><br><span class="line">long double:     所占字节数：16    最大值：1.18973e+4932    最小值：3.3621e-4932</span><br><span class="line">float:         所占字节数：4    最大值：3.40282e+38    最小值：1.17549e-38</span><br><span class="line">size_t:     所占字节数：8    最大值：18446744073709551615    最小值：0</span><br><span class="line">string:     所占字节数：24</span><br><span class="line">type:         ************size**************</span><br></pre></td></tr></table></figure><p>参考博客：<a href="https://blog.csdn.net/weixin_33720452/article/details/85970159">g++编译后中文显示乱码解决方案(c++)</a></p>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Three.js使用贝塞尔曲线绘制心形</title>
      <link href="/hexo_zh/2022/02/10/gamegraphics/three-js-shi-yong-bei-sai-er-qu-xian-hui-zhi-xin-xing/"/>
      <url>/hexo_zh/2022/02/10/gamegraphics/three-js-shi-yong-bei-sai-er-qu-xian-hui-zhi-xin-xing/</url>
      
        <content type="html"><![CDATA[<p>贝塞尔曲线是图形学中非常重要的知识，是绘制曲线以及曲面的基础，在很多地方都有着非常广泛的应用，比如Photoshop里的钢笔工具，字体设计，各种过渡动画等等。本文将记录贝塞尔曲线的原理公式，以及使用Three.js中的贝塞尔曲线API进行简单的心形绘制。</p><span id="more"></span><h3 id="贝塞尔曲线详解">贝塞尔曲线详解</h3><p>贝塞尔曲线就是在起始点和终止点之间，设置控制点，通过控制点的移动来控制曲线的形状。根据控制点数量的不同，可以将贝塞尔曲线分为一阶曲线、二阶曲线、三阶曲线……等等。</p><h4 id="一阶曲线">一阶曲线</h4><p>一阶曲线非常简单，因为没有控制点，所以就是一条从起始点到终止点的线段。</p><h4 id="二阶曲线">二阶曲线</h4><figure><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/image-20220210111040096.png" alt="image-20220210111040096" /><figcaption aria-hidden="true">image-20220210111040096</figcaption></figure><p>二阶曲线由起始点、终止点和一个控制点组成。贝塞尔曲线由以下规则形成：对于[0, 1]内任何t，在<span class="math inline">\(b_0b_1\)</span>上取一个点<span class="math inline">\(b_0^1\)</span>，满足<span class="math inline">\(b_0b_0^1\)</span>和<span class="math inline">\(b_0^1b_1\)</span>的关系为<span class="math inline">\(t : 1-t\)</span>，同样的，在在<span class="math inline">\(b_1b_2\)</span>上取一个点<span class="math inline">\(b_1^1\)</span>，满足<span class="math inline">\(b_1b_1^1\)</span>和<span class="math inline">\(b_1^1b_2\)</span>的关系为<span class="math inline">\(t : 1-t\)</span>。最后将<span class="math inline">\(b_0^1b_1^1\)</span>相连，在<span class="math inline">\(b_0^1b_1^1\)</span>上继续取一点满足<span class="math inline">\(b_0^1b_0^2:b_0^2b_1^1=t:1-t\)</span>。所有的t所形成的<span class="math inline">\(b_0^2\)</span>形成一道曲线，这道曲线就是贝塞尔曲线。对应的点的坐标在向量表示下很容易表示出来： <span class="math display">\[\vec{b^1_0}(t)=(1-t)\vec{b_0}+t\vec b_1 \\\vec{b^1_1}(t)=(1-t)\vec{b_1}+t\vec b_2 \\\vec{b^2_0}(t)=(1-t)\vec{b_0^1}+t\vec b_1^1 \\\Rightarrow \vec{b_0^2}(t)=(1-t)^2\vec b_0 + 2t(1-t)\vec{b_1}+t^2\vec b_2\]</span></p><h4 id="三阶以及多阶曲线">三阶以及多阶曲线</h4><p>类似于二阶曲线，三阶以及多阶贝塞尔曲线也是采用同样的方法，不断进行迭代，每一个t确定一个点，最后形成一条曲线。</p><figure><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/image-20220210112920807.png" alt="image-20220210112920807" /><figcaption aria-hidden="true">image-20220210112920807</figcaption></figure><p>计算贝塞尔曲线有一个对于任意阶通用的公式：<strong>德卡斯特里奥算法</strong> (De Casteljau's algorithm)，是一种递归的计算贝塞尔曲线的方法： <span class="math display">\[\vec b^n(t)=\vec b_0^n(t)=\sum_{j=0}^n\vec b_jB_j^n(t)\text{, where }\vec b_j \text{ is the Bernstein polynomial} \\\text{Bernstein polynomial: }B^n_t(t)=\tbinom{n}{t}t^i(1-t)^{n-i}\]</span></p><h3 id="使用three.js中的贝塞尔曲线绘制心形">使用Three.js中的贝塞尔曲线绘制心形</h3><h4 id="绘制圆形">绘制圆形</h4><p>我们首先可以通过贝塞尔曲线绘制出一个圆形，心形可以在圆形的基础上进行一定的控制点的调整就可以绘制而成。</p><figure><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/aEsuA.png" alt="aEsuA" /><figcaption aria-hidden="true">aEsuA</figcaption></figure><p>从上图中可以看出，一个圆形可以被分成四个弧线，每条弧线可以通过一个三阶贝塞尔曲线绘制而成（两个控制点），控制点的位置在<a href="https://stackoverflow.com/questions/1734745/how-to-create-circle-with-bézier-curves">geometry - How to create circle with Bézier curves? - Stack Overflow</a>已经有人计算好了，我们可以直接使用（这里的计算也并不是特别复杂，简单的数学知识就可以计算出来）。由此，我们可以通过贝塞尔曲线创建出一个圆的形状：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> radius = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> c = <span class="number">0.551915024494</span> * radius;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> heartShape = <span class="keyword">new</span> THREE.Shape()</span><br><span class="line">    .moveTo(x, y+radius)</span><br><span class="line">    .bezierCurveTo(x+c,y+radius, x+radius, y+c, x+radius, y)</span><br><span class="line">    .bezierCurveTo(x+radius,y-c, x+c, y-radius, x, y-radius)</span><br><span class="line">    .bezierCurveTo(x-c,y-radius, x-radius, y-c, x-radius, y)</span><br><span class="line">    .bezierCurveTo(x-radius,y+c, x-c, y+radius, x, y+radius)</span><br></pre></td></tr></table></figure><p><code>bezierCurveTo()</code>是Three.js中的贝塞尔曲线的API，它接受六个参数，前四个分别是两个控制点的x,y坐标，最后两个是终止点的x,y坐标。这里只需要设定好参数，使用四段贝塞尔曲线一一绘制出来就可以了。</p><h4 id="绘制心形">绘制心形</h4><p>心形其实就是在圆形的基础上移动了三个控制点的位置，将y轴上上方的起始点稍向下移动，以及下方左右两个控制点向上移动，就可以绘制出一个心形，代码以及效果图如下所示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> radius = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> c = <span class="number">0.551915024494</span> * radius;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> heartShape = <span class="keyword">new</span> THREE.Shape()</span><br><span class="line">    .moveTo(x, y+radius/<span class="number">3</span>)</span><br><span class="line">    .bezierCurveTo(x+c,y+radius, x+radius, y+c, x+radius, y)</span><br><span class="line">    .bezierCurveTo(x+radius,y-c, x+c, y-radius/<span class="number">2</span>, x, y-radius)</span><br><span class="line">    .bezierCurveTo(x-c,y-radius/<span class="number">2</span>, x-radius, y-c, x-radius, y)</span><br><span class="line">    .bezierCurveTo(x-radius,y+c, x-c, y+radius, x, y+radius/<span class="number">3</span>)</span><br></pre></td></tr></table></figure><figure><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/heart.gif" alt="heart" /><figcaption aria-hidden="true">heart</figcaption></figure><h3 id="参考资料">参考资料</h3><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=11">GAMES101-现代计算机图形学入门-闫令琪_哔哩哔哩_bilibili</a></p><p><a href="https://zh.wikipedia.org/wiki/德卡斯特里奥算法">德卡斯特里奥算法 - 维基百科，自由的百科全书 (wikipedia.org)</a></p><p><a href="https://threejs.org/docs/#api/en/extras/core/Path.bezierCurveTo">Path#bezierCurveTo – three.js docs (threejs.org)</a></p><p><a href="https://github.com/GcsSloop/AndroidNote/blob/master/CustomView/Advance/%5B06%5DPath_Bezier.md">AndroidNote_Path_BezierGcsSloop/AndroidNote (github.com)</a></p><p><a href="https://stackoverflow.com/questions/1734745/how-to-create-circle-with-bézier-curves">geometry - How to create circle with Bézier curves? - Stack Overflow</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> 前端 </tag>
            
            <tag> Three.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BugMysql:Access Denied for user &#39;root&#39;@&#39;localhost&#39;</title>
      <link href="/hexo_zh/2021/11/21/bug/bugmysql-access-denied-for-user-root-localhost/"/>
      <url>/hexo_zh/2021/11/21/bug/bugmysql-access-denied-for-user-root-localhost/</url>
      
        <content type="html"><![CDATA[<p>终于将困扰了很长时间的mysql的Bug解决了。朋友在macOS上的mysql每次进入的时候都会弹出<code>Access denied......</code>的错误提示，经过长时间的上网搜索未果，今天终于有机会将其解决。</p><p><span id="more"></span></p><p>我在Ubuntu上部署mysql的时候发现，如果没有sudo权限的话，直接输入<code>mysql -u root -p</code>进入mysql的话，即使密码正确也是会<code>access denied</code>，只要又sudo权限就能进入，所以mysql的root也是需要os的root权限的。由于我想远程从本地的可视化database navigator远程对数据库进行操作，如果想要连接到root，就会提示<code>access denied</code>，究其原因还是因为ssh连接到远程服务器上的时候不会给sudo权限。这个时候我们就只能够新创建一个user，给这个user近似root的权限，来达到全程操作的效果。</p><p>首先，打开mysql路径下的my.cnf，找到bind-address这一行，改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind-address=0.0.0.0</span><br></pre></td></tr></table></figure><p>接下来<code>sudo mysql -u root -p</code>进入mysql，然后输入以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#x27;myuser&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;mypass&#x27;;</span><br><span class="line">CREATE USER &#x27;myuser&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;mypass&#x27;;</span><br><span class="line">GRANT ALL ON *.* TO &#x27;myuser&#x27;@&#x27;localhost&#x27;;</span><br><span class="line">GRANT ALL ON *.* TO &#x27;myuser&#x27;@&#x27;%&#x27;;</span><br><span class="line">flush privileges;</span><br><span class="line">// myuser就是你的username</span><br></pre></td></tr></table></figure><p>然后就可以用新创建的这个user进行远程访问数据库了</p><p>参考资料</p><p><a href="https://stackoverflow.com/questions/16287559/mysql-adding-user-for-remote-access">Mysql adding user for remote access</a></p>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：数组中的逆序对</title>
      <link href="/hexo_zh/2021/11/06/algorithms/suan-fa-shu-zu-zhong-de-ni-xu-dui/"/>
      <url>/hexo_zh/2021/11/06/algorithms/suan-fa-shu-zu-zhong-de-ni-xu-dui/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>数组中的逆序对是数据结构和算法中的一道经典题目。如果<code>A[i]&gt;A[j]</code>并且<code>i&lt;j</code>，那么这就算是一组逆序对。题目要求给定一个数组，求出数组中逆序对的个数</p><blockquote><p>输入：[7,5,6,4]</p><p>输出：5</p></blockquote><span id="more"></span><h2 id="题解">题解</h2><p>本题可以使用排序的思想，因为在排序中我们发现的不符合排列顺序的数组对都是一组逆序对，我们只需要计算出在排序的过程中交换的次数即可。本题中可以采用时间复杂度为O(logn)的归并排序。代码如下：</p><p>基本思路和归并排序是一样的，如果对归并排序的代码不理解的可以先看一看<a href="https://lucas-hao.github.io/2021/07/26/suan-fa-pai-xu-suan-fa/">排序算法</a>。</p><p>唯一需要注意的地方就是归并的时候的逆序对计算，当我们发现right小于left的时候，right同时也小于left后面的所有元素，我们增加的个数就是mid-left+1（merge函数）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] aux; <span class="comment">// copy of the origin array</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        aux = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">return</span> subReversePairs(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">subReversePairs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        count += subReversePairs(nums, lo, mid);</span><br><span class="line">        count += subReversePairs(nums, mid+<span class="number">1</span>, hi);</span><br><span class="line">        <span class="comment">// 优化：如果左侧最大小于右侧最小，那么就不需要进行归并了</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= nums[mid+<span class="number">1</span>]) <span class="keyword">return</span> count;</span><br><span class="line">        count += merge(nums, lo, mid, hi);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++) aux[i] = nums[i];</span><br><span class="line">        <span class="keyword">int</span> left = lo, right  = mid+<span class="number">1</span>, index = lo;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= mid &amp;&amp; right &lt;= hi) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aux[left] &lt;= aux[right]) nums[index++] = aux[left++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (aux[left] &gt; aux[right]) &#123;</span><br><span class="line">                nums[index++] = aux[right++];</span><br><span class="line">                count += mid - left + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= mid) nums[index++] = aux[left++];</span><br><span class="line">        <span class="keyword">while</span> (right &lt;= hi) nums[index++] = aux[right++];</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学入门笔记1：图形学中的数学</title>
      <link href="/hexo_zh/2021/10/30/gamegraphics/tu-xing-xue-ru-men-bi-ji-1-tu-xing-xue-zhong-de-shu-xue/"/>
      <url>/hexo_zh/2021/10/30/gamegraphics/tu-xing-xue-ru-men-bi-ji-1-tu-xing-xue-zhong-de-shu-xue/</url>
      
        <content type="html"><![CDATA[<p>数学在图形学中是非常重要的基础，本篇简要记录一下图形学之中的一些数学基础和技巧</p><span id="more"></span><h2 id="线性代数基础">线性代数基础</h2><p>线代在图形学中是非常重要的数学。在图形学中，一些基础的线性代数知识是必须要掌握的，比如向量与矩阵的相关运算</p><ul><li>Vector Addition, Scalar Multiplication, Scalar Product, Normalization, Cross Product</li><li>Vector Cross Product: <span class="math inline">\(V_1\times V_2=u|V_1||V_2|\sin\theta=\left|\begin{matrix}u_x &amp; u_y &amp; u_z \\ v_{1x} &amp; v_{1y} &amp; v_{1z} \\ v_{2x} &amp; v_{2y} &amp; v_{2z} \end{matrix}\right|\)</span></li><li>Vector Cross product properties: 1. <span class="math inline">\(V_1 \times V_2 = -(V_2 \times V_1)\)</span> (不符合交换律) 2. <span class="math inline">\(V_1 \times (V_2 \times V_3) \neq (V_1 \times V_2) \times V_3\)</span> (不符合交换律) 3. <span class="math inline">\(V_1 \times (V_2 + V_3)=V_1 \times V_2 + V_1 \times V_3\)</span> (符合结合律)</li><li>Matrix-matrix multiplication， Matrix-vector multiplication</li></ul><h2 id="二维三维变换与齐次坐标系">二维三维变换与齐次坐标系</h2><p>利用线性代数中的向量和矩阵，我们可以表示出在二维平面和三维空间中点线面的位置与相应的关系。首先，我们需要引入齐次坐标的概念，为了简便，以下都以三维空间中的齐次坐标为例。普通的三维坐标表示为<span class="math inline">\((x,y,z)\)</span>，但是在齐次坐标系中，我们添加一个维度<span class="math inline">\(w\)</span>用来标明该坐标为向量还是，如果是空间中的点就是1，如果是向量就是0，并且齐次坐标满足以下规则，<span class="math inline">\((x,y,z,w)=(x/w,y/w,z/w,1)\)</span>，即原坐标与每个维度乘以相同的数之后得到的坐标是等价的。通过齐次坐标系，我们就可以得到常见的基本变换的矩阵表示。</p><ol type="1"><li><p>平移 (Translation) <span class="math display">\[\text{Translation: }\left(\begin{matrix}1 &amp; 0 &amp; 0 &amp; T_x \\0 &amp; 1 &amp; 0 &amp; T_y \\0 &amp; 0 &amp; 1 &amp; T_z \\0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right)\text{, Inverse: }\left(\begin{matrix}1 &amp; 0 &amp; 0 &amp; -T_x \\0 &amp; 1 &amp; 0 &amp; -T_y \\0 &amp; 0 &amp; 1 &amp; -T_z \\0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right)\]</span></p></li><li><p>缩放 (Scaling) <span class="math display">\[\text{Scaling:}\left(\begin{matrix}S_x &amp; 0 &amp; 0 &amp; 0 \\0 &amp; S_y &amp; 0 &amp; 0 \\0 &amp; 0 &amp; S_z &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right)\]</span></p></li><li><p>旋转 (Rotation) 逆时针 <span class="math display">\[R_x(\alpha)=\left(\begin{matrix}1 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; \cos{\alpha} &amp; -\sin{\alpha} &amp; 0 \\0 &amp; \sin{\alpha} &amp; \cos{\alpha} &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right),R_y(\alpha)=\left(\begin{matrix}\cos{\alpha} &amp; 0 &amp; \sin{\alpha} &amp; 0 \\0 &amp; 1 &amp; 0 &amp; 0 \\-\sin{\alpha} &amp; 0 &amp; \cos{\alpha} &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right),R_z(\alpha)=\left(\begin{matrix}\cos{\alpha} &amp; -\sin{\alpha} &amp; 0 &amp; 0 \\\sin{\alpha} &amp; \cos{\alpha} &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right),\]</span> 绕着轴<span class="math inline">\(n\)</span>旋转角度<span class="math inline">\(\alpha\)</span> (Rodrigues' Rotation Formula) <span class="math display">\[R(n,\alpha)=\cos(\alpha)\mathbf{I}+(1-\cos(\alpha))\mathbf{nn^T}+\sin(\alpha)\underbrace{\left(\begin{matrix}0 &amp; -n_z &amp; n_y \\n_z &amp; 0 &amp; -n_x \\-n_y &amp; n_x &amp; 0\end{matrix}\right)}\]</span> 欧拉角：<span class="math inline">\(R_{xyz}(\alpha, \beta,\gamma)=R_x(\alpha)R_y(\beta)R_z(\gamma)\)</span>:</p><p>桶滚 (roll), 偏航 (yaw), 俯仰 (pitch)</p><p><img src="https://i.loli.net/2021/10/31/8Mug69ZUWynx2eC.png" height = "200" alt="图片名称" align=center /></p><blockquote><p><strong>补充: </strong>旋转除了使用坐标进行计算之外，还可以使用四元数进行计算，四元数这里推荐两个YouTube视频</p><ul><li><a href="https://www.youtube.com/watch?v=3BR8tK-LuB0">Fantastic Quaternions - Numberphile - YouTube</a></li><li><a href="https://www.youtube.com/watch?v=d4EgbgTm0Bg">Visualizing quaternions (4d numbers) with stereographic projection - YouTube</a></li></ul></blockquote></li></ol><h2 id="二维与三维几何的基础知识">二维与三维几何的基础知识</h2><h3 id="二维几何知识">二维几何知识</h3><ol type="1"><li><p>计算点到直线距离 [<span class="math inline">\(A(x_1,y_1),B(x_2,y_2),P(x,y)\)</span>]</p><ul><li>直线方向向量：<span class="math inline">\(\vec{v}=(x_2-x_1, y_2-y_1)=(d_x,d_y)\)</span></li><li>直线的法线向量 (垂直于直线)：<span class="math inline">\(\vec{n}=(-d_y,d_x)=(y_1-y_2,x_2-x_1)\)</span></li><li><span class="math inline">\(\vec{n},\vec{v}\)</span>转化为单位向量 (Normalization)</li><li>向量点乘找到距离: <span class="math inline">\(h=|(P-A)\cdot \hat{n}|\)</span></li></ul></li><li><p>两条直线相交（非常简单）</p></li><li><p>给定一个点<span class="math inline">\(P\)</span>和一条直线<span class="math inline">\(AB\)</span>，判断点在直线的哪一侧</p><p>使用三角形的有向面积 (Signed area) <span class="math inline">\(\gamma=\frac{1}{2}Det\left|\begin{matrix}x_a &amp; x_b &amp; x \\ y_a &amp; y_b &amp; y \\ 1 &amp; 1 &amp; 1\end{matrix}\right|, \begin{cases}\gamma&gt;0,left\\\gamma&lt;0,right\\\gamma=0,on\space line\end{cases}\)</span></p></li></ol><p><img src="https://i.loli.net/2021/10/31/iqGdoEm9ukIJfjM.png" height = "200" alt="图片名称" align=center /></p><p>​ 多边形的有向面积：<span class="math inline">\(polygon\space area=\frac{1}{2}\sum{Det\left|\begin{matrix}x_i &amp; x_{i+1} \\ y_i &amp; y_{i+1}\end{matrix}\right|}\)</span> (Note: 不能忘记最后一个点和第一个点)</p><ol type="1"><li><p>判断点是否在多边形内部1</p><ol type="1"><li><p>法一：使用(3)的方法判断点在多边形的每一条边的哪一侧，进而判断点是否在多边形的内部</p></li><li><p>法二：如果一个点在多边形内部，过这个点任意做一条直线，与多边形的边的交点个数为奇数，如果为偶数，说明这个点在多边形的外部 （注意：还有一些特殊情况需要考虑）</p><p><img src="https://i.loli.net/2021/10/31/sfeOKyQblIcTU7L.png" height = "200" alt="图片名称" align=center /></p></li></ol></li></ol><h3 id="三维几何知识">三维几何知识</h3><ol type="1"><li><p>线性差值 (Linear Interpolation) [Lerp]: <span class="math inline">\(V=V_0+t(V_1-V_0)\)</span> (点<span class="math inline">\(V\)</span>在<span class="math inline">\(V_0\)</span>和<span class="math inline">\(V_1\)</span>的直线上移动 )</p></li><li><p>质心坐标 (Barycentric coordinate)</p><p><span class="math inline">\(P=\alpha P_0+\beta P_1 + \gamma P_2 \text{ where } \alpha+\beta+\gamma=1,A_0=\alpha A, A_1=\beta A,A_2=\gamma A\)</span></p></li><li><p>球面线性差值 (Spherical Linear Interpolation) [Slerp]</p><p><span class="math inline">\(\vec{V(t)}=\vec{V_0}\frac{\sin((1-t)\theta)}{\sin\theta}+\vec{V_1}\frac{\sin(t\theta)}{\sin\theta}\)</span> (<span class="math inline">\(V\)</span>在<span class="math inline">\(V_0\)</span>和<span class="math inline">\(V_1\)</span>之间的弧线上移动 )</p></li><li><p>三角形的法线，假设三角形三个顶点<span class="math inline">\(V_0,V_1,V_2\)</span>，将两条边按照逆时针方向进行叉乘，得到的结果就是三角形的法线 <span class="math display">\[\vec{n}=(V_1-V_0)\times(V_2-V_0) \text{ OR } (V_1-V_1) \cdots\]</span></p></li><li><p>顶点的法线: 取周围多个面的法线的平均值</p></li></ol><blockquote><p>本篇笔记基于上课的课件以及Games101进行整理</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：数组中第k大的数</title>
      <link href="/hexo_zh/2021/10/21/algorithms/suan-fa-shu-zu-zhong-di-k-da-de-shu/"/>
      <url>/hexo_zh/2021/10/21/algorithms/suan-fa-shu-zu-zhong-di-k-da-de-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>数组中第k大的数是一道十分经典的题目，题目表述可以如下</p><blockquote><p>You are given a set S of n integers in an array and also an integer k ∈ [1, n]. Design an algorithm to find the k-th largest integer of S.</p><p>给定 一个数组，返回数组中第k大的元素</p></blockquote><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p><a href="https://leetcode-cn.com/problems/xx4gT2/">剑指 Offer II 076. 数组中的第 k 大的数字 - 力扣（LeetCode） (leetcode-cn.com)</a></p><span id="more"></span><h2 id="题解">题解</h2><h3 id="分治算法快速排序">分治算法（快速排序）</h3><p>首先，一个非常简单的思路，我们直接先将整个数组进行排序，然后就可以直接找到第k大的数字了，这样的时间复杂度是O(nlogn)。但是实际上，我们并不需要将整个数组进行排序，我们在排序的过程中已经可以找到第k大的元素。下面这个算法就是基于快速排序算法找出了第k大的数字(参考《算法导论》以及课上的课件)。</p><p>算法思路：首先在数组中随机选取一个下标当做pivot，然后进行partition，将比pivot的值大的放在左侧，比pivot的值小的放在右侧，接下来分三种情况：</p><blockquote><ol type="1"><li>pivot==k-1, 我们就已经找到了第k大的元素</li><li>pivot&lt;k-1, 我们需要在pivot之后的数字中找到第k-pivot-1大的元素</li><li>pivot&gt;k-1, 我们需要在pivot之前的数字中找到第k大的元素</li></ol><p>（注：这里是k-1是因为pivot是下标从0开始，k从1开始）</p></blockquote><p>我们还可以对这个算法进行一定的优化，如果说我们随机选取的pivot的位置非常靠左或者靠右，那么这个时候我们在递归之前可能只能排除掉非常少的部分元素，我们可以希望pivot落在数组范围的中间1/3部分，如果不在的话，我们重新选择一个pivot (实际上感觉这样子提升的效果也不是很好？)下面是代码部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KSelection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Comparable <span class="title">kSelectionSort</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; arr.length || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> quickKSelection(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Comparable <span class="title">quickKSelection</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo == hi) <span class="keyword">return</span> arr[hi];</span><br><span class="line">        <span class="keyword">int</span> pivot = partition(arr, lo, hi);</span><br><span class="line">        <span class="keyword">if</span> (pivot &gt; k) <span class="keyword">return</span> quickKSelection(arr, lo, pivot - <span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pivot &lt; k) <span class="keyword">return</span> quickKSelection(arr, pivot + <span class="number">1</span>, hi, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> arr[pivot];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot= random.nextInt(hi-lo+<span class="number">1</span>)+lo;</span><br><span class="line">        swap(arr, pivot, lo);</span><br><span class="line">        pivot = lo;</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[++i].compareTo(arr[pivot]) &gt; <span class="number">0</span>) <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span> (arr[pivot].compareTo(arr[--j]) &gt; <span class="number">0</span> ) <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">            swap(arr, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, pivot, j);</span><br><span class="line">        pivot = j;</span><br><span class="line">        <span class="keyword">if</span> (pivot &gt;= lo + (hi - lo) / <span class="number">3</span> &amp;&amp; pivot &lt;= hi - (hi - lo) / <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> pivot;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> partition(arr, lo, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Comparable temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(f(n)\le O(n)+f(\lceil2n/3\rceil)\)</span>,根据Master's theorem, 时间复杂度为O(n)。空间复杂度：函数递归占用栈空间O(logn)。</p><h3 id="最大堆">最大堆</h3><p>另一个思路也非常容易，就是维护一个大根堆，然后依次将每个元素压入队列中，然后最后将最上面k-1个元素依次弹出，现在堆顶的元素就是数组中第k大的元素。时间复杂度O(nlogn)。代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Collections.reverseOrder());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) queue.add(num);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) queue.poll();</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试-Jane Street 电面</title>
      <link href="/hexo_zh/2021/09/27/other/mian-shi-jane-street-dian-mian/"/>
      <url>/hexo_zh/2021/09/27/other/mian-shi-jane-street-dian-mian/</url>
      
        <content type="html"><![CDATA[<p>今天刚面了Jane Street (HK) 的电面，再次感慨自己也太菜了，不过也权当积累经验了orz</p><p><span id="more"></span></p><p>面试题目其实不难，主要是让你去实现一个类做一个小游戏，规则如下</p><p>有一个横向无限的棋盘，有R和B两个玩家，两个玩家轮流下棋，如下图所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   B   B B</span><br><span class="line"> B R   R R</span><br><span class="line">   R R B R R B</span><br><span class="line">-------- =&gt; place an R at index 1 --------</span><br><span class="line">-1 0 1 2  -1 0 1 2</span><br></pre></td></tr></table></figure><p>如果下的位置上已经有棋子，那么在它的最底部插入一个棋子，在上图中就是在index为1处插入一个R，首先面试小哥让我实现一个move() function，就是放置棋子的函数</p><p>实现好了之后，再继续增加规则，我们需要判定什么时候玩家赢了。我们给定了一个K值，如果说一个列上出现了连续的超过或等于K个的相同玩家，则视为该玩家胜利。如上面的例子中，我们取K为2，那么R就获得了胜利。</p><p>题目难度不大，思路也很简单，但是由于口语和听力不行，导致挺面试小哥说话的时候很多东西没有听清，说了好几遍pardon (lol), 然后一开始我以为判定胜利的条件是同一行上，给我整的有点懵，后来经过一番艰苦卓绝的讨论，才发现居然是同一列……</p><p>题目思路大概就是用一个HashMap存储棋盘的数据，每个index用一个list存储数据，判断胜利只需要从所下的棋子的index那一列找到是否有连续的相同棋子，由于每一次都只能从底部加入，所以实际上只需要从头遍历就行了。这里我还犯了个错……List添加的时候是从尾部添加的，所以遍历的时候应该从尾部进行遍历，被面试老哥提醒了一下（我太菜了）</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法题目类型总结</title>
      <link href="/hexo_zh/2021/09/24/algorithms/suan-fa-ti-mu-lei-xing-zong-jie/"/>
      <url>/hexo_zh/2021/09/24/algorithms/suan-fa-ti-mu-lei-xing-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>算法题目类型总结，题目为LeetCode或者HackerRank上的题目。</p><span id="more"></span><h2 id="双指针">双指针</h2><p><a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器 - 力扣（LeetCode） (leetcode-cn.com)</a></p><h2 id="优先队列">优先队列</h2><h2 id="二叉树">二叉树</h2><h2 id="深度优先和广度优先算法">深度优先和广度优先算法</h2><p><a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量 - 力扣（LeetCode） (leetcode-cn.com)</a></p><h2 id="滑动窗口">滑动窗口</h2><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串 - 力扣（LeetCode） (leetcode-cn.com)</a></p><h2 id="哈希表">哈希表</h2><h2 id="动态规划">动态规划</h2><p><a href="https://leetcode-cn.com/problems/regular-expression-matching/">10. 正则表达式匹配 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III - 力扣（LeetCode） (leetcode-cn.com)</a></p><h2 id="前缀和">前缀和</h2><h2 id="差分法逆向前缀和">差分法（逆向前缀和）</h2><p><a href="https://leetcode-cn.com/problems/corporate-flight-bookings/submissions/">1109. 航班预订统计 - 力扣（LeetCode</a></p><p><a href="https://www.hackerrank.com/challenges/crush/problem?h_l=interview&amp;playlist_slugs%5B%5D=interview-preparation-kit&amp;playlist_slugs%5B%5D=arrays">Array Manipulation | HackerRank</a></p><h2 id="位运算">位运算</h2><p>异或 (^): 相同为0，不同为1；位与、位或等位运算。</p><p>位运算相关性质以及结论</p><ol type="1"><li><p><code>n&amp;(n-1)</code>作用：将n的二进制表示中的最低位为1的改为0</p></li><li><p><code>n &gt; 0 &amp;&amp; ((n &amp; (n - 1)) == 0 )</code> 用来判断一个数是否是2的幂</p></li><li><p>求一个数的二进制中1的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (n &gt;<span class="number">0</span> ) &#123;</span><br><span class="line">      count ++;</span><br><span class="line">      n &amp;= (n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>参考<a href="https://blog.csdn.net/navyifanr/article/details/19496459">位运算n &amp; (n-1)的妙用</a></p></li><li><p>位异或的性质</p><ul><li>x = y ^ z &lt;=&gt; z = x ^ y</li></ul></li></ol><p><a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/">421. 数组中两个数的最大异或值 - 力扣（LeetCode）</a></p><p><a href="https://leetcode-cn.com/problems/xoh6Oh/">剑指 Offer II 001. 整数除法 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p><a href="https://leetcode-cn.com/problems/JFETK5/solution/er-jin-zhi-jia-fa-by-leetcode-solution-fa6t/">二进制加法 - 二进制加法 - 力扣（LeetCode)</a></p><h2 id="深度优先算法-广度优先算法">深度优先算法 &amp; 广度优先算法</h2><p><a href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III - 力扣（LeetCode）</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1109. 航班预订统计</title>
      <link href="/hexo_zh/2021/09/24/leetcode/1109-hang-ban-yu-ding-tong-ji/"/>
      <url>/hexo_zh/2021/09/24/leetcode/1109-hang-ban-yu-ding-tong-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>这里有 n 个航班，它们分别从 1 到 n 进行编号。</p><p>有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。</p><p>请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。</p><p><span id="more"></span></p><blockquote><p>示例 1：</p><p>输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5 输出：[10,55,45,25,25] 解释： 航班编号 1 2 3 4 5 预订记录 1 ： 10 10 预订记录 2 ： 20 20 预订记录 3 ： 25 25 25 25 总座位数： 10 55 45 25 25 因此，answer = [10,55,45,25,25] 示例 2：</p><p>输入：bookings = [[1,2,10],[2,2,15]], n = 2 输出：[10,25] 解释： 航班编号 1 2 预订记录 1 ： 10 10 预订记录 2 ： 15 总座位数： 10 25 因此，answer = [10,25]</p></blockquote><h2 id="题解">题解</h2><p>使用方法：差分，也就是逆向前缀和，时间复杂度O(N)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] corpFlightBookings(<span class="keyword">int</span>[][] bookings, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] booking : bookings) &#123;</span><br><span class="line">            ans[booking[<span class="number">0</span>]-<span class="number">1</span>] += booking[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (booking[<span class="number">1</span>] != n) ans[booking[<span class="number">1</span>]] -= booking[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans[i] += ans[i-<span class="number">1</span>]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Java </tag>
            
            <tag> 差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java异常java.util.ConcurrentModificationException详解（转载）</title>
      <link href="/hexo_zh/2021/08/02/javanote/java-yi-chang-java-util-concurrentmodificationexception-xiang-jie/"/>
      <url>/hexo_zh/2021/08/02/javanote/java-yi-chang-java-util-concurrentmodificationexception-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>最近在Android开发的过程中，使用WorkerManager的时候产生了报错java.util.ConcurrentModificationException，于是就到网上进行查询，感觉这篇文章讲述的比较详尽，记录学习一下。</p><p>原文原载于<a href="https://www.cnblogs.com/snowater/p/8024776.html">java.util.ConcurrentModificationException 异常问题详解</a></p><p><span id="more"></span></p><p>在Java开发过程中，使用iterator遍历集合的同时对集合进行修改就会出现java.util.ConcurrentModificationException异常，本文就以ArrayList为例去理解和解决这种异常。</p><h2 id="一单线程情况下问题分析及解决方案">一、单线程情况下问题分析及解决方案</h2><h3 id="问题复现">1.1 问题复现</h3><p>先上一段抛异常的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        arrayList.add(Integer.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复现方法一</span></span><br><span class="line">    Iterator&lt;Integer&gt; iterator = arrayList.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Integer integer = iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (integer.intValue() == <span class="number">5</span>) &#123;</span><br><span class="line">            arrayList.remove(integer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复现方法二</span></span><br><span class="line">    iterator = arrayList.iterator();</span><br><span class="line">    <span class="keyword">for</span> (Integer value : arrayList) &#123;</span><br><span class="line">        Integer integer = iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (integer.intValue() == <span class="number">5</span>) &#123;</span><br><span class="line">            arrayList.remove(integer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个代码中展示了两种能抛异常的实现方式。</p><h3 id="问题原因分析">1.2、问题原因分析</h3><p>先来看实现方法一，方法一中使用Iterator遍历ArrayList， 抛出异常的是iterator.next()。看下Iterator next方法实现源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">int</span> i = cursor;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在next方法中首先调用了checkForComodification方法，该方法会判断modCount是否等于expectedModCount，不等于就会抛出java.util.ConcurrentModificationExcepiton异常。</p><p>我们接下来跟踪看一下modCount和expectedModCount的赋值和修改。</p><p>modCount是ArrayList的一个属性，继承自抽象类AbstractList，用于表示ArrayList对象被修改次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>整个ArrayList中修改modCount的方法比较多，有add、remove、clear、ensureCapacityInternal等，凡是设计到ArrayList对象修改的都会自增modCount属性。</p><p>在创建Iterator的时候会将modCount赋值给expectedModCount，在遍历ArrayList过程中，没有其他地方可以设置expectedModCount了，因此遍历过程中expectedModCount会一直保持初始值20（调用add方法添加了20个元素，修改了20次）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">int</span> expectedModCount = modCount; <span class="comment">// 创建对象时初始化</span></span><br></pre></td></tr></table></figure><p>遍历的时候是不会触发modCount自增的，但是遍历到integer.intValue() == 5的时候，执行了一次arrayList.remove(integer)，这行代码执行后modCount++变为了21，但此时的expectedModCount仍然为20。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行next方法时，遇到modCount != expectedModCount方法，导致抛出异常java.util.ConcurrentModificationException。</p><p>明白了抛出异常的过程，但是为什么要这么做呢？很明显这么做是为了阻止程序员在不允许修改的时候修改对象，起到保护作用，避免出现未知异常。引用网上的一段解释，<a href="http://lz12366.iteye.com/blog/675016">点击查看解释来源</a></p><blockquote><p>Iterator 是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator 被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变。 当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出 java.util.ConcurrentModificationException 异常。 所以 Iterator 在工作的时候是不允许被迭代的对象被改变的。但你可以使用 Iterator 本身的方法 remove() 来删除对象， Iterator.remove() 方法会在删除当前迭代对象的同时维护索引的一致性。</p></blockquote><p>再来分析下第二种for循环抛异常的原因：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">final</span> E[] elementData = (E[]) <span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        action.accept(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在for循环中一开始也是对expectedModCount采用modCount进行赋值。在进行for循环时每次都会有判定条件modCount == expectedModCount，当执行完arrayList.remove(integer)之后，该判定条件返回false退出循环，然后执行if语句，结果同样抛出java.util.ConcurrentModificationException异常。</p><p>这两种复现方法实际上都是同一个原因导致的。</p><h3 id="问题解决方案">1.3 问题解决方案</h3><p>上述的两种复现方法都是在单线程运行的，先来说明单线程中的解决方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        arrayList.add(Integer.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Iterator&lt;Integer&gt; iterator = arrayList.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Integer integer = iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (integer.intValue() == <span class="number">5</span>) &#123;</span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种解决方案最核心的就是调用iterator.remove()方法。我们看看该方法源码为什么这个方法能避免抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在iterator.remove()方法中，同样调用了ArrayList自身的remove方法，但是调用完之后并非就return了，而是expectedModCount = modCount重置了expectedModCount值，使二者的值继续保持相等。</p><p>针对forEach循环并没有修复方案，因此在遍历过程中同时需要修改ArrayList对象，则需要采用iterator遍历。</p><p>上面提出的解决方案调用的是iterator.remove()方法，如果不仅仅是想调用remove方法移除元素，还想增加元素，或者替换元素，是否可以呢？浏览Iterator源码可以发现这是不行的，Iterator只提供了remove方法。</p><p>但是ArrayList实现了ListIterator接口，ListIterator类继承了Iter，这些操作都是可以实现的，使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-多线程情况下的问题分析及解决方案">二、 多线程情况下的问题分析及解决方案</h2><p>单线程问题解决了，再来看看多线程情况。</p><h3 id="问题复现-1">2.1 问题复现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">arrayList.add(Integer.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ListIterator&lt;Integer&gt; iterator = arrayList.listIterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread1 &quot;</span> + iterator.next().intValue());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ListIterator&lt;Integer&gt; iterator = arrayList.listIterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread2 &quot;</span> + iterator.next().intValue());</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在个测试代码中，开启两个线程，一个线程遍历，另外一个线程遍历加修改。程序输出结果如下</p><blockquote><p>thread1 0 thread2 0 thread2 1 thread2 2 thread2 3 thread2 4 thread2 5 thread2 6 thread2 7 thread2 8 thread2 9 thread2 10 thread2 11 thread2 12 thread2 13 thread2 14 thread2 15 thread2 16 thread2 17 thread2 18 thread2 19 Exception in thread "Thread-0" java.util.ConcurrentModificationException at java.util.ArrayList<span class="math inline">\(Itr.checkForComodification(ArrayList.java:901)  at java.util.ArrayList\)</span>Itr.next(ArrayList.java:851) at com.snow.ExceptionTest$1.run(ExceptionTest.java:74) at java.lang.Thread.run(Thread.java:745)</p><p>Process finished with exit code 0</p></blockquote><h3 id="问题分析">2.2 问题分析</h3><p>从上面代码执行结果可以看出thread2 遍历结束后，thread1 sleep完1000ms准备遍历第二个元素，next的时候抛出异常了。我们从时间点分析一下抛异常的原因</p><table><colgroup><col style="width: 25%" /><col style="width: 16%" /><col style="width: 29%" /><col style="width: 29%" /></colgroup><thead><tr class="header"><th>时间点</th><th>arrayList.modCount</th><th>thread1 iterator.expectedModCount</th><th>thread2 iterator.expectedModCount</th></tr></thead><tbody><tr class="odd"><td>thread start，初始化iterator</td><td>20</td><td>20</td><td>20</td></tr><tr class="even"><td>thread2.remove()调用之后</td><td>21</td><td>20</td><td>21</td></tr></tbody></table><p>两个thread都是使用的同一个arrayList，thread2修改完后modCount = 21，此时thread2的expectedModCount = 21 可以一直遍历到结束；thread1的expectedModCount仍然为20，因为thread1的expectedModCount只是在初始化的时候赋值，其后并未被修改过。因此当arrayList的modCount被thread2修改为21之后，thread1想继续遍历必定会抛出异常了。</p><p>在这个示例代码里面，两个thread，每个thread都有自己的iterator，当thread2通过iterator方法修改expectedModCount必定不会被thread1感知到。这个跟ArrayList非线程安全是无关的，即使这里面的ArrayList换成Vector也是一样的结果，不信上测试代码：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        vector.add(Integer.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ListIterator&lt;Integer&gt; iterator = vector.listIterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread1 &quot;</span> + iterator.next().intValue());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ListIterator&lt;Integer&gt; iterator = vector.listIterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                Integer integer = iterator.next();</span><br><span class="line">                System.out.println(<span class="string">&quot;thread2 &quot;</span> + integer.intValue());</span><br><span class="line">                <span class="keyword">if</span> (integer.intValue() == <span class="number">5</span>) &#123;</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后输出结果为：</p><blockquote><p>thread1 0 thread2 0 thread2 1 thread2 2 thread2 3 thread2 4 thread2 5 thread2 6 thread2 7 thread2 8 thread2 9 thread2 10 thread2 11 thread2 12 thread2 13 thread2 14 thread2 15 thread2 16 thread2 17 thread2 18 thread2 19 Exception in thread "Thread-0" java.util.ConcurrentModificationException at java.util.Vector<span class="math inline">\(Itr.checkForComodification(Vector.java:1184)  at java.util.Vector\)</span>Itr.next(Vector.java:1137) at com.snow.ExceptionTest$3.run(ExceptionTest.java:112) at java.lang.Thread.run(Thread.java:745)</p><p>Process finished with exit code 0</p></blockquote><p>test5()方法执行结果和test4()是相同的，那如何解决这个问题呢？</p><h3 id="多线程下的解决方案">2.3 多线程下的解决方案</h3><h4 id="方案一iterator遍历过程加同步锁锁住整个arraylist">2.3.1 方案一：iterator遍历过程加同步锁，锁住整个arrayList</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">arrayList.add(Integer.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">synchronized</span> (arrayList) &#123;</span><br><span class="line">                ListIterator&lt;Integer&gt; iterator = arrayList.listIterator();</span><br><span class="line">              <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;thread1 &quot;</span> + iterator.next().intValue());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (arrayList) &#123;</span><br><span class="line">                ListIterator&lt;Integer&gt; iterator = arrayList.listIterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    Integer integer = iterator.next();</span><br><span class="line">                    System.out.println(<span class="string">&quot;thread2 &quot;</span> + integer.intValue());</span><br><span class="line">                    <span class="keyword">if</span> (integer.intValue() == <span class="number">5</span>) &#123;</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></p><p>这种方案本质上是将多线程通过加锁来转变为单线程操作，确保同一时间内只有一个线程去使用iterator遍历arrayList，其它线程等待，效率显然是只有单线程的效率。</p><h4 id="方案二使用copyonwritearraylist有坑要明白原理再用否则你就呆坑里吧">2.3.2 方案二：使用CopyOnWriteArrayList，有坑！要明白原理再用，否则你就呆坑里吧。</h4><p>我们先来看代码，很有意思咯</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            list.add(Integer.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                ListIterator&lt;Integer&gt; iterator = list.listIterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;thread1 &quot;</span> + iterator.next().intValue());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;thread2 &quot;</span> + integer.intValue());</span><br><span class="line">                    <span class="keyword">if</span> (integer.intValue() == <span class="number">5</span>) &#123;</span><br><span class="line">                        list.remove(integer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;thread2 again &quot;</span> + integer.intValue());</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                ListIterator&lt;Integer&gt; iterator = list.listIterator();</span></span><br><span class="line"><span class="comment">//                while (iterator.hasNext()) &#123;</span></span><br><span class="line"><span class="comment">//                    Integer integer = iterator.next();</span></span><br><span class="line"><span class="comment">//                    System.out.println(&quot;thread2 &quot; + integer.intValue());</span></span><br><span class="line"><span class="comment">//                    if (integer.intValue() == 5) &#123;</span></span><br><span class="line"><span class="comment">//                        iterator.remove();</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></p><p>先不分析，看执行结果，这个执行结果重点关注字体加粗部分。</p><blockquote><p>thread1 0 thread2 0 thread2 1 thread2 2 thread2 3 <strong>thread2 4</strong> <strong>thread2 5</strong> <strong>thread2 6</strong> thread2 7 thread2 8 thread2 9 thread2 10 thread2 11 thread2 12 thread2 13 thread2 14 thread2 15 thread2 16 thread2 17 thread2 18 thread2 19 thread2 again 0 thread2 again 1 thread2 again 2 thread2 again 3 <strong>thread2 again 4</strong> <strong>thread2 again 6</strong> thread2 again 7 thread2 again 8 thread2 again 9 thread2 again 10 thread2 again 11 thread2 again 12 thread2 again 13 thread2 again 14 thread2 again 15 thread2 again 16 thread2 again 17 thread2 again 18 thread2 again 19 thread1 1 thread1 2 thread1 3 thread1 4 thread1 5 thread1 6 thread1 7 thread1 8 thread1 9 thread1 10 thread1 11 thread1 12 thread1 13 thread1 14 thread1 15 thread1 16 thread1 17 thread1 18 thread1 19</p><p>Process finished with exit code 0</p></blockquote><p>我们先分析thread2的输出结果，第一次遍历将4 5 6都输出，情理之中；第一次遍历后删除掉了一个元素，第二次遍历输出4 6，符合我们的预期。</p><p>再来看下thread1的输出结果，有意思的事情来了，thread1 仍然输出了4 5 6，什么鬼？thread1和thread2都是遍历list，list在thread1遍历第二个元素的时候就已经删除了一个元素了，为啥还能输出5？</p><p>为了了解这个问题，需要了解CopyOnWriteArrayList是如何做到一边遍历的同时还能一边修改并且还不抛异常的。</p><p>在这里不想再深入分析CopyOnWriteArrayList代码，后续会专门出一篇博客来解释这个类的源码的。</p><p>这里说一下CopyOnWriteArrayList的解决思路，其实很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure><p>CopyOnWriteArrayList本质上是对array数组的一个封装，一旦CopyOnWriteArrayList对象发生任何的修改都会new一个新的Object[]数组newElement，在newElement数组上执行修改操作，修改完成后将newElement赋值给array数组（array=newElement）。</p><p>因为array是volatile的，因此它的修改对所有线程都可见。</p><p>了解了CopyOnWriteArrayList的实现思路之后，我们再来分析上面代码test6为什么会出现那样的输出结果。先来看下thread1和thread2中用到的两种遍历方式的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (action == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"><span class="comment">// 在遍历开始前获取当前数组</span></span><br><span class="line">Object[] elements = getArray();</span><br><span class="line"><span class="keyword">int</span> len = elements.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> E e = (E) elements[i];</span><br><span class="line">action.accept(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> COWIterator&lt;E&gt;(getArray(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">COWIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** Snapshot of the array */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line">        <span class="comment">/** Index of element to be returned by subsequent call to next.  */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</span><br><span class="line">            cursor = initialCursor;</span><br><span class="line">            <span class="comment">// 初始化为当前数组</span></span><br><span class="line">            snapshot = elements;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 已经不支持Iterator remove操作了！！</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor &lt; snapshot.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (! hasNext())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处省略其他无关代码</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这两种遍历方式有个共同的特点：都在初始化的时候将当前数组保存下来了，之后的遍历都将会遍历这个数组，而不管array如何变化。</p><table><colgroup><col style="width: 14%" /><col style="width: 15%" /><col style="width: 20%" /><col style="width: 24%" /><col style="width: 24%" /></colgroup><thead><tr class="header"><th>时间点</th><th>CopyOnWriteArrayList的array</th><th>thread1 iterator 初始化的Object数组</th><th>thread2 第一次遍历forEach初始化的Object数组</th><th>thread2 第二次遍历forEach初始化的Object数组</th></tr></thead><tbody><tr class="odd"><td>thread start</td><td>假设为A</td><td>A</td><td>A</td><td>/</td></tr><tr class="even"><td>thread2 调用remove方法之后</td><td>假设为B</td><td>A</td><td>A</td><td>B</td></tr></tbody></table><p>有了这个时间节点表就很清楚了，thread1和thread2 start的时候都会将A数组初始化给自己的临时变量，之后遍历的也都是这个A数组，而不管CopyOnWriteArrayList中的array发生了什么变化。因此也就解释了thread1在thread2 remove掉一个元素之后为什么还会输出5了。在thread2中，第二次遍历初始化数组变成了当前的array，也就是修改后的B，因此不会有Integer.valueOf(5)这个元素了。</p><p>从test6执行结果来看，CopyOnWriteArrayList确实能解决一边遍历一边修改并且还不会抛异常，但是这也是有<strong>代价</strong>的：</p><ol type="1"><li><p>thread2对array数组的修改thread1并不能被动感知到，只能通过hashCode()方法去主动感知，否则就会一直使用修改前的数据</p></li><li><p>每次修改都需要重新new一个数组，并且将array数组数据拷贝到new出来的数组中，效率会大幅下降</p></li></ol><p>此外CopyOnWriteArrayList中的ListIterator实现是不支持remove、add和set操作的，一旦调用就会抛出UnsupportedOperationException异常，因此test6注释代码34-41行中如果运行是会抛异常的。</p>]]></content>
      
      
      <categories>
          
          <category> Java学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android中常用的一些包(记录一下方便以后使用)</title>
      <link href="/hexo_zh/2021/07/30/android/android-zhong-chang-yong-de-yi-xie-bao-ji-lu-yi-xia-fang-bian-yi-hou-shi-yong/"/>
      <url>/hexo_zh/2021/07/30/android/android-zhong-chang-yong-de-yi-xie-bao-ji-lu-yi-xia-fang-bian-yi-hou-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>Android中有一些常用的一些包需要我们手动添加到dependency中去，记录一下方便以后使用</p><p><span id="more"></span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 圆形图片</span><br><span class="line">implementation &#x27;de.hdodenhof:circleimageview:3.0.1&#x27;</span><br><span class="line">// Recycler View</span><br><span class="line">implementation &#x27;androidx.recyclerview:recyclerview:1.1.0&#x27;</span><br><span class="line">// glide:更方便的插入图片的插件</span><br><span class="line">implementation &#x27;com.github.bumptech.glide:glide:4.9.0&#x27;</span><br><span class="line">// 下拉刷新layout</span><br><span class="line">implementation &#x27;androidx.swiperefreshlayout:swiperefreshlayout:1.0.0&#x27;</span><br><span class="line">// Android Material UI 库(一般都会默认生成)</span><br><span class="line">implementation &#x27;com.google.android.material:material:1.3.0&#x27;</span><br><span class="line">// Android workmanager</span><br><span class="line">implementation &#x27;androidx.work:work-runtime:2.3.4&#x27;</span><br><span class="line"></span><br><span class="line">implementation &#x27;androidx.lifecycle:lifecycle-extensions:2.2.0&#x27;</span><br><span class="line">implementation &#x27;androidx.lifecycle:lifecycle-livedata-ktx:2.2.0&#x27;</span><br><span class="line"></span><br><span class="line">implementation &#x27;com.squareup.retrofit2:retrofit:2.6.1&#x27;</span><br><span class="line">implementation &#x27;com.squareup.retrofit2:converter-gson:2.6.1&#x27;</span><br><span class="line"></span><br><span class="line">implementation &#x27;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.0&#x27;</span><br><span class="line">implementation &#x27;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.1.1&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡特兰数</title>
      <link href="/hexo_zh/2021/07/27/algorithms/qia-te-lan-shu/"/>
      <url>/hexo_zh/2021/07/27/algorithms/qia-te-lan-shu/</url>
      
        <content type="html"><![CDATA[<p>考虑以下问题：</p><blockquote><p>现在我们有<span class="math inline">\(n+1\)</span>个数，<span class="math inline">\(x_0,x_1,x_2,\cdots,x_n\)</span>，考虑它们的乘积<span class="math inline">\(x_1\cdot x_2\cdots x_n\)</span>，现在我们可以在其中插入括号来改变计算顺序。那么一共有多少种排列的顺序呢？比如说，现在有三个数<span class="math inline">\(x_0, x_1, x_2\)</span>，它们的计算顺序有<span class="math inline">\((x_0x_1)x_2\)</span>以及<span class="math inline">\(x_0(x_1x_2)\)</span>两种排列方式</p></blockquote><span id="more"></span><h3 id="问题分析">问题分析</h3><p>我们可以使用递归的思想来考虑这个问题。我们把这<span class="math inline">\(n+1\)</span>个数分为两组，在第<span class="math inline">\(k\)</span>个数处分开，就形成了下面<span class="math inline">\(A, B\)</span>两组数。</p><p><span class="math display">\[\underbrace{(x_0\space x_1\space x_2 \cdots x_k)}_{A} ,\underbrace{(\space x_{k+1}\cdots x_{n-1}\space x_{n})}_{B}\]</span></p><p>我们记<span class="math inline">\(n+1\)</span>个数的插入括号后的计算顺序个数为<span class="math inline">\(C_n\)</span>，那么<span class="math inline">\(A\)</span>的计算顺序个数就是<span class="math inline">\(C_k\)</span>，<span class="math inline">\(B\)</span>的就是<span class="math inline">\(C_{n-k-1}\)</span>。所以说，如果说我们把最后一个括号放在第<span class="math inline">\(k\)</span>个数的地方，那么我们总的个数就是<span class="math inline">\(C_kC_{n-k-1}\)</span>。这里<span class="math inline">\(k\)</span>可以从0到<span class="math inline">\(n-1\)</span>，根据加法原则，</p><p><span class="math display">\[C_n=\sum^{n-1}_{k=0}C_kC_{n-k-1}, \space\space\space\space n\geqslant 1\]</span></p><p>剩下的事情就是用数学方法计算出这个数列的通项公式。</p><h3 id="数学解法">数学解法</h3><p>通过生成函数法(generating function)可以解出符合方法一中递推公式的数列的通项公式。</p><p>首先我们定义函数</p><p><span class="math display">\[f(x)=\sum_{k\geqslant0}C_kx^k\]</span></p><p>然后我们可以将上面的递推公式推广到<span class="math inline">\(n\geqslant0\)</span>，也就是</p><p><span class="math display">\[C_n=\sum_{k\geqslant0}C_kC_{n-k-1}+\mathbb{I}_{\{n=0\}}, \space\space\space\space \forall n\geqslant0\]</span></p><p>其中<span class="math inline">\(\mathbb{I}_{\{n=0\}}\)</span>是示意函数(indicator function)，当<span class="math inline">\(n=0\)</span>时此函数值为1，否则值为0。并且我们定义当<span class="math inline">\(k&lt;0\)</span>时，<span class="math inline">\(C_k=0\)</span>。等式两边同乘我们可以得到</p><p><span class="math display">\[\begin{aligned}f(x)&amp; = \sum_{n\geqslant0}C_nx^n  =\sum_{n\geqslant0}C_kC_{n-k-1}x^n+\mathbb{I}_{\{n=0\}}x^n \\&amp; = \sum_{n\geqslant0}\sum_{k\geqslant0}C_kC_{n-k-1}x^kx^{n-k}+1 \\&amp; = \sum_{k\geqslant0}\Big[C_kx^k\sum_{n\geqslant0}C_{n-k-1}x^{n-k-1}\cdot x\Big]+1 \\\end{aligned}\]</span></p><p>我们对<span class="math inline">\(n-k+1\)</span>进行一个换元之后，式子中的<span class="math inline">\(\sum_{n\geqslant0}C_{n-k-1}x^{n-k-1}\)</span>可以写成<span class="math inline">\(\sum_{j\geqslant0}Cjx^j\)</span>，也就是<span class="math inline">\(f(x)\)</span>，所以我们得到</p><p><span class="math display">\[\begin{aligned}f(x)&amp; =\sum_{k\geqslant0}C_kx^kf(x)x+1 \\&amp; =x\big(f(x)\big)^2+1 \\\Longrightarrow f(x)&amp; =\frac{1\pm\sqrt{1-4x}}{2x}\end{aligned}\]</span></p><p>通过观察，由于<span class="math inline">\(f(x)=C_0+C_1x+C_2x^2+\cdots\)</span>并且<span class="math inline">\(f(0)=C_0=1\)</span>，可以推断出这里我们需要取减号。接下来计算<span class="math inline">\((1-4x)^{\frac{1}{2}}\)</span></p><p><span class="math display">\[\begin{aligned}(1-4x)^{\frac{1}{2}} &amp; =\sum_{k\geqslant0}\tbinom{\frac{1}{2}}{k}(-4x)^k \space\space\space\space |x|&lt;\frac{1}{4}\\ &amp; = 1+\sum_{k\geqslant1}(-1)^k\tbinom{\frac{1}{2}}{k}4^kx^k\end{aligned}\]</span></p><p>通过广义二项式定理，我们可以进一步化简</p><p><span class="math display">\[\begin{aligned}\tbinom{\frac{1}{2}}{k}&amp; =\frac{\frac{1}{2}(\frac{1}{2}-1)\cdots(\frac{1}{2}-k+1)}{k!} \\&amp; = \frac{1}{2k}\cdot\frac{(-\frac{1}{2})(-\frac{3}{2})\cdots(-\frac{1}{2}-(k-1)+1)}{(k-1)!} \\&amp; = \frac{1}{2k}\cdot(-\frac{1}{2})^{k-1}\cdot\frac{1\cdot3\cdots(2k-3)}{(k-1)!} \\&amp; = \frac{1}{2k}\cdot(-\frac{1}{2})^{k-1}\cdot\frac{1\cdot2\cdot3\cdot4\cdots(2k-3)\cdot(2k-2)}{2^{k-1}(k-1)!(k-1)!} \\&amp; =\frac{1}{2k}\cdot(-\frac{1}{4})^{k-1}\cdot\tbinom{2k-2}{k-1}\end{aligned}\]</span></p><p>代入上述式子可得</p><p><span class="math display">\[\begin{aligned}(1-4x)^{\frac{1}{2}}&amp; =1-\sum_{k\geqslant1}\frac{1}{2k}\tbinom{2k-2}{k-1}\cdot4\cdot x^k \\&amp; =1-2x\sum_{k\geqslant0}\frac{1}{k+1}\tbinom{2k}{k}x^k\end{aligned}\]</span></p><p>最后把这个式子代回到<span class="math inline">\(f(x)\)</span>的表达式中去，我们可以得到</p><p><span class="math display">\[f(x)=\sum_{k\geqslant0}\frac{1}{k+1}\tbinom{2k}{k}x^k\]</span></p><p>与<span class="math inline">\(f(x)=\sum_{k\geqslant0}C_kx^k\)</span>进行对比我们可以得出结论</p><p><span class="math display">\[C_n=\frac{1}{n+1}\tbinom{2n}{n}\]</span></p><p>这就是卡特兰数(Catalan Number)</p><h3 id="卡特兰数的其他等价问题">卡特兰数的其他等价问题</h3><ol type="1"><li><p>Dyck word的个数. Dyck word表示一个有由<span class="math inline">\(n\)</span>个X和<span class="math inline">\(n\)</span>个Y组成的字符串，并且需要满足：在任意一个位置，之前的X个数都必须大于等于Y的个数。</p><p>这里可以给出一个卡特兰数简单的计算方法</p><p>首先不考虑限制条件，那么总共的排列方式有<span class="math inline">\(\tbinom{2n}{n}\)</span>种，然后考虑不满足题目限制的个数。假设在第<span class="math inline">\(2m+1\)</span>处有<span class="math inline">\(m+1\)</span>个Y和<span class="math inline">\(m\)</span>个X(不满足题目要求)，那么后面就有<span class="math inline">\(n-m\)</span>个X和<span class="math inline">\(n-m-1\)</span>个Y，将这里的X全部替换为Y，Y全部替换为X，那么这样的字符串就变成了由<span class="math inline">\(n-1\)</span>个X和<span class="math inline">\(n+1\)</span>个Y组成的字符串。这样的字符串总数是<span class="math inline">\(\tbinom{2n}{n+1}\)</span>，所以总数是</p><p><span class="math display">\[\tbinom{2n}{n}-\tbinom{2n}{n+1}=\frac{1}{n+1}\tbinom{2n}{n}\]</span></p></li><li><p>包含n组括号的合法运算式的个数。</p></li><li><p>不相交的弦问题：在一个圆周上分布着<span class="math inline">\(2n\)</span>个点，要求在每两个点之间连接一条弦，并 且弦与弦不能相交，求这样的连接方式个数。</p></li><li><p>格路问题：所有在<span class="math inline">\(n\times n\)</span>格点中不越过对角线的单调路径的个数。可以等价于计算Dyck word的个数(X代表“向右”，Y表示向右)</p></li></ol><h3 id="参考资料">参考资料</h3><p>维基百科, https://zh.wikipedia.org/wiki/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0</p><p>卡特兰数（Catalan number）（一）,https://zhuanlan.zhihu.com/p/31317307</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java将List数据拆分进行分批处理</title>
      <link href="/hexo_zh/2021/07/26/javanote/java-jiang-list-shu-ju-chai-fen-jin-xing-fen-pi-chu-li/"/>
      <url>/hexo_zh/2021/07/26/javanote/java-jiang-list-shu-ju-chai-fen-jin-xing-fen-pi-chu-li/</url>
      
        <content type="html"><![CDATA[<p>最近碰到一个问题，如果将一个数据量比较大的List数据发送到服务器上，这样的批量操作可能会由一个小错误导致整个请求无法实现，这个时候我们就可以考虑将List进行拆分，分批处理，降低失误率。</p><span id="more"></span><p>考虑到List中并没有实现<code>sublist</code>的方法，所以我们可以自己实现一个<code>sublist</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将list拆分成指定数量的小list</span></span><br><span class="line"><span class="comment">* 注: 使用的subList方式,返回的是list的内部类,不可做元素的删除,修改,添加操作</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> length 数量</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> list 大list</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;T&gt;&gt; getSubList(<span class="keyword">int</span> length, List&lt;T&gt; list)&#123;</span><br><span class="line">    <span class="keyword">int</span> size = list.size();</span><br><span class="line">    <span class="keyword">int</span> temp = size / length + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">boolean</span> result = size % length == <span class="number">0</span>;</span><br><span class="line">    List&lt;List&lt;T&gt;&gt; subList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == temp - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            subList.add(list.subList(length * i, size)) ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            subList.add(list.subList(length * i, length * (i + <span class="number">1</span>))) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考资料：<a href="https://blog.csdn.net/weixin_43687353/article/details/104756939">Java中将大list拆分成多个小list，分批操作</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：排序算法</title>
      <link href="/hexo_zh/2021/07/26/algorithms/suan-fa-pai-xu-suan-fa/"/>
      <url>/hexo_zh/2021/07/26/algorithms/suan-fa-pai-xu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="选择排序-selection-sort">选择排序 (Selection sort)</h2><p><code>Selection Sort</code>是一种最基本的排序方法。这种排序方法的基本想法就是：第一次找到最小的数与第一位进行交换，第二次找到第二小的数与第二位进行交换，第三次找到第三小的数与第三位进行交换……以此类推。由于找第i小的数时，前面i-1个数已经是前i-1个最小的数了，所以只要在后N-i+1个数中找到最小的数和第i个数进行交换就好了。也就是说，这个方法需要嵌套两个<code>for</code>循环，时间复杂度很明显也就是<span class="math inline">\(O(N^2)\)</span>了。Java 代码：</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">double</span>[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = a.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lengh; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> min = <span class="function">i</span></span><br><span class="line"><span class="function">            <span class="title">for</span><span class="params">(<span class="keyword">int</span> j = i; j &lt; length; j++)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (a[j] &lt; a[min])&#123;</span><br><span class="line">                min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a[min] = a[i] + a[min];</span><br><span class="line">            a[i] = a[min] - a[i];</span><br><span class="line">            a[min] = a[min] - a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序-insertion-sort">插入排序 (Insertion sort)</h2><p><code>Insertion Sort</code>是另一种基本的排序方法，它会比<code>Selection Sort</code>更有效率一些，因为这种排序方法的效率和原本数组的混乱度有关，如果说这个数组本身就已经排序十分整齐的话，这个时候这种算法的效率就会很高了。这种算法的基本想法就和我们打扑克的时候理牌的方法是一样的。我们打牌的时候，会对我们想要进行移动的那张牌进行大小判断，将那张牌插入到我们已经整理好的一堆牌里的对应的位置。这种算法就是这样，我们假设我们想要移动第i个数，并且前i-1张牌都已经进行好了排序，那么我们只需要对这个数与前一个数进行大小的比较，如果这个数更小，那么就进行交换，直到我们找到了前一个位置的数比这个第i个数还要小的时候，再去移动下一个数。所以，这个方法仍然需要嵌套两个<code>for</code>循环，时间复杂度也是<span class="math inline">\(O(N^2)\)</span>。Java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">double</span>[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = a.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span> &amp;&amp; a[j]&lt; a[j-<span class="number">1</span>]; j--)&#123;</span><br><span class="line">                a[j] = a[j] + a[j-<span class="number">1</span>];</span><br><span class="line">                a[j-<span class="number">1</span>] = a[j] - a[j-<span class="number">1</span>];</span><br><span class="line">                a[j] = a[j] - a[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序-merge-sort">归并排序 (Merge sort)</h2><p>在之前寻找一个数组中的最大值的时候，我们可以使用二分法的方法寻找最大值，可以大大提高效率。那么在排序的时候，也可以使用类似的想法，利用分治(divide and conquer)可以将时间复杂度降低至<span class="math inline">\(O(lgN)\)</span>。首先，我们可以考虑一下情况，有两组数，都是已经排好序的，如果将这两组数按照顺序合并在一起，那么我们可以新创建一个数组，存储新的有顺序的数。首先，比较两组数的第一位数，将较小的数放进新的数组中，较小数所在数组的下一位与较大数所在数组原来的数继续进行比较，直到有一组数达到了尽头，然后把另一组剩下的数放进去得到的新的数组就是排好序的合并后的数组。Java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 数组aux[]为原数组的复制</span></span><br><span class="line">    <span class="keyword">int</span> i = lo, j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(inr i = <span class="number">0</span>; i &lt;= hi; i++)&#123;</span><br><span class="line">        aux[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = lo; k &lt;= hi; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; mid) a[k] = aux[j++]</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; hi) a[k] = aux[i++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(less(a[i], a[j])) a[k] = aux[i++];</span><br><span class="line">        <span class="keyword">else</span> a[k] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，就可以使用分治算法递归进行计算。Java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> Comaparable[a.length]; </span><br><span class="line">        sort(a, <span class="number">0</span>, hi / <span class="number">2</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt; hi) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        sort(a, lo, mid);</span><br><span class="line">        sort(a, mid+<span class="number">1</span>, hi);</span><br><span class="line">        merge(a, lo, mid, hi);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 数组aux[]为原数组的复制</span></span><br><span class="line">        <span class="keyword">int</span> i = lo, j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = lo; k &lt;= hi; k++)&#123;</span><br><span class="line">            aux[k] = a[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = lo; k &lt;= hi; k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; mid) a[k] = aux[j++]</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; hi) a[k] = aux[i++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(less(a[i], a[j])) a[k] = aux[i++];</span><br><span class="line">            <span class="keyword">else</span> a[k] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序-quick-sort">快速排序 (Quick sort)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        quickSort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> partitionIndex = partition(a, lo, hi);</span><br><span class="line">            quickSort(a, lo, partitionIndex-<span class="number">1</span>);</span><br><span class="line">            quickSort(a, hi, partitionIndex+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同版本的partition：主要思想都是一致的，将比pivot小的放在左边，比他大的放在pivot的右边</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 算法第四版 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot = lo;</span><br><span class="line">    <span class="comment">// Scan right, scan left, check for scan complete, and exchange</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (a[++i] &lt; a[pivot]) <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (a[pivot] &lt; a[--j]) <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        swap(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a, lo, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 菜鸟教程 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comaparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = lo;</span><br><span class="line">    <span class="keyword">int</span> index = pivot + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt;= hi; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            swap(arr, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Java </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>539. 移动零</title>
      <link href="/hexo_zh/2021/07/26/leetcode/539-yi-dong-ling/"/>
      <url>/hexo_zh/2021/07/26/leetcode/539-yi-dong-ling/</url>
      
        <content type="html"><![CDATA[<p>给一个数组 <em>nums</em> 写一个函数将 <code>0</code> 移动到数组的最后面，非零元素保持原数组的顺序</p><h3 id="样例">样例</h3><p>例1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [0, 1, 0, 3, 12],</span><br><span class="line">输出: [1, 3, 12, 0, 0].</span><br></pre></td></tr></table></figure><span id="more"></span><p>例2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [0, 0, 0, 3, 1],</span><br><span class="line">输出: [3, 1, 0, 0, 0].</span><br></pre></td></tr></table></figure><h3 id="注意事项">注意事项</h3><p>1.必须在原数组上操作 2.最小化操作数</p><h3 id="解法">解法</h3><p>算法：双指针，简单粗暴。用两个指针 <code>right</code>和 <code>left</code>，<code>right</code>用来右移数组，碰到不为0 的元素就赋值到 <code>left</code>指针处。时间复杂度：<span class="math inline">\(O(N)\)</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java solution</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right] != <span class="number">0</span>)&#123;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                left += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            right += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt; length; i++) &#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Java </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：回溯法学习记录</title>
      <link href="/hexo_zh/2021/07/26/algorithms/suan-fa-hui-su-fa-xue-xi-ji-lu/"/>
      <url>/hexo_zh/2021/07/26/algorithms/suan-fa-hui-su-fa-xue-xi-ji-lu/</url>
      
        <content type="html"><![CDATA[<p>回溯法是一种非常常见的算法，八皇后问题和迷宫问题都可以使用回溯法进行求解。以下是百度百科中对于回溯法的解释</p><blockquote><p>回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯<a href="https://baike.baidu.com/item/条件/1783021">条件</a>的某个<a href="https://baike.baidu.com/item/状态/33204">状态</a>的点称为“回溯点”。 ——百度百科</p></blockquote><p>回溯法采用一种试探回溯的思想。我们从一个一个分支逐步深入，一旦发现当前分支不是我们所需要的，就排除当前分支，然后回到上一步试探其他分支。迷宫问题就是一种常见的使用回溯法的算法问题。事实上，在现实生活中走迷宫我们也经常使用这种试探的走法。</p><p>除了迷宫问题，全排列问题，八皇后问题也都是回溯法的典型问题</p><p><span id="more"></span></p><h3 id="八皇后问题">八皇后问题</h3><blockquote><p>问题表述为：在8×8格的<a href="https://baike.baidu.com/item/国际象棋/80888">国际象棋</a>上摆放8个<a href="https://baike.baidu.com/item/皇后/15860305">皇后</a>，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。</p></blockquote><p>对于八皇后问题，我们采用逐行试探的方法。先在当前行找到一个符合条件的位置放置皇后，如果找不到，就回溯一行排除当前位置继续寻找，直到在最后一行找到一个合适的位置，就可以得到一个解。</p><p>一下是四皇后问题的一个解的寻找过程。首先在(0,0)处放置皇后，转移到行1，查找到第一个合法的位置为(1,3)。</p><p><img src="https://i.loli.net/2021/07/26/W3ZKphw9uAESN8V.png" /></p><p>接着搜寻行2，发现没有符合条件的位置，于是回溯到行1，继续寻找下一个合法的位置(1,4)。</p><p><img src="https://i.loli.net/2021/07/26/W3ZKphw9uAESN8V.png" /></p><p>继续试探到行2，找到了一个合法的位置(2,1)。</p><p><img src="https://i.loli.net/2021/07/26/W3ZKphw9uAESN8V.png" /></p><p>发现在这种情况下行3没有合法的位置，回溯到行2，发现行2剩余的位置也没有合法的，回溯到行1，行1已经没有剩余位置，直接回溯到第0行。</p><p><img src="https://i.loli.net/2021/07/26/W3ZKphw9uAESN8V.png" /></p><p>接着试探，起始位置为(0,1)。第1行试探，皇后放在(1,3)</p><p><img src="https://i.loli.net/2021/07/26/W3ZKphw9uAESN8V.png" /></p><p>第2行，皇后放在(2,0)。第3行，皇后放在(3,2)。四皇后问题的第一个解找到。</p><p><img src="https://i.loli.net/2021/07/26/W3ZKphw9uAESN8V.png" /></p><p>代码实现中特别需要关注的问题是循环何时终止，以及对于边界的处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> QUEENS 4</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> EMPTY 0</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> FULL 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> checkboard[QUEENS][QUEENS] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> boardrow[QUEENS] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只需要判断当前行与之前几行是否冲突</span></span><br><span class="line"><span class="comment">// assert： 0&lt;=x&lt;QUEENS &amp;&amp; 0&lt;=y&lt;QUEENS</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">collide</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = x - <span class="number">1</span>, j = y - <span class="number">1</span>, k = y + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; (j &gt;= <span class="number">0</span> || k &lt; QUEENS)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (checkboard[i][y] == FULL)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">0</span> &amp;&amp; checkboard[i][j--] == FULL)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; QUEENS &amp;&amp; checkboard[i][k++] == FULL)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawBoard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;---------------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QUEENS; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; QUEENS; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d | &quot;</span>, checkboard[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n---------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意边界状态</span></span><br><span class="line"><span class="comment">// 注意循环结束判断</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Queen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>; <span class="comment">// 棋盘坐标</span></span><br><span class="line">    <span class="keyword">int</span> numOfSol = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt;= <span class="number">0</span> || y &lt; QUEENS) &#123;</span><br><span class="line">        <span class="comment">/* 何时回溯</span></span><br><span class="line"><span class="comment">         * 1. 当前行数达到最大（得到一个解）</span></span><br><span class="line"><span class="comment">         * 2. 列数达到最大（当前情况解已经列举完毕）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (x &gt;= QUEENS) &#123;</span><br><span class="line">            numOfSol++;</span><br><span class="line">            x--;</span><br><span class="line">            drawBoard();</span><br><span class="line">            y = boardrow[x];</span><br><span class="line">            checkboard[x][y++] = EMPTY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y &gt;= QUEENS) &#123;</span><br><span class="line">            x--;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            y = boardrow[x];</span><br><span class="line">            checkboard[x][y++] = EMPTY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (collide(x, y)) &#123;</span><br><span class="line">            <span class="comment">// 如果冲突，移动至当前行下一列</span></span><br><span class="line">            y++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不冲突，并且在范围内</span></span><br><span class="line">            <span class="comment">// 那么移动至下一行首列</span></span><br><span class="line">            checkboard[x][y] = FULL;</span><br><span class="line">            boardrow[x++] = y;</span><br><span class="line">            y = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numOfSol;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = Queen();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Number of Solution: %d&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里循环结束的终点条件是当回溯到第0行第4列时，就会继续回溯到第-1行，也就是x&lt;0时结束整个循环。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯法 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android studio中log的内容不完整（log被截断）</title>
      <link href="/hexo_zh/2021/07/26/android/android-studio-zhong-log-de-nei-rong-bu-wan-zheng/"/>
      <url>/hexo_zh/2021/07/26/android/android-studio-zhong-log-de-nei-rong-bu-wan-zheng/</url>
      
        <content type="html"><![CDATA[<p>今天在调试Android程序的时候，想要log一段json数据，数据挺大的，折腾了半天，原来以为是JSON的长度会不会是有上限的，经过搜索发现并没有，参考StackOverflow的两个问题<a href="https://stackoverflow.com/questions/57340897/what-is-limit-of-json-array-and-how-to-overcome-it">android - What is limit of json array and how to overcome it - Stack Overflow</a>和<a href="https://stackoverflow.com/questions/1262376/is-there-a-limit-on-how-much-json-can-hold">Is there a limit on how much JSON can hold? - Stack Overflow</a>。此外，还试图研究Java中String的长度上限，参考这篇文章<a href="https://blog.csdn.net/cyw1900/article/details/48179911">java中String类型的最大长度_cyw1900的专栏-CSDN博客_string类型的最大长度</a>，发现String的上限远比我的数据要大的多，总结就是<mark>String类型的长度为320339960，其最大容量不超过1个G</mark>。</p><p>后来发现是Android studio的log的字符串长度是有上限的，logcat在实现上对于message的内存分配大概是4k左右，实际上根据我的个人的log来看，截取的部分大约是4056个字符串，超过的部分都会被截断。经过搜索，发现网上一个博主自己定义一个debug工具类切分超过4k的message，来解决这个问题。</p><span id="more"></span><p>实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebugUtils</span> </span>&#123;</span><br><span class="line"><span class="comment">// 使用Log来显示调试信息,因为log在实现上每个message有4k字符长度限制</span></span><br><span class="line"><span class="comment">// 所以这里使用自己分节的方式来输出足够长度的message</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        str = str.trim();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">4000</span>;</span><br><span class="line">        String sub;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; str.length()) &#123;</span><br><span class="line">            <span class="comment">// java的字符不允许指定超过总的长度end</span></span><br><span class="line">            <span class="keyword">if</span> (str.length() &lt;= index + maxLength) &#123;</span><br><span class="line">                sub = str.substring(index);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sub = str.substring(index, maxLength);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            index += maxLength;</span><br><span class="line">            Log.i(<span class="string">&quot;qidizi_debug&quot;</span>, sub.trim());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>本文参考文章：<a href="https://blog.csdn.net/qidizi/article/details/47291803">android的logcat的message有字符长度的限制,超过将直接截断</a>，仅作为个人笔记记录。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 使用过的命令记录(ubuntu)</title>
      <link href="/hexo_zh/2021/07/24/linux-command-notes/"/>
      <url>/hexo_zh/2021/07/24/linux-command-notes/</url>
      
        <content type="html"><![CDATA[<p>本文记录一下使用过搜索过的Linux的一些命令，作为一个Linux新手，很多命令用了就忘，还是稍微记录一下比较好，单纯的做个笔记。</p><p><span id="more"></span></p><h2 id="网络">网络</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示所有网络接口和相关IP地址的列表</span></span><br><span class="line">ip addr</span><br><span class="line"><span class="comment"># 显示内部IP地址</span></span><br><span class="line">hostname -I</span><br><span class="line">ifconfig</span><br><span class="line"><span class="comment"># 检测监听端口22</span></span><br><span class="line">sudo lsof -i:22</span><br><span class="line"><span class="comment"># 查看进程</span></span><br><span class="line">ps -A | grep 进程名称</span><br><span class="line">ps -A <span class="comment"># 查看所有</span></span><br><span class="line">ps -ef <span class="comment"># 更详尽的信息</span></span><br><span class="line"><span class="comment"># 结束进程</span></span><br><span class="line"><span class="built_in">kill</span> [信号代码] 进程PID <span class="comment"># kill -9 PID</span></span><br></pre></td></tr></table></figure><h2 id="文件管理">文件管理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示文件</span></span><br><span class="line">ls -t(时间顺序) -a(所有文件) </span><br><span class="line"><span class="comment"># 返回历史上一级目录</span></span><br><span class="line"><span class="built_in">cd</span> -</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$OLDPWD</span></span><br><span class="line"><span class="comment"># 移动文件</span></span><br><span class="line">mv [options] 源文件或目录 目标文件或目录</span><br><span class="line"><span class="comment"># 重命名文件</span></span><br><span class="line">mv abc 1234 重命名文件名为1234</span><br><span class="line"><span class="comment"># 新建文件</span></span><br><span class="line">touch filename OR vim newFileName</span><br></pre></td></tr></table></figure><h3 id="文件压缩">文件压缩</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压缩文件 file1 和目录 dir2 到 test.tar.gz</span></span><br><span class="line">tar -zcvf test.tar.gz file1 dir2</span><br><span class="line"><span class="comment"># 解压 test.tar.gz（将 c 换成 x 即可）</span></span><br><span class="line">tar -zxvf test.tar.gz</span><br><span class="line"><span class="comment"># 列出压缩文件的内容</span></span><br><span class="line">tar -ztvf test.tar.gz</span><br></pre></td></tr></table></figure><blockquote><p>z : 使用 gzip 来压缩和解压文件 -v : --verbose 详细的列出处理的文件 -f : --file=ARCHIVE 使用档案文件或设备，这个选项通常是必选的 -c : --create 创建一个新的归档（压缩包） -x : 从压缩包中解出文件</p></blockquote><h2 id="卸载软件">卸载软件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看已经安装的软件</span></span><br><span class="line">dpkg --list</span><br><span class="line">sudo apt-get remove –-purge 要卸载的软件的名字 <span class="comment">#卸载软件同时删除配置文件</span></span><br><span class="line">sudo apt-get remove 要卸载的软件的名字  <span class="comment">#卸载该软件</span></span><br><span class="line">sudo apt-get clean <span class="comment"># apt缓存删除</span></span><br></pre></td></tr></table></figure><h2 id="时区">时区</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timedatectl status # 查看当前时间状态</span><br><span class="line">timedatectl set-timezone &quot;Asia/Shanghai&quot; # 修改时区为上海时间</span><br></pre></td></tr></table></figure><h2 id="tmux">Tmux</h2><p>Tmux是一个非常方便的session管理以及session工具, 教程参见<a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">Tmux使用教程（阮一峰）</a></p><figure><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/tmux-help.png" alt="Tmux快捷键指南" /><figcaption aria-hidden="true">Tmux快捷键指南</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正向代理和反向代理的区分</title>
      <link href="/hexo_zh/2021/07/24/zheng-xiang-dai-li-he-fan-xiang-dai-li-de-qu-fen/"/>
      <url>/hexo_zh/2021/07/24/zheng-xiang-dai-li-he-fan-xiang-dai-li-de-qu-fen/</url>
      
        <content type="html"><![CDATA[<p>最近在学习的过程中，对正向代理和反向代理的区别纠结了好久，总是感觉有点相似，又有些微妙的差别，但是又说不上到底如何理解，终于找到了一篇讲得比较清晰好理解的博文，适合我这种新手小白，记录一下，原文原载于<a href="https://cloud.tencent.com/developer/article/1418457">终于有人把正向代理和反向代理解释的明明白白了！ - 云+社区 - 腾讯云 (tencent.com)</a>，原文图文并茂，生动形象，本文由于版权原因，没有了图片，权当个人笔记，如有兴趣，可以直接去看一看原文。</p><span id="more"></span><p><strong>正向代理</strong></p><p>正向代理（forward proxy）：是一个位于客户端和目标服务器之间的服务器(代理服务器)，为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。</p><p>这种代理其实在生活中是比较常见的，比如访问外国网站技术，其用到的就是代理技术。</p><p>有时候，用户想要访问某国外网站，该网站无法在国内直接访问，但是我们可以访问到一个代理服务器，这个代理服务器可以访问到这个国外网站。这样呢，用户对该国外网站的访问就需要通过代理服务器来转发请求，并且该代理服务器也会将请求的响应再返回给用户。这个上网的过程就是用到了正向代理。</p><p>这个过程其实和租房子很像。</p><p>租房子的时候，一般情况下，我们很难联系到房东，因为有些房东为了图方便，只把自己的房屋信息和钥匙交给中介了。而房客想要租房子，只能通过中介才能联系到房东。而对于房东来说，他可能根本不知道真正要租他的房子的人是谁，他只知道是中介在联系他。</p><p>这里面一共有三个角色，租客（用户）、中介（代理服务器）和房东（国外网站，目标服务器）。引入中介（代理服务器）的原因是用户无法联系上房东（用户无法访问国外网站）。</p><p><strong>所以，正向代理，其实是"代理服务器"代理了"客户端"，去和"目标服务器"进行交互。</strong></p><p>通过正向代理服务器访问目标服务器，目标服务器是不知道真正的客户端是谁的，甚至不知道访问自己的是一个代理（有时候中介也直接冒充租客）。</p><h3 id="正向代理的用途"><strong>正向代理的用途</strong></h3><p><strong>突破访问限制</strong></p><p>通过代理服务器，可以突破自身IP访问限制，访问国外网站，教育网等。</p><p>即，租客可以通过中介，来解决无法联系上房东的问题。</p><p><strong>提高访问速度</strong></p><p>通常代理服务器都设置一个较大的硬盘缓冲区，会将部分请求的响应保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。</p><p>即，中介手里留存了很多房源信息和钥匙，可以直接带租客去看房。</p><p><strong>隐藏客户端真实IP</strong></p><p>上网者也可以通过这种方法隐藏自己的IP，免受攻击。</p><p>即，房东并不知道租客的真实身份。PS：但是中介知道了，可能骚扰更多….</p><h3 id="反向代理"><strong>反向代理</strong></h3><p>反向代理（reverse proxy）：是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p><p>我们在租房子的过程中，除了有些房源需要通过中介以外，还有一些是可以直接通过房东来租的。用户直接找到房东租房的这种情况就是我们不使用代理直接访问国内的网站的情况。</p><p>还有一种情况，就是我们以为我们接触的是房东，其实有时候也有可能并非房主本人，有可能是他的亲戚、朋友，甚至是二房东。但是我们并不知道和我们沟通的并不是真正的房东。这种帮助真正的房主租房的二房东其实就是反向代理服务器。这个过程就是反向代理。</p><p>对于常用的场景，就是我们在Web开发中用到的<a href="https://cloud.tencent.com/product/clb?from=10680">负载均衡</a>服务器（二房东），客户端（租客）发送请求到负载均衡服务器（二房东）上，负载均衡服务器（二房东）再把请求转发给一台真正的服务器（房东）来执行，再把执行结果返回给客户端（租客）。</p><p>￼</p><p><strong>所以，反向代理，其实是"代理服务器"代理了"目标服务器"，去和"客户端"进行交互。</strong></p><p>通过反向代理服务器访问目标服务器时，客户端是不知道真正的目标服务器是谁的，甚至不知道自己访问的是一个代理。</p><h3 id="反向代理的用途"><strong>反向代理的用途</strong></h3><p><strong>隐藏服务器真实IP</strong></p><p>使用反向代理，可以对客户端隐藏服务器的IP地址。</p><p>即，租客并不房东知道的真实身份。</p><p><strong>负载均衡</strong></p><p>反向代理服务器可以做负载均衡，根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上。</p><p>即，二房东发现房主本人很忙，于是找到房主的妻子帮忙处理租房事宜。</p><p><strong>提高访问速度</strong></p><p>反向代理服务器可以对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务，提高访问速度。</p><p>即，二房东同样有房屋信息和钥匙。</p><p><strong>提供安全保障</strong></p><p>反向代理服务器可以作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等。还可以为后端服务器统一提供加密和SSL加速（如SSL终端代理），提供HTTP访问认证等。</p><p>即，二房东可以有效的保护房东的安全。</p><h3 id="正向代理和反向代理的区别"><strong>正向代理和反向代理的区别</strong></h3><p>虽然正向代理服务器和反向代理服务器所处的位置都是客户端和真实服务器之间，所做的事情也都是把客户端的请求转发给服务器，再把服务器的响应转发给客户端，但是二者之间还是有一定的差异的。</p><p>1、<strong>正向代理其实是客户端的代理</strong>，帮助客户端访问其无法访问的服务器资源。<strong>反向代理则是服务器的代理</strong>，帮助服务器做负载均衡，安全防护等。</p><p>2、<strong>正向代理一般是客户端架设的</strong>，比如在自己的机器上安装一个代理软件。而<strong>反向代理一般是服务器架设的</strong>，比如在自己的机器集群中部署一个反向代理服务器。</p><p>3、<strong>正向代理中，服务器不知道真正的客户端到底是谁</strong>，以为访问自己的就是真实的客户端。而在<strong>反向代理中，客户端不知道真正的服务器是谁</strong>，以为自己访问的就是真实的服务器。</p><p>4、正向代理和反向代理的作用和目的不同。<strong>正向代理主要是用来解决访问限制问题。而反向代理则是提供负载均衡、安全防护等作用。二者均能提高访问速度。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL的个人使用笔记</title>
      <link href="/hexo_zh/2021/07/23/postgresql-de-ge-ren-shi-yong-bi-ji/"/>
      <url>/hexo_zh/2021/07/23/postgresql-de-ge-ren-shi-yong-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>作为一个数据库小白，PostgreSQL居然是我第一个使用的数据库而不是MySQL。有的时候有些操作难免忘记，就又要到网上去查询，这里就记录一下我忘记的那些一些用到过的SQL语句吧（虽然有些可能感觉挺蠢的orz。</p><span id="more"></span><h2 id="添加和删除unique约束">添加和删除UNIQUE约束</h2><p>我们现在使用一下语句创建了一张表，用来记录app在某一天的使用情况，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> app_usage_info (</span><br><span class="line"><span class="keyword">day</span> <span class="type">date</span>,</span><br><span class="line">app_name text,</span><br><span class="line">package_name text,</span><br><span class="line">usage_time <span class="type">interval</span>,</span><br><span class="line">usage_count <span class="type">integer</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>然而，创建好之后我发现，我需要插入的数据在特定的一天中，一个app只能插入一组数据，所以我们需要添加UNIQUE约束：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> app_usage_info <span class="keyword">add</span> <span class="keyword">constraint</span> unique_app_one_day <span class="keyword">unique</span>(<span class="keyword">day</span>,app_name); </span><br></pre></td></tr></table></figure><p>想要删除这一个约束，我们可以使用一下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> app_usage_info <span class="keyword">drop</span> <span class="keyword">constraint</span> unique_app_one_day;</span><br></pre></td></tr></table></figure><p>如果我们在建表的时候就添加约束，那么应该这样写</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> app_usage_info (</span><br><span class="line"><span class="keyword">day</span> <span class="type">date</span>,</span><br><span class="line">app_name text,</span><br><span class="line">package_name text,</span><br><span class="line">usage_time <span class="type">interval</span>,</span><br><span class="line">usage_count <span class="type">integer</span>,</span><br><span class="line">    constaint unique_app_one_day <span class="keyword">unique</span>(<span class="keyword">day</span>,app_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="更新操作upsert">更新操作UPSERT</h2><p>UPSERT就是说当我们在INSERT的时候，发现与约束冲突，这个时候我们就可以对原有的数据进行更新而不是插入。例如我们对上面的表进行UPSERT，下面的SQL语句中excluded中的内容就是发生冲突的数据，我们使用这个数据对其进行更新即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> app_usage_info <span class="keyword">values</span> (<span class="string">&#x27;2021-07-16&#x27;</span>,<span class="string">&#x27;QQ&#x27;</span>,<span class="string">&#x27;com.tencent.mobileqq&#x27;</span>,<span class="string">&#x27;03:22:44&#x27;</span>,<span class="string">&#x27;20&#x27;</span>)</span><br><span class="line"><span class="keyword">on</span> conflict(<span class="keyword">day</span>,app_name) do update </span><br><span class="line"><span class="keyword">set</span> &quot;usage_time&quot;<span class="operator">=</span>excluded.usage_time,&quot;usage_count&quot;<span class="operator">=</span>excluded.usage_count;</span><br></pre></td></tr></table></figure><h2 id="删除某个字段">删除某个字段</h2><p>同样的，我们创建一个表，用来记录app的活动情况，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> DB_usage_events (</span><br><span class="line">app_name text,</span><br><span class="line">package_name text,</span><br><span class="line">start_time timestamptz,</span><br><span class="line">end_time, timestamptz</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>然后，我们创建好之后发现我们可以不需要app_name这个字段，于是我们就可以用一下命令删去：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> DB_usage_events <span class="keyword">drop</span> <span class="keyword">column</span> if <span class="keyword">exists</span> app_name;</span><br></pre></td></tr></table></figure><h2 id="设置postgresql时区">设置PostgreSQL时区</h2><p>在PostgreSQL中的日期/时间类型有时区之差，在使用中发现默认使用的是零时区，所以我们需要切换一下时区：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="type">time</span> zone; <span class="comment">-- 显示当前时区</span></span><br><span class="line"><span class="keyword">select</span> form now(); <span class="comment">-- 显示当前时间</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> pg_timezone_names; <span class="comment">-- 查看支持的时区列表</span></span><br><span class="line"><span class="keyword">set</span> <span class="type">time</span> zone <span class="string">&#x27;PRC&#x27;</span>; <span class="comment">-- 设置成东八区 北京时间 UTC+8</span></span><br></pre></td></tr></table></figure><p>上述方法是session级设置，退出psql只有就不会再生效，我们可以使用用户级配置或者数据库级配置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用户级配置</span></span><br><span class="line"><span class="keyword">alter</span> role rolename <span class="keyword">set</span> timezone<span class="operator">=</span><span class="string">&#x27;PRC&#x27;</span>;</span><br><span class="line"><span class="keyword">alter</span> role <span class="keyword">all</span> <span class="keyword">set</span> timezone<span class="operator">=</span><span class="string">&#x27;PRC&#x27;</span>;</span><br><span class="line"><span class="comment">-- 数据库级配置</span></span><br><span class="line"><span class="keyword">alter</span> database dbname <span class="keyword">set</span> timezone<span class="operator">=</span><span class="string">&#x27;PRC&#x27;</span>;</span><br></pre></td></tr></table></figure><p>更加详细的PostgreSQL日期/时间/时区相关可以参考这篇博文<a href="https://blog.csdn.net/wangkai_123456/article/details/106333521">PostgreSQL时区、时间不一致、差8小时</a></p><h2 id="schema-刷新-schema-reloading">Schema 刷新 (Schema Reloading)</h2><p>在使用RESTful API的时候，如果在数据库中创建了一个函数，那么要想在RESTful API中使用这个函数，那么首先我们需要reload Schema，使用以下命令可以在不中断PostgreSQL Service服务的同时刷新Schema</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall -SIGUSR1 postgrest</span><br></pre></td></tr></table></figure><p>参考<a href="https://postgrest.org/en/stable/admin.html#schema-reloading">Hardening PostgREST — PostgREST 7.0.1 documentation</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java日期与格式化：Date,Calendar,DateFormat和SimpleDateFormat类</title>
      <link href="/hexo_zh/2021/07/22/javanote/java-ri-qi-ge-shi-hua-dateformat-lei-he-simpledateformat-lei/"/>
      <url>/hexo_zh/2021/07/22/javanote/java-ri-qi-ge-shi-hua-dateformat-lei-he-simpledateformat-lei/</url>
      
        <content type="html"><![CDATA[<p>最近的一个项目中有着大量关于时间和日期的应用，从网上找到一篇教程记录一下，就当放进收藏夹里好了。</p><p><code>Date</code>和<code>Calendar</code>原载于<a href="http://c.biancheng.net/view/876.html">Java时间日期的处理：Java Date类、Calendar类详解 (biancheng.net)</a></p><p><code>DateFormat</code>和<code>SimpleDateFormat</code>原载于<a href="http://c.biancheng.net/view/878.html">Java日期格式化（DateFormat类和SimpleDateFormat类） (biancheng.net)</a></p><span id="more"></span><p>在 <a href="http://c.biancheng.net/java/">Java</a> 中获取当前时间，可以使用 java.util.Date 类和 java.util.Calendar 类完成。其中，Date 类主要封装了系统的日期和时间的信息，Calendar 类则会根据系统的日历来解释 Date 对象。下面详细介绍这两个类的具体使用。</p><h2 id="date-类">Date 类</h2><p>Date 类表示系统特定的时间戳，可以精确到毫秒。Date 对象表示时间的默认顺序是星期、月、日、小时、分、秒、年。</p><h3 id="构造方法">构造方法</h3><p>Date 类有如下两个构造方法。</p><ul><li>Date()：此种形式表示分配 Date 对象并初始化此对象，以表示分配它的时间（精确到毫秒），使用该构造方法创建的对象可以获取本地的当前时间。</li><li>Date(long date)：此种形式表示从 GMT 时间（格林尼治时间）1970 年 1 月 1 日 0 时 0 分 0 秒开始经过参数 date 指定的毫秒数。</li></ul><p>这两个构造方法的使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date date1 = <span class="keyword">new</span> Date();    <span class="comment">// 调用无参数构造函数</span></span><br><span class="line">System.out.println(date1.toString());    <span class="comment">// 输出：Wed May 18 21:24:40 CST 2016</span></span><br><span class="line">Date date2 = <span class="keyword">new</span> Date(<span class="number">60000</span>);    <span class="comment">// 调用含有一个long类型参数的构造函数</span></span><br><span class="line">System.out.println(date2);    <span class="comment">// 输出：Thu Jan 0108:01:00 CST 1970</span></span><br></pre></td></tr></table></figure><p>Date 类的无参数构造方法获取的是系统当前的时间，显示的顺序为星期、月、日、小时、分、秒、年。</p><p>Date 类带 long 类型参数的构造方法获取的是距离 GMT 指定毫秒数的时间，60000 毫秒是一分钟，而 GMT（格林尼治标准时间）与 CST（中央标准时间）相差 8 小时，也就是说 1970 年 1 月 1 日 00:00:00 GMT 与 1970 年 1 月 1 日 08:00:00 CST 表示的是同一时间。 因此距离 1970 年 1 月 1 日 00:00:00 CST 一分钟的时间为 1970 年 1 月 1 日 00:01:00 CST，即使用 Date 对象表示为 Thu Jan 01 08:01:00 CST 1970。</p><h3 id="常用方法">常用方法</h3><p>Date 类提供了许多与日期和事件相关的方法，其中常见的方法如表 1 所示。</p><table><colgroup><col style="width: 35%" /><col style="width: 64%" /></colgroup><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>boolean after(Date when)</code></td><td>判断此日期是否在指定日期之后</td></tr><tr class="even"><td><code>boolean before(Date when)</code></td><td>判断此日期是否在指定日期之前</td></tr><tr class="odd"><td><code>int compareTo(Date anotherDate)</code></td><td>比较两个日期的顺序</td></tr><tr class="even"><td><code>boolean equals(Object obj)</code></td><td>比较两个日期的相等性</td></tr><tr class="odd"><td><strong><code>long getTime()</code></strong></td><td>返回自 1970 年 1 月 1 日 00:00:00 GMT 以来，此 Date 对象表示的毫秒数</td></tr><tr class="even"><td><code>String toString()</code></td><td>把此 Date 对象转换为以下形式的 String: dow mon dd hh:mm:ss zzz yyyy。 其中 dow 是一周中的某一天(Sun、Mon、Tue、Wed、Thu、Fri 及 Sat)</td></tr></tbody></table><h3 id="例-1">例 1</h3><p>下面使用一个实例来具体演示 Date 类的使用。假设，某一天特定时间要去做一件事，而且那个时间已经过去一分钟之后才想起来这件事还没有办，这时系统将会提示已经过去了多 长时间。具体的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要做的事情：&quot;</span>);</span><br><span class="line">        String title = input.next();</span><br><span class="line">        Date date1 = <span class="keyword">new</span> Date(); <span class="comment">// 获取当前日期</span></span><br><span class="line">        System.out.println(<span class="string">&quot;[&quot;</span> + title + <span class="string">&quot;] 这件事发生时间为：&quot;</span> + date1);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">60000</span>);<span class="comment">// 暂停 1 分钟</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Date date2 = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(<span class="string">&quot;现在时间为：&quot;</span> + date2);</span><br><span class="line">        <span class="keyword">if</span> (date2.before(date1)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你还有 &quot;</span> + (date2.getTime() - date1.getTime()) / <span class="number">1000</span> + <span class="string">&quot; 秒需要去完成【&quot;</span> + title + <span class="string">&quot;】这件事！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;【&quot;</span> + title + <span class="string">&quot;】事情已经过去了 &quot;</span> + (date2.getTime() - date1.getTime()) / <span class="number">1000</span> + <span class="string">&quot; 秒&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该程序中，分别使用 Date 类的无参数构造方法创建了两个 Date 对象。在创建完第一个 Date 对象后，使用 Thread.sleep() 方法让程序休眠 60 秒，然后再创建第二个 Date 对象，这样第二个 Date 对象所表示的时间将会在第一个 Date 对象所表示时间之后，因此“date2.before(date1)”条件表达式不成立，从而执行 else 块中的代码，表示事情已经发生过。</p><p>运行该程序，执行结果如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请输入要做的事情：</span><br><span class="line">收快递</span><br><span class="line">【收快递】这件事发生时间为：Fri Oct 12 11:11:07 CST 2018</span><br><span class="line">现在时间为：Fri Oct 12 11:12:07 CST 2018</span><br><span class="line">【收快递】事情已经过去了 60 秒</span><br></pre></td></tr></table></figure><h2 id="calendar-类">Calendar 类</h2><p>Calendar 类是一个抽象类，它为特定瞬间与 YEAR、MONTH、DAY_OF—MONTH、HOUR 等日历字段之间的转换提供了一些方法，并为操作日历字段（如获得下星期的日期） 提供了一些方法。</p><p>创建 Calendar 对象不能使用 new 关键字，因为 Calendar 类是一个抽象类，但是它提供了一个<code>getInstance()</code>方法来获得 Calendar类的对象。<code>getInstance()</code> 方法返回一个 Calendar 对象，其日历字段已由当前日期和时间初始化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance();</span><br></pre></td></tr></table></figure><p>当创建了一个 Calendar 对象后，就可以通过 Calendar 对象中的一些方法来处理日期、时间。Calendar 类的常用方法如表 2 所示。</p><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>void add(int field, int amount)</code></td><td>根据日历的规则，为给定的日历字段 field 添加或减去指定的时间量 amount</td></tr><tr class="even"><td><code>boolean after(Object when)</code></td><td>判断此 Calendar 表示的时间是否在指定时间 when 之后，并返回判断结果</td></tr><tr class="odd"><td><code>boolean before(Object when)</code></td><td>判断此 Calendar 表示的时间是否在指定时间 when 之前，并返回判断结果</td></tr><tr class="even"><td><code>void clear()</code></td><td>清空 Calendar 中的日期时间值</td></tr><tr class="odd"><td><code>int compareTo(Calendar anotherCalendar)</code></td><td>比较两个 Calendar 对象表示的时间值（从格林威治时间 1970 年 01 月 01 日 00 时 00 分 00 秒至现在的毫秒偏移量），大则返回 1，小则返回 -1，相等返回 0</td></tr><tr class="even"><td><code>int get(int field)</code></td><td>返回指定日历字段的值</td></tr><tr class="odd"><td><code>int getActualMaximum(int field)</code></td><td>返回指定日历字段可能拥有的最大值</td></tr><tr class="even"><td><code>int getActualMinimum(int field)</code></td><td>返回指定日历字段可能拥有的最小值</td></tr><tr class="odd"><td><code>int getFirstDayOfWeek()</code></td><td>获取一星期的第一天。根据不同的国家地区，返回不同的值</td></tr><tr class="even"><td><code>static Calendar getInstance()</code></td><td>使用默认时区和语言坏境获得一个日历</td></tr><tr class="odd"><td><code>static Calendar getInstance(TimeZone zone)</code></td><td>使用指定时区和默认语言环境获得一个日历</td></tr><tr class="even"><td><strong><code>static Calendar getInstance(TimeZone zone, Locale aLocale)</code></strong></td><td>使用指定时区和语言环境获得一个日历</td></tr><tr class="odd"><td><strong><code>Date getTime()</code></strong></td><td>返回一个表示此 Calendar 时间值（从格林威治时间 1970 年 01 月 01 日 00 时 00 分 00 秒至现在的毫秒偏移量）的 Date 对象</td></tr><tr class="even"><td><strong><code>long getTimeInMillis()</code></strong></td><td>返回此 Calendar 的时间值，以毫秒为单位</td></tr><tr class="odd"><td><code>void set(int field, int value)</code></td><td>为指定的日历字段设置给定值</td></tr><tr class="even"><td><code>void set(int year, int month, int date)</code></td><td>设置日历字段 YEAR、MONTH 和 DAY_OF_MONTH 的值</td></tr><tr class="odd"><td><code>void set(int year, int month, int date, int hourOfDay, int minute, int second)</code></td><td>设置字段 YEAR、MONTH、DAY_OF_MONTH、HOUR、 MINUTE 和 SECOND 的值</td></tr><tr class="even"><td><code>void setFirstDayOfWeek(int value)</code></td><td>设置一星期的第一天是哪一天</td></tr><tr class="odd"><td><strong><code>void setTimeInMillis(long millis)</code></strong></td><td>用给定的 long 值设置此 Calendar 的当前时间值</td></tr></tbody></table><p>Calendar 对象可以调用 set() 方法将日历翻到任何一个时间，当参数 year 取负数时表示公元前。Calendar 对象调用 get() 方法可以获取有关年、月、日等时间信息，参数 field 的有效值由 Calendar 静态常量指定。</p><p>Calendar 类中定义了许多常量，分别表示不同的意义。</p><ul><li><code>Calendar.YEAR</code>：年份。</li><li><code>Calendar.MONTH</code>：月份。</li><li><code>Calendar.DATE</code>：日期。</li><li><code>Calendar.DAY_OF_MONTH</code>：日期，和上面的字段意义完全相同。</li><li><code>Calendar.HOUR</code>：12小时制的小时。</li><li><code>Calendar.HOUR_OF_DAY</code>：24 小时制的小时。</li><li><code>Calendar.MINUTE</code>：分钟。</li><li><code>Calendar.SECOND</code>：秒。</li><li><code>Calendar.DAY_OF_WEEK</code>：星期几。</li></ul><p>例如，要获取当前月份可用如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int month = Calendar.getInstance().get(Calendar.MONTH);</span><br></pre></td></tr></table></figure><p>如果整型变量 month 的值是 0，表示当前日历是在 1 月份；如果值是 11，则表示当前日历在 12 月份。</p><p>使用 Calendar 类处理日期时间的实例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance(); <span class="comment">// 如果不设置时间，则默认为当前时间</span></span><br><span class="line">calendar.setTime(<span class="keyword">new</span> Date()); <span class="comment">// 将系统当前时间赋值给 Calendar 对象</span></span><br><span class="line">System.out.println(<span class="string">&quot;现在时刻：&quot;</span> + calendar.getTime()); <span class="comment">// 获取当前时间</span></span><br><span class="line"><span class="keyword">int</span> year = calendar.get(Calendar.YEAR); <span class="comment">// 获取当前年份</span></span><br><span class="line">System.out.println(<span class="string">&quot;现在是&quot;</span> + year + <span class="string">&quot;年&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> month = calendar.get(Calendar.MONTH) + <span class="number">1</span>; <span class="comment">// 获取当前月份（月份从 0 开始，所以加 1）</span></span><br><span class="line">System.out.print(month + <span class="string">&quot;月&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> day = calendar.get(Calendar.DATE); <span class="comment">// 获取日</span></span><br><span class="line">System.out.print(day + <span class="string">&quot;日&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> week = calendar.get(Calendar.DAY_OF_WEEK) - <span class="number">1</span>; <span class="comment">// 获取今天星期几（以星期日为第一天）</span></span><br><span class="line">System.out.print(<span class="string">&quot;星期&quot;</span> + week);</span><br><span class="line"><span class="keyword">int</span> hour = calendar.get(Calendar.HOUR_OF_DAY); <span class="comment">// 获取当前小时数（24 小时制）</span></span><br><span class="line">System.out.print(hour + <span class="string">&quot;时&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> minute = calendar.get(Calendar.MINUTE); <span class="comment">// 获取当前分钟</span></span><br><span class="line">System.out.print(minute + <span class="string">&quot;分&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> second = calendar.get(Calendar.SECOND); <span class="comment">// 获取当前秒数</span></span><br><span class="line">System.out.print(second + <span class="string">&quot;秒&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> millisecond = calendar.get(Calendar.MILLISECOND); <span class="comment">// 获取毫秒数</span></span><br><span class="line">System.out.print(millisecond + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> dayOfMonth = calendar.get(Calendar.DAY_OF_MONTH); <span class="comment">// 获取今天是本月第几天</span></span><br><span class="line">System.out.println(<span class="string">&quot;今天是本月的第 &quot;</span> + dayOfMonth + <span class="string">&quot; 天&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> dayOfWeekInMonth = calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH); <span class="comment">// 获取今天是本月第几周</span></span><br><span class="line">System.out.println(<span class="string">&quot;今天是本月第 &quot;</span> + dayOfWeekInMonth + <span class="string">&quot; 周&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> many = calendar.get(Calendar.DAY_OF_YEAR); <span class="comment">// 获取今天是今年第几天</span></span><br><span class="line">System.out.println(<span class="string">&quot;今天是今年第 &quot;</span> + many + <span class="string">&quot; 天&quot;</span>);</span><br><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">c.set(<span class="number">2012</span>, <span class="number">8</span>, <span class="number">8</span>); <span class="comment">// 设置年月日，时分秒将默认采用当前值</span></span><br><span class="line">System.out.println(<span class="string">&quot;设置日期为 2012-8-8 后的时间：&quot;</span> + c.getTime()); <span class="comment">// 输出时间</span></span><br></pre></td></tr></table></figure><p>上面的示例代码演示了 Calendar 类中的方法与常量的结合使用，从而完成处理日期的操作。 ### 例 2</p><p>下面使用 Calendar 类来实现日历的打印功能，代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalendarDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar calendar = Calendar.getInstance();</span><br><span class="line">        calendar.set(<span class="number">2016</span>, <span class="number">5</span>, <span class="number">1</span>); <span class="comment">// 实际的calendar对象所表示的日期为2016年6月1日</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断2016年6月1日为一周中的第几天</span></span><br><span class="line">        <span class="keyword">int</span> index = calendar.get(Calendar.DAY_OF_WEEK) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>[] title = &#123; <span class="string">&#x27;日&#x27;</span>, <span class="string">&#x27;一&#x27;</span>, <span class="string">&#x27;二&#x27;</span>, <span class="string">&#x27;三&#x27;</span>, <span class="string">&#x27;四&#x27;</span>, <span class="string">&#x27;五&#x27;</span>, <span class="string">&#x27;六&#x27;</span> &#125;; <span class="comment">// 存放日历的头部</span></span><br><span class="line">        <span class="keyword">int</span> daysArray[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>][<span class="number">7</span>];<span class="comment">// 存放日历的数据</span></span><br><span class="line">        <span class="keyword">int</span> daysInMonth = <span class="number">31</span>; <span class="comment">// 该月的天数</span></span><br><span class="line">        <span class="keyword">int</span> day = <span class="number">1</span>; <span class="comment">// 自动增长</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 填充第一周的日期数据，即日历中的第一行</span></span><br><span class="line">            daysArray[<span class="number">0</span>][i] = day++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 填充其他周的日历数据，控制行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果当前day表示的是本月最后一天，则停止向数组中继续赋值</span></span><br><span class="line">                <span class="keyword">if</span> (day &gt; daysInMonth) &#123;</span><br><span class="line">                    i = <span class="number">6</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                daysArray[i][j] = day++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------2016 年 6 月--------------------\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; title.length; i++) &#123;</span><br><span class="line">            System.out.print(title[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 输出二元数组daysArray中的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (daysArray[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 如果到月末，则完成显示日历的任务，停止该方法的执行</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(daysArray[i][j] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序看似复杂其实很简单。因为 Calendar 类所表示的时间月份是 set() 方法中表示月份的参数值 +1，因此 Calendar 类的实际时间为 2016 年 6 月 1 日。在下面的代码中分别获取 6 月 1 日为本周中的第几天，以便在相应的星期下开始输出 6 月份的日历。程序中的 <code>daysArray</code> 是一个二元数组，该二元数组控制了日历的格式输出，第一个子数组控制日历的行，第二个子数组控制曰历的列，即可输出二元数组中的每一个元素。</p><p>运行程序，执行结果如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">------------------2016 年 6 月--------------------</span><br><span class="line"></span><br><span class="line">日 一 二 三 四 五 六</span><br><span class="line">   1 2 3 4</span><br><span class="line">5 6 7 8 9 10 11</span><br><span class="line">12 13 14 15 16 17 18</span><br><span class="line">19 20 21 22 23 24 25</span><br><span class="line">26 27 28 29 30 31 </span><br></pre></td></tr></table></figure><p>日期格式化：格式化日期表示将日期/时间格式转换为预先定义的日期/时间格式。例如将日期“Fri May 18 15:46:24 CST2016” 格式转换为 “2016-5-18 15:46:24 星期五”的格式。</p><p>在 <a href="http://c.biancheng.net/java/">Java</a> 中，可以使用 <code>DateFormat</code> 类和 <code>SimpleDateFormat</code>类来格式化日期，下面详细介绍这两个格式化日期类的使用。</p><h2 id="dateformat-类">DateFormat 类</h2><p><code>DateFormat</code> 是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。日期/时间格式化子类（如 <code>SimpleDateFormat</code>）允许进行格式化（也就是日期→文本）、解析（文本→日期）和标准化日期。</p><p>在创建<code>DateFormat</code> 对象时不能使用 new 关键字，而应该使用 <code>DateFormat</code> 类中的静态方法 <code>getDateInstance()</code>，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DateFormat df = DateFormat.getDatelnstance();</span><br></pre></td></tr></table></figure><p>在创建了一个 <code>DateFormat</code> 对象后，可以调用该对象中的方法来对日期/时间进行格式化。<code>DateFormat</code> 类中常用方法如表 1 所示。</p><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>String format(Date date)</code></td><td>将 Date 格式化日期/时间字符串</td></tr><tr class="even"><td><code>Calendar getCalendar()</code></td><td>获取与此日期/时间格式相关联的日历</td></tr><tr class="odd"><td><code>static DateFormat getDateInstance()</code></td><td>获取具有默认格式化风格和默认语言环境的<strong>日期</strong>格式</td></tr><tr class="even"><td><code>static DateFormat getDateInstance(int style)</code></td><td>获取具有指定格式化风格和默认语言环境的<strong>日期</strong>格式</td></tr><tr class="odd"><td><strong><code>static DateFormat getDateInstance(int style, Locale locale)</code></strong></td><td>获取具有指定格式化风格和指定语言环境的<strong>日期</strong>格式</td></tr><tr class="even"><td><code>static DateFormat getDateTimeInstance()</code></td><td>获取具有默认格式化风格和默认语言环境的<strong>日期/时间</strong>格式</td></tr><tr class="odd"><td><code>static DateFormat getDateTimeInstance(int dateStyle,int timeStyle)</code></td><td>获取具有指定日期/时间格式化风格和默认语言环境的 <strong>日期/时间</strong>格式</td></tr><tr class="even"><td><strong><code>static DateFormat getDateTimeInstance(int dateStyle,int timeStyle,Locale locale)</code></strong></td><td>获取具有指定日期/时间格式化风格和指定语言环境的 <strong>日期/时间</strong>格式</td></tr><tr class="odd"><td><code>static DateFormat getTimeInstance()</code></td><td>获取具有默认格式化风格和默认语言环境的<strong>时间</strong>格式</td></tr><tr class="even"><td><code>static DateFormat getTimeInstance(int style)</code></td><td>获取具有指定格式化风格和默认语言环境的<strong>时间</strong>格式</td></tr><tr class="odd"><td><strong><code>static DateFormat getTimeInstance(int style, Locale locale)</code></strong></td><td>获取具有指定格式化风格和指定语言环境的<strong>时间</strong>格式</td></tr><tr class="even"><td><code>void setCalendar(Calendar newCalendar)</code></td><td>为此格式设置日历</td></tr><tr class="odd"><td><code>Date parse(String source)</code></td><td>将给定的字符串解析成日期/时间</td></tr></tbody></table><p>格式化样式(<code>dateStyle</code>)主要通过 <code>DateFormat</code> 常量设置。将不同的常量传入到表 1 所示的方法中，以控制结果的长度。<code>DateFormat</code> 类的常量如下。</p><ul><li>SHORT：完全为数字，如 12.5.10 或 5:30pm。</li><li><strong>MEDIUM：较长，如 May 10，2016。</strong> <mark>个人感觉用的比较多</mark></li><li>LONG：更长，如 May 12，2016 或 11:15:32am。</li><li>FULL：是完全指定，如 Tuesday、May 10、2012 AD 或 11:15:42am CST。</li></ul><p>使用 <code>DateFormat</code> 类格式化曰期/时间的示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取不同格式化风格和中国环境的日期</span></span><br><span class="line">DateFormat df1 = DateFormat.getDateInstance(DateFormat.SHORT, Locale.CHINA);</span><br><span class="line">DateFormat df2 = DateFormat.getDateInstance(DateFormat.FULL, Locale.CHINA);</span><br><span class="line">DateFormat df3 = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.CHINA);</span><br><span class="line">DateFormat df4 = DateFormat.getDateInstance(DateFormat.LONG, Locale.CHINA);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取不同格式化风格和中国环境的时间</span></span><br><span class="line">DateFormat df5 = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.CHINA);</span><br><span class="line">DateFormat df6 = DateFormat.getTimeInstance(DateFormat.FULL, Locale.CHINA);</span><br><span class="line">DateFormat df7 = DateFormat.getTimeInstance(DateFormat.MEDIUM, Locale.CHINA);</span><br><span class="line">DateFormat df8 = DateFormat.getTimeInstance(DateFormat.LONG, Locale.CHINA);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将不同格式化风格的日期格式化为日期字符串</span></span><br><span class="line">String date1 = df1.format(<span class="keyword">new</span> Date());</span><br><span class="line">String date2 = df2.format(<span class="keyword">new</span> Date());</span><br><span class="line">String date3 = df3.format(<span class="keyword">new</span> Date());</span><br><span class="line">String date4 = df4.format(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将不同格式化风格的时间格式化为时间字符串</span></span><br><span class="line">String time1 = df5.format(<span class="keyword">new</span> Date());</span><br><span class="line">String time2 = df6.format(<span class="keyword">new</span> Date());</span><br><span class="line">String time3 = df7.format(<span class="keyword">new</span> Date());</span><br><span class="line">String time4 = df8.format(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出日期</span></span><br><span class="line">System.out.println(<span class="string">&quot;SHORT：&quot;</span> + date1 + <span class="string">&quot; &quot;</span> + time1);</span><br><span class="line">System.out.println(<span class="string">&quot;FULL：&quot;</span> + date2 + <span class="string">&quot; &quot;</span> + time2);</span><br><span class="line">System.out.println(<span class="string">&quot;MEDIUM：&quot;</span> + date3 + <span class="string">&quot; &quot;</span> + time3);</span><br><span class="line">System.out.println(<span class="string">&quot;LONG：&quot;</span> + date4 + <span class="string">&quot; &quot;</span> + time4);</span><br></pre></td></tr></table></figure><p>运行该段代码，输出的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SHORT：18-10-15 上午9:30</span><br><span class="line">FULL：2018年10月15日 星期一 上午09时30分43秒 CST</span><br><span class="line">MEDIUM：2018-10-15 9:30:43</span><br><span class="line">LONG：2018年10月15日 上午09时30分43秒</span><br></pre></td></tr></table></figure><p>该示例主要介绍了 <code>DateFormat</code> 类中方法与常量的结合使用，通过使用<code>DateFomat</code>类可以对日期进行不同风格的格式化。</p><h2 id="simpledateformat-类">SimpleDateFormat 类</h2><p>如果使用 <code>DateFormat</code> 类格式化日期/时间并不能满足要求，那么就需要使用 <code>DateFormat</code> 类的子类——<code>SimpleDateFormat</code>。</p><p><code>SimpleDateFormat</code> 是一个以与语言环境有关的方式来格式化和解析日期的具体类，它允许进行格式化（日期→文本）、解析（文本→日期）和规范化。<code>SimpleDateFormat</code> 使得可以选择任何用户定义的日期/时间格式的模式。</p><p><code>SimpleDateFormat</code> 类主要有如下 3 种构造方法。</p><ul><li><code>SimpleDateFormat()</code>：用默认的格式和默认的语言环境构造 <code>SimpleDateFormat</code>。</li><li><code>SimpleDateFormat(String pattern)</code>：用指定的格式和默认的语言环境构造 <code>SimpleDateFormat</code>。</li><li><code>SimpleDateFormat(String pattern,Locale locale)</code>：用指定的格式和指定的语言环境构造 <code>SimpleDateFormat</code>。</li></ul><p><code>SimpleDateFormat</code> 自定义格式中常用的字母及含义如表 2 所示。</p><table><colgroup><col style="width: 3%" /><col style="width: 48%" /><col style="width: 48%" /></colgroup><thead><tr class="header"><th>字母</th><th>含义</th><th>示例</th></tr></thead><tbody><tr class="odd"><td>y</td><td>年份。一般用 yy 表示两位年份，yyyy 表示 4 位年份</td><td>使用 yy 表示的年扮，如 11； 使用 yyyy 表示的年份，如 2011</td></tr><tr class="even"><td>M</td><td>月份。一般用 MM 表示月份，如果使用 MMM，则会 根据语言环境显示不同语言的月份</td><td>使用 MM 表示的月份，如 05； 使用 MMM 表示月份，在 Locale.CHINA 语言环境下，如“十月”；在 Locale.US 语言环境下，如 Oct</td></tr><tr class="odd"><td>d</td><td>月份中的天数。一般用 dd 表示天数</td><td>使用 dd 表示的天数，如 10</td></tr><tr class="even"><td>D</td><td>年份中的天数。表示当天是当年的第几天， 用 D 表示</td><td>使用 D 表示的年份中的天数，如 295</td></tr><tr class="odd"><td>E</td><td>星期几。用 E 表示，会根据语言环境的不同， 显示不 同语言的星期几</td><td>使用 E 表示星期几，在 Locale.CHINA 语 言环境下，如“星期四”；在 Locale.US 语 言环境下，如 Thu</td></tr><tr class="even"><td>H</td><td>一天中的小时数（0~23)。一般用 HH 表示小时数</td><td>使用 HH 表示的小时数，如 18</td></tr><tr class="odd"><td>h</td><td>一天中的小时数（1~12)。一般使用 hh 表示小时数</td><td>使用 hh 表示的小时数，如 10 (注意 10 有 可能是 10 点，也可能是 22 点）</td></tr><tr class="even"><td>m</td><td>分钟数。一般使用 mm 表示分钟数</td><td>使用 mm 表示的分钟数，如 29</td></tr><tr class="odd"><td>s</td><td>秒数。一般使用 ss 表示秒数</td><td>使用 ss 表示的秒数，如 38</td></tr><tr class="even"><td>S</td><td>毫秒数。一般使用 SSS 表示毫秒数</td><td>使用 SSS 表示的毫秒数，如 156</td></tr></tbody></table><h3 id="例-1-1">例 1</h3><p>编写 Java 程序，使用 <code>SimpleDateFormat</code> 类格式化当前日期并打印，日期格式为“xxxx 年 xx 月 xx 日星期 xxx 点 xx 分 xx 秒”，具体的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test13</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date now = <span class="keyword">new</span> Date(); <span class="comment">// 创建一个Date对象，获取当前时间</span></span><br><span class="line">        <span class="comment">// 指定格式化格式</span></span><br><span class="line">        SimpleDateFormat f = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;今天是 &quot;</span> + <span class="string">&quot;yyyy 年 MM 月 dd 日 E HH 点 mm 分 ss 秒&quot;</span>);</span><br><span class="line">        System.out.println(f.format(now)); <span class="comment">// 将当前时间袼式化为指定的格式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序的运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">今天是 2018 年 10 月 15 日 星期一 09 点 26 分 23 秒</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android PackageManager 使用简单记录</title>
      <link href="/hexo_zh/2021/07/22/android/android-packagemanager-shi-yong-jian-dan-ji-lu/"/>
      <url>/hexo_zh/2021/07/22/android/android-packagemanager-shi-yong-jian-dan-ji-lu/</url>
      
        <content type="html"><![CDATA[<p>Android 为我们提供了一个能够获取Package的信息的类<code>PackageManager</code>，从中我们可以通过包名获取到例如App名称，桌面图标等应用信息。简单记录一下如何使用PackageManager获取对应的信息吧。</p><span id="more"></span><h4 id="获取app-name">获取App Name</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getApplicationNameByPackageName</span><span class="params">(Context context, String packageName)</span> </span>&#123;</span><br><span class="line">    PackageManager pm = context.getPackageManager();</span><br><span class="line">    String Name;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Name = pm.getApplicationLabel(pm.getApplicationInfo(packageName, PackageManager.GET_META_DATA)).toString();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        Name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取桌面图标">获取桌面图标</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Drawable <span class="title">getAppIconByPacakgeName</span><span class="params">(Context context, String packageName)</span> </span>&#123;</span><br><span class="line">    PackageManager pm = context.getPackageManager();</span><br><span class="line">    Drawable icon;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        icon = pm.getApplicationIcon(packageName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        icon = ContextCompat.getDrawable(context, R.mipmap.ic_launcher);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> icon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java获取当天开始结束时间</title>
      <link href="/hexo_zh/2021/07/22/javanote/java-huo-qu-dang-tian-kai-shi-jie-shu-shi-jian/"/>
      <url>/hexo_zh/2021/07/22/javanote/java-huo-qu-dang-tian-kai-shi-jie-shu-shi-jian/</url>
      
        <content type="html"><![CDATA[<p>记录一下给定一个时间戳，Java获取这一天开始和结束时间的方法，主要还是没有系统的学习过Java时间相关的类和使用方法</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取指定某一天的开始时间戳</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> timeStamp 毫秒级时间戳</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> timeZone  如 GMT+8:00</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">getDailyStartTime</span><span class="params">(Long timeStamp, String timeZone)</span> </span>&#123;</span><br><span class="line">    Calendar calendar = Calendar.getInstance();</span><br><span class="line">    calendar.setTimeZone(TimeZone.getTimeZone(timeZone));</span><br><span class="line">    calendar.setTimeInMillis(timeStamp);</span><br><span class="line">    calendar.set(Calendar.HOUR_OF_DAY, <span class="number">0</span>);</span><br><span class="line">    calendar.set(Calendar.SECOND, <span class="number">0</span>);</span><br><span class="line">    calendar.set(Calendar.MINUTE, <span class="number">0</span>);</span><br><span class="line">    calendar.set(Calendar.MILLISECOND, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> calendar.getTimeInMillis();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取指定某一天的结束时间戳</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> timeStamp 毫秒级时间戳</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> timeZone  如 GMT+8:00</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">getDailyEndTime</span><span class="params">(Long timeStamp, String timeZone)</span> </span>&#123;</span><br><span class="line">    Calendar calendar = Calendar.getInstance();</span><br><span class="line">    calendar.setTimeZone(TimeZone.getTimeZone(timeZone));</span><br><span class="line">    calendar.setTimeInMillis(timeStamp);</span><br><span class="line">    calendar.set(Calendar.HOUR_OF_DAY, <span class="number">23</span>);</span><br><span class="line">    calendar.set(Calendar.MINUTE, <span class="number">59</span>);</span><br><span class="line">    calendar.set(Calendar.SECOND, <span class="number">59</span>);</span><br><span class="line">    calendar.set(Calendar.MILLISECOND, <span class="number">999</span>);</span><br><span class="line">    <span class="keyword">return</span> calendar.getTimeInMillis();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<code>TimeZone</code>的用法可以参考<a href="https://www.jb51.net/article/85930.htm#:~:text=TimeZone可以用来获取或者规定时区%2C也可以用来计算时差%2C这里我们就来详解Java中的时区类TimeZone的用法%2C特别要注意下面所提到的TimeZone相关的时间校准问题.%20TimeZone%20表示时区偏移量，也可以计算夏令时。%20在操作%20Date%2C%20Calendar等表示日期%2F时间的对象时，经常会用到TimeZone；因为不同的时区，时间不同。%20下面说说TimeZone对象的,2种常用创建方式。%20关于%20getTimeZone%20(String%20id)%20这种方式支持的全部id参数的取值，可以通过以下方式查找：%20例如，创建上面第2个打印值%22Etc%2FGMT%2B11%22对应的TimeZone。%20方法如下：">详解Java中的时区类TimeZone的用法_java_脚本之家 (jb51.net)</a>，获取默认<code>TimeZone</code>可以使用<code>TimeZone.getDefault().getID()</code>。</p><p>原文来自于<a href="https://www.cnblogs.com/lingyejun/p/11298186.html">Java获取当天、当前月、当前年(今年)的开始和结束时间戳 - 翎野 - 博客园</a></p>]]></content>
      
      
      <categories>
          
          <category> Java学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>138. 复制带随机指针的链表</title>
      <link href="/hexo_zh/2021/07/22/leetcode/138-fu-zhi-dai-sui-ji-zhi-zhen-de-lian-biao/"/>
      <url>/hexo_zh/2021/07/22/leetcode/138-fu-zhi-dai-sui-ji-zhi-zhen-de-lian-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><blockquote><p>给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。</p><p>构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。</p><p>例如，如果原链表中有 X 和 Y 两个节点，其中 <code>X.random→Y</code> 。那么在复制链表中对应的两个节点 x 和 y ，同样有 <code>x.random→y</code> 。</p><p>返回复制链表的头节点。</p><span id="more"></span><p>用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p><p><code>val</code>：一个表示 <code>Node.val</code>的整数。 random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。 你的代码 只 接受原链表的头节点 head 作为传入参数。</p><p>示例 1：</p><figure><img src="https://i.loli.net/2021/07/22/PuImxiYAStbcj3O.png" alt="138_example1" /><figcaption aria-hidden="true">138_example1</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">&gt;输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// Definition for a Node.</span></span><br><span class="line">&gt;<span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> val;</span><br><span class="line">   Node next;</span><br><span class="line">   Node random;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.val = val;</span><br><span class="line">          <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">this</span>.random = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="题解">题解</h2><p>看到这道题第一个反应就是这个链表不是一个普通的链表，本质上它可以转化为有向图，所以这道题本质可以说是图的深拷贝。下面这张图就是我们将这个链表转化为一张图之后的样子。</p><figure><img src="https://i.loli.net/2021/07/22/PBhuRnt3eiOqKAN.png" alt="138_diagram" /><figcaption aria-hidden="true">138_diagram</figcaption></figure><p>所以，由此我们可以采取类似BFS的思路对这个链表进行深拷贝。当遍历到一个节点的时候，我们可以对当前节点的下一个节点和随机节点分别进行拷贝。为了保证一个不会重复拷贝已经拷贝过的节点，我们可以使用哈希表对节点的拷贝情况进行记录。以下是代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Node,Node&gt; map = <span class="keyword">new</span> HashMap&lt;Node,Node&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(head)) &#123;</span><br><span class="line">            Node newHead = <span class="keyword">new</span> Node(head.val);</span><br><span class="line">            map.put(head, newHead);</span><br><span class="line">            newHead.next = copyRandomList(head.next);</span><br><span class="line">            newHead.random = copyRandomList(head.random);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一种思路是在评论区里看到的，感觉也非常的容易理解，也记录一下。思路非常清晰，首先遍历一遍链表，拷贝每个节点的值到新节点中，并且放入哈希表中记录，但是并拷贝节点的两个指针。然后第二次遍历，这个时候，我们新创建的每个指针的节点都储存在哈希表中了，我们就直接可以用<code>next</code>和<code>random</code>指针直接指向了。总体的思路就是，先创建单个节点，再将他们连接起来。下面是代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Map&lt;Node,Node&gt; map = <span class="keyword">new</span> HashMap&lt;Node,Node&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Node node = head; node != <span class="keyword">null</span>; node = node.next) &#123;</span><br><span class="line">            map.put(node, <span class="keyword">new</span> Node(node.val));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Node node = head; node != <span class="keyword">null</span>; node = node.next) &#123;</span><br><span class="line">            Node newNode = map.get(node);</span><br><span class="line">            newNode.next = map.get(node.next);</span><br><span class="line">            newNode.random = map.get(node.random);</span><br><span class="line">            map.put(node, newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附">附</h2><p>注意到第一种解法的代码中，我们首先将<code>newNode</code>加入到哈希表中，之后再改变它的两个指针，由此可以判断出我们加入哈希表中的Object实际上应该是一个引用，所以我们改变原本的值就会直接影响到哈希表中存储的值，写了以下代码进行验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">            Node next;</span><br><span class="line">            <span class="keyword">int</span> val;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.val = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Node node1 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        Node node2 = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        node1.next = node2;</span><br><span class="line">        node2.next = <span class="keyword">null</span>;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(node1.val);</span><br><span class="line">        map.put(node1, newNode);</span><br><span class="line">        newNode.val = <span class="number">4</span>;</span><br><span class="line">        newNode.next = node2;</span><br><span class="line">        System.out.println(map.get(node1).val);</span><br><span class="line">        System.out.println(map.get(node1).next.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 输出：</span></span><br><span class="line"><span class="comment">* 4</span></span><br><span class="line"><span class="comment">* 2</span></span><br><span class="line"><span class="comment">/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Java </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 52. 两个链表的第一个公共节点</title>
      <link href="/hexo_zh/2021/07/21/leetcode/jian-zhi-offer-52-liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian/"/>
      <url>/hexo_zh/2021/07/21/leetcode/jian-zhi-offer-52-liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>比较经典的简单题目，稍微记录一下思路</p><blockquote><p>输入两个链表，找出它们的第一个公共节点。</p><p>如下面的两个链表：</p><figure><img src="https://i.loli.net/2021/07/21/uiplfmB3PqCkht6.png" alt="160_statement" /><figcaption aria-hidden="true">160_statement</figcaption></figure><p>在节点 c1 开始相交。</p><span id="more"></span><p>示例 1：</p><figure><img src="https://i.loli.net/2021/07/21/PdIR6xC4V7Uhp3o.png" alt="160_example_1" /><figcaption aria-hidden="true">160_example_1</figcaption></figure><p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p><p>示例 2：</p><figure><img src="https://i.loli.net/2021/07/21/3ZU2Afnc5eNs9rk.png" alt="160_example_2" /><figcaption aria-hidden="true">160_example_2</figcaption></figure><p>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Reference of the node with value = 2 输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p><p>示例 3：</p><figure><img src="https://i.loli.net/2021/07/21/GTQD9AjXB2nJzyh.png" alt="160_example_3" /><figcaption aria-hidden="true">160_example_3</figcaption></figure><p>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 输出：null 输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。 解释：这两个链表不相交，因此返回 null。</p></blockquote><h2 id="题解">题解</h2><p>这道题采用双指针的思想就可以轻松解决。我们注意到，无论指针从哪个端点出发，遍历两个链表一共走的步数是一样的，并且他们去除他们的公共部分，也就是说如果两个指针分别从A和B的头出发的话，最后他们一定会同时到达第一个相交的公共节点。并且，如果说这两个链表没有公共节点，那么他们最后一定会同时到达两个链表的末尾，也就是<code>null</code>。思路出来了，代码也就很容易了，时间复杂度<strong>O(N)</strong>，空间复杂度<strong>O(1)</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode nodeA = headA, nodeB = headB;</span><br><span class="line">        <span class="keyword">if</span> (nodeA == <span class="keyword">null</span> || nodeB == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (nodeA != nodeB) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodeA == <span class="keyword">null</span>) nodeA = headB;</span><br><span class="line">            <span class="keyword">else</span> nodeA = nodeA.next;</span><br><span class="line">            <span class="keyword">if</span> (nodeB == <span class="keyword">null</span>) nodeB = headA;</span><br><span class="line">            <span class="keyword">else</span> nodeB = nodeB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodeA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Java </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NexT主题配置记录</title>
      <link href="/hexo_zh/2021/07/18/other/next/"/>
      <url>/hexo_zh/2021/07/18/other/next/</url>
      
        <content type="html"><![CDATA[<p>原来折腾了很久的Yilia主题，然而搞了半天终于还是来到了NexT的怀抱，NexT提供的功能相比于Yilia确实多了不少，这篇就作为一个记录，稍微记载下NexT中的一些配置吧。</p><hr /><p>2022.9.10 更新</p><p>以后打算就在这里记录一下对博客的更新情况</p><span id="more"></span><ul><li><p>2022.9.11 中英文切换功能，中英文板块分离;</p></li><li><p>2022.9.10 增加Portfolio页面; 添加DarkMode以及切换功能;</p></li><li><p>2021.7.18 切换主题为Next主题并进行配置;</p></li></ul><h2 id="hexo博客中英文板块以及切换">Hexo博客中英文板块以及切换</h2><p>由于一些原因准备给博客添加英文板块，主要想要实现的功能是中英文板块单独分离，用户在点击中英文切换的按钮后跳转到对应的页面。Next原本就支持双语切换，但是只有Menu等少部分元素的切换，并不是想要的效果。在网上找了很多相关的资料，最终决定还是使用最简单的办法：在github中创两个仓库，hexo_zh和hexo_en，分别作为中文博客和英文博客，并且在Menu上添加外链，点击可以进行跳转。</p><p>需要修改的地方主要有：</p><ol type="1"><li><p>en博客删除_post中不需要的中文博客</p></li><li><p>修改<code>_config.yml</code>的URL</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as &#x27;http://example.com/child&#x27; and root as &#x27;/child/&#x27;</span></span><br><span class="line"><span class="comment"># 这里是中英文对应的url，由于是subdirectory，所以需要按照以下写法</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://lucas-hao.github.io/hexo_en/</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/hexo_en/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br></pre></td></tr></table></figure></li><li><p>修改<code>_config.next.yml</code>（即主题配置文件，参见<a href="https://theme-next.js.org/docs/getting-started/configuration">Configuration | NexT (theme-next.js.org)</a>）的Menu，添加切换的外链。这里还有一些Bug没有解决，目前仍然存在的问题是点击切换按钮后只有内容板块切换到了中英文对应的post页面，但是其他包括左侧的边栏以及评论板块都没有刷新，也就是说因为en和zh在同一个root下，所以hexo默认为站内的切换而并非外链，有待寻找解决办法。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Usage: `Key: /link/ || icon`</span></span><br><span class="line"><span class="comment"># Key is the name of menu item. If the translation for this item is available, the translated text will be loaded, otherwise the Key name will be used. Key is case-senstive.</span></span><br><span class="line"><span class="comment"># Value before `||` delimiter is the target link, value after `||` delimiter is the name of Font Awesome icon.</span></span><br><span class="line"><span class="comment"># External url should start with http:// or https://</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">portfolio:</span> <span class="string">/portfolio/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="string">中文:</span> <span class="string">https://lucas-hao.github.io/hexo_zh/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-language</span></span><br><span class="line">  <span class="comment">#archives: /archives/ || fa fa-archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure></li><li><p>修改Deploy的git地址</p></li></ol><blockquote><p><strong>参考资料</strong></p><ul><li><a href="https://youngforest.github.io/2021/09/07/Setup-English-blog/">Hexo 创建中英文博客 | YoungForest's blog</a></li><li><a href="https://tstrs.me/1448.html?utm_source=blog_decay_fun">Hexo添加多语言支持「国际化i18n」 - SaltyLeo's Blog (tstrs.me)</a></li></ul></blockquote><h2 id="hexo站点内页面跳转的问题">Hexo站点内页面跳转的问题</h2><p>在Hexo站点内部文章页面跳转在hexo中可以使用<code>My portfolio: &#123;% poge_link "Post Name"&#125;</code>这种方式简便的实现，但是由于我想要实现的是两个Page之间的跳转，而不是一个post跳转到另一个post，这种方式就无法实现了。最傻的办法就是直接使用markdown传统的网址链接的方式，但是感觉有点不是太方便，具体的页面跳转的方式有待查证(TODO)</p><blockquote><p><strong>参考资料</strong></p><ul><li><a href="https://hexo.io/zh-cn/docs/tag-plugins.html#引用文章">标签插件（Tag Plugins） | Hexo</a></li></ul></blockquote><h2 id="添加可以切换模式的darkmode支持">添加可以切换模式的DarkMode支持</h2><p>目前Next主题已经支持DarkMode了，可以直接在<code>_config.yml</code>中进行配置，但是没有切换的功能，所以采用了<a href="https://github.com/rqh656418510/hexo-next-darkmode">hexo-dark-mode</a>插件来实现深色模式。可以使用自定义styl的方式分别设置浅色深色模式的背景，让背景图片和主题更搭一些。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: url(/images/body-light.jpg); <span class="comment">// 可以是路径也可以是链接</span></span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat; <span class="comment">// 不重复</span></span><br><span class="line">    <span class="attribute">background-attachment</span>:fixed; <span class="comment">// 固定住背景图片</span></span><br><span class="line">    <span class="attribute">background-position</span>:<span class="number">50%</span> <span class="number">50%</span>; <span class="comment">// 图片位置：居中</span></span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">100%</span> <span class="number">100%</span>; <span class="comment">// 图片长宽扩充为100%</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span><span class="selector-class">.darkmode--activated</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: url(<span class="string">&#x27;/images/body-dark.jpg&#x27;</span>)</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">background-attachment</span>: fixed;</span><br><span class="line">    <span class="attribute">background-position</span>: <span class="number">50%</span>, <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">100%</span>, <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/Darkmode.gif" /></p><blockquote><p><strong>参考资料</strong></p><ul><li><a href="https://www.techgrow.cn/posts/abf4aee1.html">Hexo Next 8.x 主题添加可切换的暗黑模式 | Clay 的技术博客 (techgrow.cn)</a></li></ul></blockquote><h2 id="使用mathjax对latex公式进行渲染">使用mathjax对<span class="math inline">\(\LaTeX\)</span>公式进行渲染</h2><p>我们在markdown中或多或少都会用到Latex来书写数学符号，NexT就为<span class="math inline">\(\LaTeX\)</span>提供了非常方便的渲染方式。我们只需要找到<code>/next/__config.yml</code>，然后找到如下配置并修改</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Available values: none | ams | all</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">none</span></span><br></pre></td></tr></table></figure><p>然而，由于hexo自带的<code>hexo-renderer-marked</code>会造成一些bug，所以我们使用pandoc会更加好一点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure><p>然后，进行部署就会发现渲染成功啦</p><p>更新2022.9.12</p><p>今天写的时候发现一个问题，<code>$$</code>符号没有隐藏，然后发现是因为似乎pandoc自动渲染了<code>\begin&#123;align&#125;</code>中的公式，所以外层的<code>$$</code>就被忽略了，所以去掉就好了，但是这样子就会有一个问题，就是在typora中是无法预览的，不是很方便，也许有机会研究一下如何解决吧 (TODO)</p><blockquote><p>参考资料</p><ul><li><a href="https://nokiasonic.github.io/2020/12/17/%5BHexo%5DNext主题更好地支持LaTeX数学公式/">【Hexo】Next主题更好地支持LaTeX数学公式</a></li></ul></blockquote><h2 id="next主题的目录层级问题">NexT主题的目录层级问题</h2><p>发现如果跨级使用目录的话，就会造成bug导致目录下的层级错乱，这就是由于我比较喜欢二级标题跟着四级标题，如果标题逐级递减就不会有这个问题了，把四级标题都改成三级标题就好了</p><p><img title="" src="https://i.loli.net/2021/07/23/rHYxJv5Rk96UNpd.png" alt="image-20210723224432413" width="387"></p><p>更新 (2022.10.6) 最近又出现了目录乱七八糟的问题，这次是二级标题+三级标题但是还是有问题，尝试了一下严格的使用一级标题二级标题，发现就好了，以后还是一级标题起手吧orz。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL生成RESTful神器PostgREST</title>
      <link href="/hexo_zh/2021/07/17/postgresql-sheng-cheng-restful-shen-qi-postgrest/"/>
      <url>/hexo_zh/2021/07/17/postgresql-sheng-cheng-restful-shen-qi-postgrest/</url>
      
        <content type="html"><![CDATA[<p>当我们想要对PostgreSQL进行客户端上的操作时，我们需要从远端对数据库进行访问。这个时候PostgreSQL的神器PostgREST就可以出马了。PostgREST是一个能够帮助我们生成一系列用于操作PostgreSQL数据库的RESTful API的服务器。之前我还尝试过直接使用Nginx中的ngx_postgres模块进行数据的操作，但是实际使用下来发现非常的麻烦，并且RESTful style要求每个网址代表一种资源，在网址中不能有动词，只能有名词，而且所用的名词一般和数据库名称相同。然而，我在Nginx的使用中还并没有找到一种可以适配这种样式的方法，关于ngx_postgres这个模块，可以看一看我的这篇博客<a href="https://lucas-hao.github.io/2021/07/06/nginx-yi-ji-ngx-postgres-an-zhuang-yi-ji-pei-zhi/#more">Nginx以及ngx_postgres安装以及配置 | Lucas的博客</a> 和这一篇<a href="https://lucas-hao.github.io/2021/07/08/shi-yong-java-tong-guo-nginx-fan-xiang-dai-li-fu-wu-qi-cao-zuo-postgresql-shu-ju-ku/">使用Java通过Nginx反向代理服务器操作PostgreSQL数据库 | Lucas的博客 )</a> 。</p><span id="more"></span><h2 id="postgrest的配置">PostgREST的配置</h2><p>PostgREST的下载安装也非常的方便，首先我们创建一个文件夹用来放置PostgREST的安装目录。这里我选择在<code>/opt</code>目录下创建文件夹<code>postgrest</code>，然后下载压缩包到<code>~/pacakges</code>，压缩包最新版本可以在<a href="https://github.com/PostgREST/postgrest/releases/tag/v7.0.1">Release v7.0.1 · PostgREST/postgrest (github.com)</a>里面找到，这里我下载的是7.0.1版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget https://github.com/PostgREST/postgrest/releases/download/v7.0.1/postgrest-v7.0.1-linux-x64-static.tar.xz</span><br></pre></td></tr></table></figure><p>将压缩包解压到postgrest中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/packages</span><br><span class="line">sudo tar -xvf postgrest-v7.0.1-linux-x64-static.tar.xz -C /opt/postgrest</span><br></pre></td></tr></table></figure><p>然后进入postgrest目录中，解压后只有一个可执行文件<code>postgrest</code>，执行解压后的可执行文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/postgrest</span><br><span class="line">./postgrest</span><br></pre></td></tr></table></figure><p>执行之后看到提示说明配置成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db-uri = <span class="string">&quot;postgres://user:pass@localhost:5432/dbname&quot;</span></span><br><span class="line">db-schema = <span class="string">&quot;public&quot;</span></span><br><span class="line">db-anon-role = <span class="string">&quot;postgres&quot;</span></span><br><span class="line">db-pool = 10</span><br></pre></td></tr></table></figure><p>接下来配置配置文件，新建文件<code>default.conf</code>，配置文件内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># postgrest.conf</span></span><br><span class="line"><span class="comment"># The standard connection URI format, documented at</span></span><br><span class="line"><span class="comment"># &lt;https://www.postgresql.org/docs/current/static/libpq-connect.html#AEN45347&gt;</span></span><br><span class="line">db-uri       = <span class="string">&quot;postgres://postgres:password@127.0.0.1:5432/dbname&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The name of which database schema to expose to REST clients</span></span><br><span class="line">db-schema    = <span class="string">&quot;public&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The database role to use when no client authentication is provided.</span></span><br><span class="line"><span class="comment"># Can (and probably should) differ from user in db-uri</span></span><br><span class="line">db-anon-role = <span class="string">&quot;postgres&quot;</span></span><br></pre></td></tr></table></figure><p>用设置好的配置文件启动postgrest</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/postgrest</span><br><span class="line">sudo ./postgrest default.conf</span><br></pre></td></tr></table></figure><p>启动之后，就会看到日志直接输出，可以通过Ctrl-C停止程序。我们可以通过调整将日志输出到日志文件，并且后台运行程序，日志文件应该保存在当前用户空间中，否则会出现权限问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nohup postgrest default.conf&gt;~/postgrest.log &amp;</span><br></pre></td></tr></table></figure><p>启动之后，我们就可以通过PostgREST进行Query或者Insertion了。</p><p>如果想要停止PostgREST，需要先找到它的进程，然后kill就好了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -A | grep postgrest  # 查看进程</span><br><span class="line">sudo lsof -i:3000# 查看端口，也会显示进程PID</span><br><span class="line">kill PID# 杀死进程</span><br></pre></td></tr></table></figure><h2 id="postgrest和nignx联合使用">PostgREST和Nignx联合使用</h2><p>虽然PostgREST能够为我们提供强大的RESTful API帮助，但是它并未提供一些安全上的保障和措施。所以，在实际应用中，我们可以搭配强大的Nginx，用Nginx反向代理PostgREST。我们在Nginx的配置文件中加入如下配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">upstream postgrest &#123;</span><br><span class="line">server localhost:3000;</span><br><span class="line">    keepalive 64;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">location /api/ &#123;</span><br><span class="line">        default_type  application/json;</span><br><span class="line">        proxy_hide_header Content-Location;</span><br><span class="line">        add_header Content-Location  /api/<span class="variable">$upstream_http_content_location</span>;</span><br><span class="line">        proxy_set_header  Connection <span class="string">&quot;&quot;</span>;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_pass http://postgrest/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以直接通过<code>http://hostname/api/</code>来对数据库进行操作</p><p>参考资料：<a href="https://www.cnblogs.com/cunchen/p/9464115.html">【PostgREST 基本教程（一）】 PostgREST快速搭建 )</a></p><p>使用教程：<a href="https://postgrest.org/en/stable/">官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo下yilia主题博客个性化自定义</title>
      <link href="/hexo_zh/2021/07/16/other/hexo-bi-ji/"/>
      <url>/hexo_zh/2021/07/16/other/hexo-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>我的博客采用的hexo下的yilia主题，这篇文章记录一下自己折腾配置博客的方法和经过。 首先是创建博客的基本的几个命令 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo g # 生成博客网页文件</span><br><span class="line">hexo s # 本地预览博客，打开本地网址http://localhost:4000/进行预览</span><br><span class="line">hexo d # 上传网页文件到github</span><br><span class="line">hexo new post &quot;Article Title&quot; # 新建一篇博客</span><br><span class="line">hexo cl &amp;&amp; hexo g &amp;&amp;　hexo s # 一步实现清除重构本地预览</span><br></pre></td></tr></table></figure> <span id="more"></span></p><h2 id="yilia主题下的截断功能及优化">yilia主题下的截断功能及优化</h2><p>一篇文章太长，不需要将其全部显示出来，在yilia主题下，我们只需要在我们的markdown文件中需要截断的地方插入<code>&lt;!-- more --&gt;</code>就可以实现阶段了。</p><p>但是这个时候发现，在截断的地方会有一个<code>more&gt;&gt;</code>的标志出现，与展开全文重复了</p><figure><img src="https://i.loli.net/2021/04/06/XcU5V76DT3HniFN.png" alt="image-20210406213135567" /><figcaption aria-hidden="true">image-20210406213135567</figcaption></figure><p>为了去除这个<code>more&gt;&gt;</code>，在<code>themes/_config.yml</code>，修改excerpt_link参数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">excerpt_link：之后的more单词换成空格</span><br><span class="line">注：‘excerpt_link： ’。其中：后有一个空格键</span><br></pre></td></tr></table></figure><h2 id="优先级配置">优先级配置</h2><p>修改根目录配置文件<code>/_config.yml</code>,top值-1标示根据top值倒序（正序设置为1即可），同样<code>date</code>也是根据创建日期倒序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">index_generator:</span><br><span class="line">  path: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">per_page</span>: <span class="number">10</span></span><br><span class="line">  <span class="attr">order_by</span>:</span><br><span class="line">    top: -<span class="number">1</span></span><br><span class="line">    <span class="attr">date</span>: -<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="在左边栏显示总文章数">在左边栏显示总文章数</h2><p>将<code>themes\yilia\layout_partial\left-col.ejs</code>文件的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;nav <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;header-menu&quot;</span>&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &lt;% for (var i in theme.menu)&#123; %&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%- url_for(theme.menu[i]) %&gt;&quot;</span>&gt;</span>&lt;%= i %&gt;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &lt;%&#125;%&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">&lt;/nav&gt;</span><br></pre></td></tr></table></figure><p>后面加上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;nav&gt;</span><br><span class="line">    总文章数 &lt;%=site.posts.length%&gt;</span><br><span class="line">&lt;/nav&gt;</span><br></pre></td></tr></table></figure><h2 id="添加网站流量计数功能">添加网站流量计数功能</h2><ul><li><p>在<code>_config.yml</code>中添加 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">busuanzi:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p></li><li><p>将themes/yilia/layout/_partial/footer.ejs替换为一下代码 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;footer id=<span class="string">&quot;footer&quot;</span>&gt;</span><br><span class="line"> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer-info&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer-left&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">       <span class="symbol">&amp;copy;</span> &lt;%= date(new Date(), &#x27;YYYY&#x27;) %&gt; &lt;%= config.author || config.title %&gt;</span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer-right&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">         <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://hexo.io/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>Hexo<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  Theme <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://github.com/litten/hexo-theme-yilia&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>Yilia<span class="tag">&lt;/<span class="name">a</span>&gt;</span> by Litten</span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">calss</span>=<span class="string">&quot;count-span&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_site_pv&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">         总访问量: <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_site_pv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p></li><li><p>打开<code>\themes\yilia\layout\_partial\article.ejs</code>，在<code>&lt;header class="article-header"&gt;</code>里加入以下代码: <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 添加代码 访问统计 --&gt;</span><br><span class="line">&lt;% <span class="keyword">if</span> ( !index )&#123; %&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;archive-article-date&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        阅读量 <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_page_pv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></p></li></ul><figure><img src="https://i.loli.net/2021/04/06/tPHydr4apl3oUDx.png" alt="image-20210406210243081" /><figcaption aria-hidden="true">image-20210406210243081</figcaption></figure><p>参考资源: <a href="https://blog.csdn.net/weixin_43864927/article/details/106970576">Hexo个人博客之yilia主题阅读量和文章字数统计</a></p><h2 id="添加字数统计和阅读时长功能">添加字数统计和阅读时长功能</h2><ul><li><p><strong>安装hexo-wordcount</strong></p><p>在终端中博客目录下输入命令(安装wordcount插件) <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i –save hexo-wordcount</span><br></pre></td></tr></table></figure></p></li><li><p><strong>配置修改</strong></p><p>在theme_partial.ejs文件：</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=<span class="string">&quot;margin-top:10px;&quot;</span>&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-time&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-keyboard-o&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-text&quot;</span>&gt;</span>  字数统计: <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-count&quot;</span>&gt;</span>&lt;%= wordcount(post.content) %&gt;字<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-time&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="symbol">&amp;nbsp;</span> | <span class="symbol">&amp;nbsp;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-hourglass-half&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-text&quot;</span>&gt;</span>  阅读时长: <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-count&quot;</span>&gt;</span>&lt;%= min2read(post.content) %&gt;分<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>在<code>\themes\yilia\layout\_partial\article.ejs</code>中添加</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 需要添加的位置 --&gt;</span><br><span class="line">&lt;!-- 开始添加字数统计--&gt;</span><br><span class="line">&lt;% <span class="keyword">if</span>(theme.word_count &amp;&amp; !post.no_word_count)&#123;%&gt;</span><br><span class="line">    &lt;%- partial(<span class="string">&#x27;post/word&#x27;</span>) %&gt;</span><br><span class="line">        &lt;% &#125; %&gt;</span><br><span class="line">            &lt;!-- 添加完成 --&gt;</span><br></pre></td></tr></table></figure></p><figure><img src="https://i.loli.net/2021/04/06/BIudtvj9NOxirUS.png" alt="image-20210406210706379" /><figcaption aria-hidden="true">image-20210406210706379</figcaption></figure></li></ul><p>参考资源: <a href="https://blog.csdn.net/weixin_43864927/article/details/106970576">Hexo个人博客之yilia主题阅读量和文章字数统计</a></p><h2 id="live-2d看板娘">Live 2D看板娘</h2><p>在博客的根目录运行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure><p>安装想要的live2d动画人物模型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install live2d-widget-model-haru</span><br></pre></td></tr></table></figure><p>live2d-widget-model-haru这个是一个动画的样式model，你可以在网上搜到很多。</p><p>安装成功后，你可以在你的<code>博客根文件夹/node_modules/</code>底下找到<code>live2d-widget-model-haru</code>这个文件夹。模型可以在<a href="https://github.com/xiazeyu/live2d-widget-models">live2d-widget-models</a>中找到。</p><p>修改根目录下的配置文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">7.</span>live2d配置宠物</span><br><span class="line">live2d:</span><br><span class="line">  # 当enable 为<span class="literal">true</span>的时候，会启用yaliya主题自带宠物shizuku,橘头发小姐姐，而且不可以配置位置，所以需要讲enable注释掉</span><br><span class="line">  # enable: <span class="literal">true</span></span><br><span class="line">  scriptFrom: local</span><br><span class="line">  pluginRootPath: live2dw/</span><br><span class="line">  pluginJsPath: lib/</span><br><span class="line">  pluginModelPath: assets/</span><br><span class="line">  model:</span><br><span class="line">  # 我用的是初音的模型(老二次元了)</span><br><span class="line">  use: live2d-widget-model-miku</span><br><span class="line">    # live2d-widget-model-wanko 是一只趴在碗里的狗狗</span><br><span class="line">    # use: live2d-widget-model-wanko # 通过修改use来确定使用哪种model</span><br><span class="line">    # hibiki 是一个御姐</span><br><span class="line">    # use: live2d-widget-model-hibiki</span><br><span class="line">    # haruto 海军服女孩，有点难看</span><br><span class="line">    # use: live2d-widget-model-haruto</span><br><span class="line">  display:</span><br><span class="line">    position: left</span><br><span class="line">    width: <span class="number">150</span></span><br><span class="line">    height: <span class="number">300</span></span><br><span class="line">    # 一个比较可爱的位置</span><br><span class="line">    # hOffset: <span class="number">200</span> </span><br><span class="line">    # vOffset: <span class="number">-100</span></span><br><span class="line">    # 第二个位置配置，这个在左侧边栏位置很居中</span><br><span class="line">    hOffset: <span class="number">80</span>  # 调节水平位置</span><br><span class="line">    vOffset: <span class="number">-50</span>  # 调节垂直位置</span><br><span class="line">  mobile:</span><br><span class="line">    show: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>参考资料:</p><p><a href="https://www.jianshu.com/p/5b5c61323772">hexo-添加Live2d看板动画 （添加宠物）- yaliya 主题 一个小坑</a></p><p><a href="https://wu_aquarius.gitee.io/live2d/">Hexo 博客添加看板娘</a></p><h2 id="yilia替换背景">yilia替换背景</h2><p>首先，左侧栏替换背景</p><p>找到<code>themes/yilia/layout/_partial/left-col.ejs</code>，将</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;overlay&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background: &lt;%= theme.style &amp;&amp; theme.style.header ? theme.style.header : defaultBg %&gt;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> --&gt;</span><br></pre></td></tr></table></figure><p>注释掉，然后在<code>themes\yilia\source\main.0cf68a.css</code>中修改样式，注释掉原有的背景颜色</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left-col</span> &#123;</span><br><span class="line">    <span class="comment">/* background:#fff; */</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.5</span>), <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.5</span>)), <span class="built_in">url</span>(<span class="string">&#x27;image-url&#x27;</span>) no-repeat <span class="number">0%</span> <span class="number">20%</span>/ cover;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">transition</span>: all .<span class="number">2s</span> ease-in;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">999</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">overflow-y</span>: auto;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">15px</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，右侧主题区域替换背景。这里调整的是右侧显示文章的区域。在这里如果将代码作一下变化，那么右侧文章区域就会呈现半透明的状态。我为了简洁，还是选择这块区域呈现出不透明的状态。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.article</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#fff</span>;</span><br><span class="line">    <span class="comment">/* background: #fff; */</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,.<span class="number">5</span>);</span><br><span class="line">    <span class="attribute">transition</span>: all .<span class="number">2s</span> ease-in</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来有两个地方需要注意，一个是<code>.mid-col</code>中的背景和<code>body</code>中的背景</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.mid-col</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="comment">/* background: #eaeaea; */</span></span><br><span class="line">    <span class="attribute">left</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">width</span>: auto</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line"></span><br><span class="line">  *<span class="attribute">overflow-y</span>*: hidden;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* background: #eaeaea */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两处都需要把背景注释掉，否则会遮挡背景图片导致图片无法显示。</p><p>然后在<code>body</code>中设置背景图片（和上面的body不是一个body，可以使用vscode中的搜索功能搜索）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: Helvetica Neue, Helvetica, STHeiTi, Arial, sans-serif;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="comment">/* background-color: #fff; */</span></span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.5</span>), <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.5</span>)), </span><br><span class="line">    <span class="built_in">url</span>(<span class="string">&#x27;image-url&#x27;</span>) no-repeat <span class="number">0%</span> <span class="number">0%</span>/ cover;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前左侧栏的背景成功更改了，但是右侧区域的背景还是没有成功更改。</p><p>参考资料:</p><p><a href="https://blog.csdn.net/weixin_41287260/article/details/103050813?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control">hexo+yilia添加背景图片</a></p><p><a href="https://blog.csdn.net/weixin_44330881/article/details/103293892?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control">hexo之yilia主题添加背景图片</a></p><h2 id="修改翻页不能正确显示的bug">修改翻页不能正确显示的bug</h2><p>默认的Yilia主题下的翻页会有bug，在主页下的上下翻页会有如下的bug，HTML的特殊符号无法正确显示。</p><figure><img src="https://i.loli.net/2021/07/16/RNO63KuTbWn8tPH.png" alt="image-20210716214619724" /><figcaption aria-hidden="true">image-20210716214619724</figcaption></figure><p>强迫症看着非常难受，索性直接改成中文上一页和下一页，找到<code>yilia/layout/_partial/archive.ejs</code>分别修改<strong>第8,9行</strong>和<strong>第37,38行</strong>，如下图：</p><figure><img src="https://i.loli.net/2021/07/16/BH5FIjKzf7eQCDp.png" alt="image-20210716215012720" /><figcaption aria-hidden="true">image-20210716215012720</figcaption></figure><p>修改完之后，再找到文件<code>yilia/layout/_partial/script.ejs</code>，搜索<code>&amp;laquo; Prev</code>和<code>Next &amp;raquo;</code>并且删除，然后本来的Prev和Next就变成了“上一页”和”下一页“。参考<a href="https://blog.csdn.net/CYK5201995/article/details/107769487">软件 | hexo博客主题yilia上一页下一页显示的问题_RyanCYK的计算机世界-CSDN博客</a></p><h2 id="gitalk-评论">Gitalk 评论</h2><p>在<a href="https://github.com/settings/applications/new">New OAuth Application (github.com)</a>中进行注册，如下图：</p><figure><img src="https://i.loli.net/2021/07/17/9qHwNdr5CxtZ3Sz.png" alt="image-20210717000639493" /><figcaption aria-hidden="true">image-20210717000639493</figcaption></figure><p>注册好之后，就可以得到Client ID和Client Secret，然后我们需要创建一件仓库用来承接gitalk的评论。</p><p>在主题下的<code>_config.yml</code>中找到gitalk配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">    <span class="attr">githubID:</span> <span class="comment"># 填你的 github 用户名</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">xxx.github.io</span> <span class="comment"># 承载评论的仓库，一般使用 Github Page 仓库</span></span><br><span class="line">    <span class="attr">ClientID:</span> <span class="comment"># 第1步获得 Client ID</span></span><br><span class="line">    <span class="attr">ClientSecret:</span> <span class="comment"># 第1步获得 Client Secret</span></span><br><span class="line">    <span class="attr">adminUser:</span> <span class="comment"># Github 用户名</span></span><br><span class="line">    <span class="attr">distractionFreeMode:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line">    <span class="attr">perPage:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>然后重新部署博客页面就可以看到评论区出现了</p><p>参考资料：<a href="https://yelog.org/2020/05/23/3-hexo-comment/">3-hexo评论设置 | 叶落阁 (yelog.org)</a> 这个博主的yilia还蛮全面的</p><p>在使用的时候发现了以下异常，Gitalk出现Error:Validation Failed问题，经过查询发现这是由于Gitalk的id有长度限制，而在yilia中默认是将通过url设置为id，所以很容易长度超过50，解决办法：我们可以把id设置为文章标题，这样子就不容易超过50了。修改<code>yilia/layout/_partial/post/gitment.ejs</code>，第6行修改为<code>id: "&lt;%=post.title%&gt;"</code>，问题解决。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Java通过Nginx反向代理服务器操作PostgreSQL数据库</title>
      <link href="/hexo_zh/2021/07/08/javanote/shi-yong-java-tong-guo-nginx-fan-xiang-dai-li-fu-wu-qi-cao-zuo-postgresql-shu-ju-ku/"/>
      <url>/hexo_zh/2021/07/08/javanote/shi-yong-java-tong-guo-nginx-fan-xiang-dai-li-fu-wu-qi-cao-zuo-postgresql-shu-ju-ku/</url>
      
        <content type="html"><![CDATA[<p>最近在做一个项目，需要讲Android App和服务器上的PostgreSQL进行连接，但是Android Studio不能够直接通过JDBC进行连接，所以选择通过Nginx作为中间服务器对PostgreSQL进行操作，这篇文章紧接<a href="https://lucas-hao.github.io/2021/07/06/nginx-yi-ji-ngx-postgres-an-zhuang-yi-ji-pei-zhi/#more">Nginx以及ngx_postgres安装以及配置</a>。</p><p><strong>更新：后来发现使用nginx的效果并不好，更好的方法可能是使用PostgREST+Nginx反向代理对数据库进行操作，因为PostgREST直接提供了处理PostgreSQL数据库的RESTful接口，更加方便。详细教程可以去网上搜一搜。</strong></p><span id="more"></span><p>我们的数据库中的数据主要存储的是Android app中的使用信息，定义app_usage_info表拥有以下字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">day</span> <span class="type">date</span>,</span><br><span class="line">app_name text,</span><br><span class="line">package_name text,</span><br><span class="line">app_usage_time <span class="type">interval</span>,</span><br><span class="line">app_usage_count <span class="type">integer</span></span><br></pre></td></tr></table></figure><p>首先，我们需要对nginx的配置文件进行配置，nginx的配置文件一般是在nginx的安装目录下的/conf/nginx.conf，比如在我的系统中就是/opt/nginx/conf/nginx.conf，打开配置文件我们就可以进行配置。Nginx的配置文件结构可以在<a href="https://www.runoob.com/w3cnote/nginx-setup-intro.html">Nginx 配置详解 | 菜鸟教程 (runoob.com)</a>中简单学习一下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">worker_processes 1;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">        include         mime.types;</span><br><span class="line">        default_type    application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">        keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    upstream database &#123;</span><br><span class="line">        postgres_server 172.29.118.77 dbname=postgres user=postgres password=511668;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line"></span><br><span class="line">        charset utf-8;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name localhost;</span><br><span class="line"></span><br><span class="line">        location /insert &#123;</span><br><span class="line">            postgres_pass database;</span><br><span class="line">            rds_json on;</span><br><span class="line">            postgres_query &quot;insert into app_usage_info VALUES (&#x27;$arg_day&#x27;, &#x27;$arg_app_name&#x27;, &#x27;$arg_package_name&#x27;, &#x27;$arg_time&#x27;, &#x27;$arg_count&#x27;);</span><br><span class="line">            postgres_rewrite no_changes 410;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location /query-all &#123;</span><br><span class="line">            postgres_pass database;</span><br><span class="line">            rds_json on;</span><br><span class="line">            postgres_query &quot;select * from app_usage_info&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location /query-day &#123;</span><br><span class="line">            postgres_pass database;</span><br><span class="line">            rds_json on;</span><br><span class="line"></span><br><span class="line">            postgres_query      HEAD GET &quot;SELECT * FROM app_usage_info WHERE day=&#x27;$arg_day&#x27;&quot;;</span><br><span class="line">            postgres_rewrite    HEAD GET no_rows 410;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">               root   html;</span><br><span class="line">               index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">       # 错误页面 </span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">                root    html;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这是我的一个简单的配置，为了对数据库做不同的处理，我定义了insert页面，query-day（查询指定天数）页面，query-all（查询整个表）页面。这里面还涉及到关于Nginx中变量的使用，可以看这一篇<a href="https://www.jianshu.com/p/44680c081ea0">Nginx变量使用方法详解 - 简书 (jianshu.com)</a>，讲得还是非常的清楚的。这里我使用了<code>$arg_XXX</code>变量，就可以直接通过http网址进行参数的设定了，也就很方便的可以通过JAVA的Http请求执行对应的数据库操作。</p><p>下面是用来实现Http请求的Java类，参考这篇文章实现<a href="https://www.jb51.net/article/206762.htm#:~:text=JAVA发送HTTP请求的四种方式总结%201%20HttpURLConnection%202,URLConnection%203%20HttpClient%204%20Socket">JAVA发送HTTP请求的四种方式总结_java_脚本之家 (jb51.net)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String uri;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpUtils</span><span class="params">(String hostname)</span> </span>&#123;</span><br><span class="line">        uri = hostname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendRequest</span><span class="params">(String url, Callback callback)</span> </span>&#123;</span><br><span class="line">        OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">        Request request = <span class="keyword">new</span> Request.Builder().url(url).build();</span><br><span class="line">        client.newCall(request).enqueue(callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sendRequestWithHttpURL</span><span class="params">(String urlParam,String requestType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        HttpURLConnection con = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        BufferedReader buffer = <span class="keyword">null</span>;</span><br><span class="line">        StringBuffer resultBuffer = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(urlParam);</span><br><span class="line">            <span class="comment">//得到连接对象</span></span><br><span class="line">            con = (HttpURLConnection) url.openConnection();</span><br><span class="line">            <span class="comment">//设置请求类型</span></span><br><span class="line">            con.setRequestMethod(requestType);</span><br><span class="line">            <span class="comment">//设置请求需要返回的数据类型和字符集类型</span></span><br><span class="line">            con.setRequestProperty(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">            <span class="comment">//允许写出</span></span><br><span class="line">            con.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//允许读入</span></span><br><span class="line">            con.setDoInput(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//不使用缓存</span></span><br><span class="line">            con.setUseCaches(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//得到响应码</span></span><br><span class="line">            <span class="keyword">int</span> responseCode = con.getResponseCode();</span><br><span class="line">            System.out.println(urlParam + <span class="string">&quot;: &quot;</span> + responseCode);</span><br><span class="line">            <span class="keyword">if</span>(responseCode == HttpURLConnection.HTTP_OK)&#123;</span><br><span class="line">                <span class="comment">//得到响应流</span></span><br><span class="line">                InputStream inputStream = con.getInputStream();</span><br><span class="line">                <span class="comment">//将响应流转换成字符串</span></span><br><span class="line">                resultBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                String line;</span><br><span class="line">                buffer = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">                <span class="keyword">while</span> ((line = buffer.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    resultBuffer.append(line);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> resultBuffer.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ProtocolException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Failed!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String day, String app_name, String package_name, String interval, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        String responseData = sendRequestWithHttpURL(uri+<span class="string">&quot;/insert?&quot;</span>+<span class="string">&quot;day=&quot;</span>+day+<span class="string">&quot;&amp;app_name=&quot;</span>+app_name+<span class="string">&quot;&amp;package_name=&quot;</span>+package_name+<span class="string">&quot;&amp;time=&quot;</span>+interval+<span class="string">&quot;&amp;count=&quot;</span>+count, <span class="string">&quot;POST&quot;</span>);</span><br><span class="line">        System.out.println(responseData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String responseData = sendRequestWithHttpURL(uri+<span class="string">&quot;/query-all&quot;</span>, <span class="string">&quot;GET&quot;</span>);</span><br><span class="line">        System.out.println(responseData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryDay</span><span class="params">(String day)</span> </span>&#123;</span><br><span class="line">        String responseData = sendRequestWithHttpURL(uri+<span class="string">&quot;/query-day?day=&quot;</span>+day, <span class="string">&quot;GET&quot;</span>);</span><br><span class="line">        System.out.println(responseData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数所在类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String url =<span class="string">&quot;your host address&quot;</span>;</span><br><span class="line">        HttpUtils http = <span class="keyword">new</span> HttpUtils(url);</span><br><span class="line">        http.queryAll();</span><br><span class="line">        http.queryDay(<span class="string">&quot;2021-07-07&quot;</span>);</span><br><span class="line">        http.insert(<span class="string">&quot;2021-07-08&quot;</span>, <span class="string">&quot;华为桌面&quot;</span>, <span class="string">&quot;com.huawei.android.launcher&quot;</span>,</span><br><span class="line">                <span class="string">&quot;00:18:41&quot;</span>, <span class="number">63</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果</p><figure><img src="https://i.loli.net/2021/07/16/DJsO18TfyU29MSz.png" alt="image-20210708152524585" /><figcaption aria-hidden="true">image-20210708152524585</figcaption></figure><h4 id="参考资料">参考资料</h4><p>[1] <a href="https://www.runoob.com/w3cnote/nginx-setup-intro.html">Nginx 配置详解 | 菜鸟教程 (runoob.com)</a></p><p>[2] <a href="https://www.jianshu.com/p/44680c081ea0">Nginx变量使用方法详解 - 简书 (jianshu.com)</a></p><p>[3] <a href="https://www.jb51.net/article/206762.htm#:~:text=JAVA发送HTTP请求的四种方式总结%201%20HttpURLConnection%202,URLConnection%203%20HttpClient%204%20Socket">JAVA发送HTTP请求的四种方式总结_java_脚本之家 (jb51.net)</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
            <tag> Nginx </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx以及ngx_postgres安装以及配置</title>
      <link href="/hexo_zh/2021/07/06/nginx-yi-ji-ngx-postgres-an-zhuang-yi-ji-pei-zhi/"/>
      <url>/hexo_zh/2021/07/06/nginx-yi-ji-ngx-postgres-an-zhuang-yi-ji-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p>最近在做一个项目，需要讲Android App和服务器上的PostgreSQL进行连接，但是Android Studio不能够直接通过JDBC进行连接，所以选择通过Nginx作为中间服务器对PostgreSQL进行操作。以下简单记录一下安装nginx和配置ngx_postgres的过程 <span id="more"></span></p><p>首先，由于我们在手动安装的过程中需要对nginx的源码进行编译，所以首先系统中必须具有C/C++的编译器，如果没有，手动安装一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc <span class="comment"># 安装C语言编译器gcc</span></span><br><span class="line">sudo apt-get install g++ <span class="comment"># 安装C++编译器g++</span></span><br></pre></td></tr></table></figure><p>接下来依次安装我们需要的包，这里我全部安装到<code>~/packages</code>路径下。对于压缩包使用<code>wget address</code>命令下载，使用<code>tar -zxvf filename.tar.gz</code>进行解压；对于github上的仓库，使用<code>git clone github_address</code>克隆到本地。</p><ul><li><p>nginx http://nginx.org/download/nginx-1.20.1.tar.gz</p><p>在官网http://nginx.org/download/找到对应的压缩包，然后下载解压</p></li><li><p>ngx_postgres https://github.com/FRiCKLE/ngx_postgres.git</p></li><li><p>ngx_postgres还需要下载安装libpq，否则就会在编译的时候出现错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure: error: ngx_postgres addon was unable to find the libpq library.</span><br></pre></td></tr></table></figure><p>使用<code>sudo apt-get install libpq-dev</code>进行安装</p></li><li><p>ngx_devel_kit https://github.com/vision5/ngx_devel_kit.git</p></li><li><p>rds-json-nginx-module https://github.com/openresty/rds-json-nginx-module.git</p></li><li><p>form-input-nginx-module https://github.com/nginx-modules/form-input-nginx-module.git</p></li></ul><p>还有几个nginx本身需要依赖的包，即使不使用ngx_postgres也是需要下载安装的</p><ul><li><p>pcre: https://jaist.dl.sourceforge.net/project/pcre/pcre/8.45/pcre-8.45.tar.gz</p><p>在这个网站可以找到对应的压缩包 http://sourceforge.net/projects/pcre/files/pcre/</p></li><li><p>zlib: https://jaist.dl.sourceforge.net/project/libpng/zlib/1.2.11/zlib-1.2.11.tar.gz</p><p>官网 https://www.zlib.net/</p><figure><img src="https://i.loli.net/2021/07/16/zT3L16CWE8FmY9v.png" alt="zlib" /><figcaption aria-hidden="true">zlib</figcaption></figure></li><li><p>openssl Github 地址: https://github.com/openssl/openssl.git</p></li></ul><p>全部下载完成之后应该有以下文件夹</p><figure><img src="https://i.loli.net/2021/07/16/H9VpaqmzQldSgnR.png" alt="packages" /><figcaption aria-hidden="true">packages</figcaption></figure><p>然后进入nginx-1.20.1目录下，这个目录下有一个configure可执行文件，在命令行中输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/opt/nginx \\</span><br><span class="line">--with-pcre=/home/ubuntu/packages/pcre-8.45 \\ </span><br><span class="line">--with-zlib=/home/ubuntu/packages/zlib-1.2.11 \\ </span><br><span class="line">--with-openssl=/home/ubuntu/packages/openssl \\ </span><br><span class="line">--add-module=/home/ubuntu/packages/ngx_postgres \\</span><br><span class="line">--add-module=/home/ubuntu/packages/rds-json-nginx-module \\ </span><br><span class="line">--add-module=/home/ubuntu/packages/ngx_devel_kit \\</span><br><span class="line">--add-module=/home/ubuntu/packages/form-input-nginx-module</span><br></pre></td></tr></table></figure><p><code>--prefix=/opt/nginx</code>代表我把nginx安装在这个目录下，下面几行是所添加的module和包，填上自己的文件路径就可以了。然后运行命令<code>make</code>，如果没有下载make的话使用<code>apt-get</code> 安装以下就好了。执行了<code>make</code>之后，出现了以下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/home/ubuntu/packages/ngx_postgres/src/ngx_postgres_module.c:1323:21: error: ‘ngx_http_upstream_srv_conf_t’ &#123;aka ‘struct ngx_http_upstream_srv_conf_s’&#125; has no member named ‘default_port’</span><br><span class="line"> 1323 |         <span class="keyword">if</span> (uscfp[i]-&gt;default_port &amp;&amp; url-&gt;default_port</span><br><span class="line">      |                     ^~</span><br><span class="line">/home/ubuntu/packages/ngx_postgres/src/ngx_postgres_module.c:1324:25: error: ‘ngx_http_upstream_srv_conf_t’ &#123;aka ‘struct ngx_http_upstream_srv_conf_s’&#125; has no member named ‘default_port’</span><br><span class="line"> 1324 |             &amp;&amp; (uscfp[i]-&gt;default_port != url-&gt;default_port))</span><br></pre></td></tr></table></figure><p>到nginx的<code>src/http/ngx_http_upstream.h</code>文件找到<code>ngx_http_upstream_srv_conf_s</code>结构添加<code>in_port_t default_port;</code></p><p><img src="https://i.loli.net/2021/07/16/OjwVoBn2Xzg7ypc.png" /></p><p>然后执行命令<code>make</code>，没有问题之后执行<code>make install</code>就可以成功安装了。</p><p>安装成功，我们就可以在我们的安装路径下<code>/opt/nginx</code>找到对应的安装目录，nginx可执行文件就是/opt/nginx/sbin/nginx这个路径。</p><p>使用以下命令启动nginx服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /opt/nginx/sbin/nginx -c /opt/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><p>最后我们可以创建软链接，这样就可以不用自己手动配置了，只需要输入sudo nginx就可以启动了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /opt/nginx/sbin/nginx /usr/bin/nginx</span><br></pre></td></tr></table></figure><p>使用<code>sudo nginx</code>开始 nginx，<code>nginx -s stop</code>停止nginx。打开nginx之后，就可以在我们的服务器域名下看到如下的页面</p><p><img src="https://i.loli.net/2021/07/16/ibrBwHGD3h9aIAO.png" /></p><h4 id="参考资料">参考资料</h4><p>[1] 知乎，<em>nginx安装及其配置详细教程</em>，https://zhuanlan.zhihu.com/p/83890573</p><p>[2] CSDN，<em>ubuntu 手动安装nginx</em>，https://blog.csdn.net/xiaoyou625/article/details/112006193</p><p>[3] HostAdvice, <em>How to Install PostgreSQL on an Ubuntu VPS Running Nginx</em>, https://hostadvice.com/how-to/how-to-install-postgresql-on-nginx-web-servers/</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实现一个简单的计算器</title>
      <link href="/hexo_zh/2021/07/01/javanote/java-jian-dan-de-ji-suan-qi/"/>
      <url>/hexo_zh/2021/07/01/javanote/java-jian-dan-de-ji-suan-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="java实现一个简单的计算器">Java实现一个简单的计算器</h1><p>在LeetCode上有几道题目实现简单的计算器，最近刚刚在Algorithms (4th edition)上学习了利用栈实现简单的计算器，使用的是 E.W.Dijkstra在1960s提出的栈算法实现的。利用栈后进先出的特性，可以实现对括号以及优先级的处理。第一次尝试这种算法，写出来的代码效率也不是很高。</p><span id="more"></span><h3 id="基本想法">基本想法</h3><p>首先，初始化两个栈，一个用来存储运算符（包括括号和各种运算符)。<code>Stack&lt;String&gt; ops = new Stack&lt;String&gt;();</code> <code>Stack&lt;Integer&gt; vals = new Stack&lt;Integer&gt;();</code>第一个程序实现的是只包括加减的，因此没有运算优先顺序，只需要考虑括号，空格等字符。基本想法是：向standard input内输入一个字符串表达式，然后对数字和符号进行各自对应的处理。遇到一个数字，push进<code>vals</code>栈，遇到一个运算符，先判断在<code>ops</code>中的上一个字符是否可以进行运算（之所以这样子做是因为这样子也可以方便判断优先级），若可以进行运算，那么就将<code>ops</code>中的一个符号和<code>vals</code>的数pop出来进行对应的运算，然后将当前的运算符push进<code>ops</code>，否则，直接将当前符号push进<code>ops</code>。如果遇到右括号，直接对栈中的元素进行运算直到遇到左括号。</p><h3 id="对于字符串转整型的处理">对于字符串转整型的处理</h3><p>首先，我们可以设置一个<code>int flag = 0</code>，若读取的当前字符为数字，那么就将<code>flag</code>的值设为1，并且将这个数字转化为<code>int</code>入栈。若当前的字符不为数字，记得一定要将<code>flag</code>的值重新设为0。代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">    String currentString = s.subString(i,i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(currentChar.charAt(<span class="number">0</span>) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; currentChar.charAt(<span class="number">0</span>) &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>)</span><br><span class="line">            vals.push(Integer.parseInt(currentChar));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">       vals.push(Integer.parseInt(Integer.toString(vals.pop())+currentChar()));</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码">完整代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        Stack&lt;String&gt; ops = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; vals = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            String currentChar = s.substring(i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//将当前位置的字符转化为字符串</span></span><br><span class="line">            <span class="keyword">if</span> (currentChar.equals(<span class="string">&quot; &quot;</span>))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (currentChar.charAt(<span class="number">0</span>) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; currentChar.charAt(<span class="number">0</span>) &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">                    vals.push(Integer.parseInt(currentChar));</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    vals.push(Integer.parseInt(Integer.toString(vals.pop()) + currentChar));</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (currentChar.equals(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">                ops.push(currentChar);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (currentChar.equals(<span class="string">&quot;+&quot;</span>) || currentChar.equals(<span class="string">&quot;-&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(ops.isEmpty());</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ops.peek().equals(<span class="string">&quot;+&quot;</span>) || ops.peek().equals(<span class="string">&quot;-&quot;</span>))&#123;</span><br><span class="line">                    <span class="keyword">int</span> x = vals.pop();</span><br><span class="line">                    String op = ops.pop();</span><br><span class="line">                    <span class="keyword">if</span>(op.equals(<span class="string">&quot;+&quot;</span>))</span><br><span class="line">                        x = vals.pop() + x;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(op.equals(<span class="string">&quot;-&quot;</span>))</span><br><span class="line">                        x = vals.pop() - x;</span><br><span class="line">                    vals.push(x);</span><br><span class="line">                &#125;</span><br><span class="line">                ops.push(currentChar);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (currentChar.equals(<span class="string">&quot;)&quot;</span>)) &#123;</span><br><span class="line">                String op = ops.pop();</span><br><span class="line">                <span class="keyword">while</span> (!op.equals(<span class="string">&quot;(&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = vals.pop();</span><br><span class="line">                    <span class="keyword">if</span> (op.equals(<span class="string">&quot;+&quot;</span>))</span><br><span class="line">                        x = vals.pop() + x;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (op.equals(<span class="string">&quot;-&quot;</span>))</span><br><span class="line">                        x = vals.pop() - x;</span><br><span class="line">                    vals.push(x);</span><br><span class="line">                    <span class="keyword">if</span> (!ops.isEmpty())</span><br><span class="line">                        op = ops.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!ops.isEmpty()) &#123;</span><br><span class="line">            String op = ops.pop();</span><br><span class="line">            <span class="keyword">int</span> x = vals.pop();</span><br><span class="line">            <span class="keyword">if</span> (op.equals(<span class="string">&quot;+&quot;</span>))</span><br><span class="line">                x = vals.pop() + x;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (op.equals(<span class="string">&quot;-&quot;</span>))</span><br><span class="line">                x = vals.pop() - x;</span><br><span class="line">            vals.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vals.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Java </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA String学习笔记</title>
      <link href="/hexo_zh/2021/07/01/javanote/java-string-xue-xi-bi-ji/"/>
      <url>/hexo_zh/2021/07/01/javanote/java-string-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>String是一种特殊的对象（不同于8种基本数据类型）。String类的特殊性可以它的两个其他的类不具有的特点体现出来<span id="more"></span></p><ul><li><p>在创建一个String对象的时候，我们不仅可以通过和其他类类似的创建方式，通过<code>new</code>的方式创建，我们也可以直接通过赋值创建 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String newStr1 = <span class="keyword">new</span> String(<span class="string">&quot;content&quot;</span>); <span class="comment">// 和其他对象类似的创建方式</span></span><br><span class="line">String newStr2 =  <span class="string">&quot;content&quot;</span>;</span><br><span class="line"><span class="comment">// String 特殊的创建方式</span></span><br></pre></td></tr></table></figure></p></li><li><p>String可以直接进行+运算，达到字符串连接的效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str3 = <span class="string">&quot;One String&quot;</span>;</span><br><span class="line">String str4 = <span class="string">&quot; Another String&quot;</span>;</span><br><span class="line">String str5 = str3 + str4;</span><br><span class="line"><span class="comment">// str5 = &quot;One String Another String&quot;</span></span><br></pre></td></tr></table></figure></li></ul><p>另外一个需要注意的点：String可以为空，但是空字符串不代表<code>null</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str6 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">String str7 = <span class="keyword">new</span> String();</span><br><span class="line">String str8 = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">/* str6和str7一样,但和str8不一样 */</span></span><br></pre></td></tr></table></figure><p>String作为一个对象，具有一个对象应该具有基本元素。String的field都是private的，所以我们也不需要知道他们的具体内容。String提供的method可以帮助我们实现很多对String的操作</p><ul><li><p><code>char charAt(int i)</code> 返回String在第<span class="math inline">\(i\)</span>个位置的字符</p></li><li><p><code>int compareTo(String anotherString)</code> 返回值是整型，它是先比较对应字符的大小(ASCII码顺序)，如果第一个字符和参数的第一个字符不等，结束比较，返回他们之间的<strong>差值</strong>，如果第一个字符和参数的第一个字符相等，则以第二个字符和参数的第二个字符做比较，以此类推,直至比较的字符或被比较的字符有一方结束。（<a href="https://www.runoob.com/java/java-string-compareto.html">菜鸟教程</a>）</p></li><li><p><code>String concat(String str)</code> 和加法运算符相同的效果</p></li><li><p><code>int indexOf(int ch)</code> <code>int indexOf(int ch, int fromIndex)</code> <code>int indexOf(String str)</code> <code>int indexOf(String str, int fromIndex)</code>返回String中出现的第一个相应的参数字符的下标，<code>fromIndex</code>表示从此处开始搜索。对应的有<code>int lastIndexOf(parameters)</code>表示最后一个出现的字符下标</p></li><li><p><code>boolean isEmpty()</code> 判断一个String是否为空，若是返回true。</p></li><li><p><code>String replace(char oldChar, char newChar)</code> 将原本的字符串中的所有<code>oldchar</code>用<code>newChar</code>代替，返回替换后的字符串</p></li><li><p><code>String[] split(String regex, int limit)</code> 以<code>regex</code>为界限分割String得到一个数组。参数<code>int limit</code>(optional)表示分割的上限次数（以前limit-1的<code>regex</code>进行分割，共分成limit个String），limit&lt;=0表示无界限。</p><p>e.g. 在下面这种情况中，<code>|</code>被编译器默认认为是或运算符, 所以我们需要用<code>"\\|"</code>进行区分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s=“ABC|DEF|GHI”;</span><br><span class="line">s.split(“|”)</span><br><span class="line"><span class="comment">/*-&gt; [ “A”, “B”, “C”, “|”, “D”, “E”, “F”, “|”, “G”, “H”, “I”];*/</span></span><br><span class="line">String s=“ABC|DEF|GHI”;</span><br><span class="line">s.split(“\\|”);</span><br><span class="line"><span class="comment">/* -&gt; [ “ABC”, “DEF”, “GHI”]; */</span></span><br></pre></td></tr></table></figure></li><li><p><code>String substring(int beginIndex, int endIndex)</code> 返回从<code>beginIndex</code>开始到<code>endIndex</code>（不包括）的substring。</p></li><li><p><code>String trim()</code> 返回消除了所有空格之后的字符串</p><ul><li>有关String更详细的方法可以参考<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html">官方文档</a></li></ul></li></ul><p>String一旦被创建就不能再更改（注：<code>String.concat()</code>和运算符"+"都会创建一个新的String对象而不是在原来的String基础上进行更改），所以Java提供了另一个类来实现String的更改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder strbui = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;something &quot;</span>);</span><br><span class="line">strbui.append(<span class="string">&quot;another thing &quot;</span>);</span><br><span class="line"><span class="comment">// strbui: something another thing</span></span><br></pre></td></tr></table></figure><p>相比于<code>concat</code>和加法运算，使用StringBuilder的好处就是提高了效率</p><p>数字和字符串之间的转换</p><ul><li><p>Integer与String转化</p><ul><li><p><code>Integer.parseInt(str)</code> 将<code>str</code>转化为对应的Integer</p></li><li><p>Integer转化为对应的字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">&quot;&quot;</span> + <span class="number">123</span>;</span><br><span class="line">String a = Integer.toString(<span class="number">123</span>);</span><br><span class="line">String a = String.valueOf(<span class="number">123</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Double与String转化</p><ul><li><p><code>Double.parseDouble(str)</code> 将<code>str</code>转化为对应的Double</p></li><li><p>Double转化为String使用<code>String.valueOf(double d)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="number">11.01</span>;</span><br><span class="line">String s = String.valueOf(d);</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java链表、栈、队列、哈希表、集合</title>
      <link href="/hexo_zh/2021/07/01/javanote/java-lian-biao-zhan-dui-lie-ha-xi-biao-ji-he/"/>
      <url>/hexo_zh/2021/07/01/javanote/java-lian-biao-zhan-dui-lie-ha-xi-biao-ji-he/</url>
      
        <content type="html"><![CDATA[<p>总结一下JAVA中常见的一些与数据结构有关的持有对象以及他们的常见的方法 (并不是全部因为全部太多了orz)</p><span id="more"></span><h2 id="列表-list">列表 List</h2><table><thead><tr class="header"><th>方法</th><th>作用</th></tr></thead><tbody><tr class="odd"><td><code>boolean add(E e)</code></td><td>在列表末尾添加元素</td></tr><tr class="even"><td><code>void add(int index, E e)</code></td><td>在指定的下标处添加元素</td></tr><tr class="odd"><td><code>void clear()</code></td><td>清除列表中的所有元素</td></tr><tr class="even"><td><code>boolean contains(Object o)</code></td><td>判断列表中是否包含指定的元素</td></tr><tr class="odd"><td><code>E get(int index)</code></td><td>返回指定下标出的元素</td></tr><tr class="even"><td><code>int indexOf(Object o)</code></td><td>返回指定元素的下标，如果列表中不存在返回-1</td></tr><tr class="odd"><td><code>boolean isEmpty()</code></td><td>判断列表是否为空</td></tr><tr class="even"><td><code>E remove(int index)</code></td><td>删除指定下标处的元素</td></tr><tr class="odd"><td><code>boolean remove(Object o)</code></td><td>删除指定元素，如果不存在返回<code>false</code></td></tr><tr class="even"><td><code>E set(int index, E element)</code></td><td>将指定下标处的元素用新的元素代替</td></tr><tr class="odd"><td><code>int size()</code></td><td>返回列表的大小</td></tr><tr class="even"><td><code>default void sort(Comparator&lt;? super E&gt; c)</code></td><td>对列表进行按照给定的Compartor的排序</td></tr><tr class="odd"><td><code>Object[] toArray()</code></td><td>将列表转化为对应元素的一个数组</td></tr></tbody></table><h3 id="列表与数组之间的相互转化">列表与数组之间的相互转化</h3><p>在实际使用中，数组和列表的相互转化也是经常需要用到的，奈何本人记性太差，老是记不住，印象中已经是查了N次了，果然好记性不如烂笔头，还是记一下吧，原文：<a href="https://blog.csdn.net/lpq374606827/article/details/93203927">Java List和Array之间的转换</a></p><h4 id="array-转为list">Array 转为List</h4><ol type="1"><li><p>实现方法 :java中数组转list使用Arrays.asList(T... a)方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Array2List</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; listA=Arrays.asList(<span class="string">&quot;dog&quot;</span>,<span class="string">&quot;cat&quot;</span>,<span class="string">&quot;cow&quot;</span>);</span><br><span class="line">        String[] strs=&#123;<span class="string">&quot;dog&quot;</span>,<span class="string">&quot;cat&quot;</span>,<span class="string">&quot;cow&quot;</span>&#125;;</span><br><span class="line">        List&lt;String&gt; listB= Arrays.asList(strs);</span><br><span class="line">        System.out.println(listA);</span><br><span class="line">        System.out.println(listB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意事项</p><p>1）<code>Arrays.asList()</code>方法返回的对象是Arrays的内部类，对list的操作仍然反映在原数组上，因此这个list是定长的，不支持add、remove操作；</p><p>2）由于<code>asList</code>方法接受的泛型参数，因此不能用于基本类型，只能使用如下方法：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Array2List</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:a)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ol><h4 id="list转为array">List转为Array</h4><ol type="1"><li><p>实现：使用<code>list.toArray()</code></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Array2List</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;cow&quot;</span>);</span><br><span class="line">        String[] animals=list.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(String animal:animals)&#123;</span><br><span class="line">            System.out.println(animal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>注意事项</p><p>由于<code>list.toArray()</code>返回的是Object对象数组，如果我们想要转化为基本类型数组，比如说<code>List&lt;Integer&gt;</code>转化为<code>int[]</code>，那么可以使用<code>steam()</code>：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().mapToInt(Integer::intValue).toArray();</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="双端队列-deque-1">双端队列 Deque [1]</h2><table><thead><tr class="header"><th></th><th>First Element (Head)</th><th></th><th><strong>Last Element (Tail)</strong></th><th></th></tr></thead><tbody><tr class="odd"><td></td><td><em>Throws exception</em></td><td><em>Special value</em></td><td><em>Throws exception</em></td><td><em>Special value</em></td></tr><tr class="even"><td><strong>Insert</strong></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#addFirst(E)"><code>addFirst(e)</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#offerFirst(E)"><code>offerFirst(e)</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#addLast(E)"><code>addLast(e)</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#offerLast(E)"><code>offerLast(e)</code></a></td></tr><tr class="odd"><td><strong>Remove</strong></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#removeFirst()"><code>removeFirst()</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#pollFirst()"><code>pollFirst()</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#removeLast()"><code>removeLast()</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#pollLast()"><code>pollLast()</code></a></td></tr><tr class="even"><td><strong>Examine</strong></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#getFirst()"><code>getFirst()</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#peekFirst()"><code>peekFirst()</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#getLast()"><code>getLast()</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#peekLast()"><code>peekLast()</code></a></td></tr></tbody></table><table><thead><tr class="header"><th><strong><code>Queue</code> Method</strong></th><th><strong>Equivalent <code>Deque</code> Method</strong></th></tr></thead><tbody><tr class="odd"><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Queue.html#add(E)"><code>add(e)</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#addLast(E)"><code>addLast(e)</code></a></td></tr><tr class="even"><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Queue.html#offer(E)"><code>offer(e)</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#offerLast(E)"><code>offerLast(e)</code></a></td></tr><tr class="odd"><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Queue.html#remove()"><code>remove()</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#removeFirst()"><code>removeFirst()</code></a></td></tr><tr class="even"><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Queue.html#poll()"><code>poll()</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#pollFirst()"><code>pollFirst()</code></a></td></tr><tr class="odd"><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Queue.html#element()"><code>element()</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#getFirst()"><code>getFirst()</code></a></td></tr><tr class="even"><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Queue.html#peek()"><code>peek()</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#peek()"><code>peekFirst()</code></a></td></tr></tbody></table><table><thead><tr class="header"><th><strong>Stack Method</strong></th><th><strong>Equivalent <code>Deque</code> Method</strong></th></tr></thead><tbody><tr class="odd"><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#push(E)"><code>push(e)</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#addFirst(E)"><code>addFirst(e)</code></a></td></tr><tr class="even"><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#pop()"><code>pop()</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#removeFirst()"><code>removeFirst()</code></a></td></tr><tr class="odd"><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#peek()"><code>peek()</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#peekFirst()"><code>peekFirst()</code></a></td></tr></tbody></table><h3 id="arraylist">ArrayList</h3><p>ArrayList是List接口的可变数组实现，所有的方法和List基本一致。时间复杂度方面，增的时间复杂度均摊下来是常数的，但是几乎其他的操作都是线性时间复杂度，优点是常数因子相比于LinkedList来说比较小。</p><table><thead><tr class="header"><th>特有的方法</th><th>作用</th></tr></thead><tbody><tr class="odd"><td><code>void ensureCapcity(int minCapacity)</code></td><td>将动态数组进行扩容，确保列表能够容纳给定的最小容量</td></tr><tr class="even"><td><code>void trimToSize()</code></td><td>将动态数组的容量调整为数组中的元素个数</td></tr></tbody></table><h3 id="linkedlist">LinkedList</h3><p>LinkedList是List接口和Deque接口的双向链表实现，所拥有的方法为List接口和Deque接口的集合。链表实现使得增、删时间复杂度为O(1)，但是没有了ArrayList中的索引机制，导致对于特定位置的元素查询时间复杂度为O(n)。</p><h2 id="图-map-键值对">图 Map （键值对）</h2><table><colgroup><col style="width: 39%" /><col style="width: 60%" /></colgroup><thead><tr class="header"><th>方法</th><th>作用</th></tr></thead><tbody><tr class="odd"><td><code>void clear()</code></td><td>清除图中所有的元素</td></tr><tr class="even"><td><code>boolean containsKey(Object key)</code></td><td>判断是否包含我们给定键的键值对</td></tr><tr class="odd"><td><code>boolean containsValue(Object value)</code></td><td>判断是否包含我们给定值的键值对</td></tr><tr class="even"><td><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code></td><td>返回Map的集合(Set)视图</td></tr><tr class="odd"><td><code>V get (Object key)</code></td><td>返回给定键的对应值，若不存在，返回null</td></tr><tr class="even"><td><code>default V getOrDefault(Object key, V defaultValue)</code></td><td>返回给定键的对应值，若不存在，返回设定的默认值</td></tr><tr class="odd"><td><code>boolean isEmpty()</code></td><td>判断Map是否为空</td></tr><tr class="even"><td><code>Set&lt;K&gt; keySet()</code></td><td>返回Map中键的集合(Set)视图</td></tr><tr class="odd"><td><code>V put(K key, V value)</code></td><td>将给定的键值对插入到Map中，若已经存在对应的key，则替换value，返回旧的value，若不存在，返回null</td></tr><tr class="even"><td><code>default V putIfAbsent(K key, V value)</code></td><td>如果不存在给定的键的键值对，则插入，否则，返回当前键对应的值</td></tr><tr class="odd"><td><code>V remove(Object key)</code></td><td>删除给定键的键值对</td></tr><tr class="even"><td><code>default boolean remove(Object key, Object value)</code></td><td>删除给定的键值对，返回是否删除成功</td></tr><tr class="odd"><td><code>default V replace(K key, V value)</code></td><td>如果存在给定键的键值对，替换键的当前值为给定的新值</td></tr><tr class="even"><td><code>default boolean replace(K key, V oldValue, V newValue)</code></td><td>如果存在给定键值对，替换给定键值对中的值为新值，返回是否替换成功</td></tr><tr class="odd"><td><code>int size()</code></td><td>返回Map中的键值对数目</td></tr></tbody></table><h3 id="hashmap和hashtable">HashMap和Hashtable</h3><p>Map接口的哈希表实现，HashMap基本与Hashtable相同，除了HashMap是异步的并且允许null key。时间复杂度方面，对于基本的增查操作 (get and put)，HashMap可以达到常数的时间复杂度。关于HashMap和Hashtable的区分，详情可以参考这一篇博文 <a href="https://www.cnblogs.com/lchzls/p/6714335.html">[2]</a></p><p>构造器 Constructor：initialCapcacity和loadFactor影响HashMap的性能。当当前的entry数量超过loadFactor和当前容量的乘积，哈希表就会被rehash，扩容至原来的两倍 [3]。默认情况下initialCapacity为16，loadFactor为0.75，这样的情况下性能是 比较好的。</p><table><thead><tr class="header"><th>构造器 Constructor</th></tr></thead><tbody><tr class="odd"><td>HashMap(): 默认的initialCapacity为16，loadFactor为0.75</td></tr><tr class="even"><td>HashMap(int initialCapacity)：设定初始化容量</td></tr><tr class="odd"><td>HashMap(int initialCapacity, float loadFactor)：设定初始化容量和负载系数</td></tr></tbody></table><h3 id="treemap">TreeMap</h3><p>NavigableMap接口的红黑树实现，具有排序的能力，默认情况对键值的进行默认的排序，也可以指定Comparator进行排序。TreeMap与普通 的Map不同的方法在于一些和键值顺序有关的函数，下面简要列举一下</p><table><colgroup><col style="width: 47%" /><col style="width: 52%" /></colgroup><thead><tr class="header"><th>方法</th><th>作用</th></tr></thead><tbody><tr class="odd"><td><code>Map.Entry&lt;K,V&gt; ceilingEntry(K key)</code></td><td>最小的键大于等于给定值的键值对</td></tr><tr class="even"><td><code>K ceilingKey(K key)</code></td><td>最小的大于等于给定值的键</td></tr><tr class="odd"><td><code>NavigableSet&lt;K&gt; descendingKeySet()</code></td><td>降序排列的键集合</td></tr><tr class="even"><td><code>NavigableMap&lt;K,V&gt; descendingMap()</code></td><td>按键降序排列的Map</td></tr><tr class="odd"><td><code>Map.Entry&lt;K,V&gt; firstEntry()</code></td><td>键最小的键值对</td></tr><tr class="even"><td><code>K firstKey()</code></td><td>最小的键</td></tr><tr class="odd"><td><code>Map.Entry&lt;K,v&gt; floorEntry(K key)</code></td><td>最大的键小于等于给定值的键值对</td></tr><tr class="even"><td><code>K floorKey(K key)</code></td><td>最大的小于等于给定值的键</td></tr><tr class="odd"><td><code>SortedMap&lt;K,V&gt; headMap(K toKey)</code></td><td>返回小于给定键的所有键值对的一个map</td></tr><tr class="even"><td><code>NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive)</code></td><td>返回小于（或等于）给定键的所有键值对的一个map，如果没有则返回null</td></tr><tr class="odd"><td><code>Map.Entry&lt;K,V&gt; higherEntry(K key)</code></td><td>最小的键严格大于给定键的键值对</td></tr><tr class="even"><td><code>K higherKey(K key)</code></td><td>最小的严格大于给定键的键值对</td></tr><tr class="odd"><td><code>Map.Entry&lt;K,V&gt; lastEntry()</code></td><td>键最大的键值对</td></tr><tr class="even"><td><code>K lastKey()</code></td><td>最大的键</td></tr><tr class="odd"><td><code>Map.Entry&lt;K,V&gt; lowerEntry(K key)</code></td><td>最大的键严格小于给定键的键值对</td></tr><tr class="even"><td><code>K lowerKey(K key)</code></td><td>最大的严格小于给定键的键值对</td></tr><tr class="odd"><td><code>Map.Entry&lt;K,V&gt;   pollFirstEntry()</code></td><td>删除并返回键最小的键值对</td></tr><tr class="even"><td><code>Map.Entry&lt;K,V&gt;   pollLastEntry()</code></td><td>删除并返回键最大的键值对</td></tr><tr class="odd"><td><code>SortedMap&lt;K,V&gt; headMap(K toKey)</code></td><td>返回大于等于给定键的所有键值对的一个map</td></tr><tr class="even"><td><code>NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive)</code></td><td>返回大于（或等于）给定键的所有键值对的一个map，如果没有则返回null</td></tr></tbody></table><h2 id="集合-set-接口">集合 Set 接口</h2><p>集合的方法就比较简单了，基本上都是之前的一些简单重复，简单列举一下</p><table><thead><tr class="header"><th>方法</th><th>方法</th><th>方法</th></tr></thead><tbody><tr class="odd"><td><code>boolean add(E e)</code></td><td><code>void clear()</code></td><td><code>boolean contains(Object o)</code></td></tr><tr class="even"><td><code>boolean equals(Object o)</code></td><td><code>boolean isEmpty()</code></td><td><code>boolean remove(Object o)</code></td></tr><tr class="odd"><td><code>int size()</code></td><td><code>Object[] toArray()</code></td><td></td></tr></tbody></table><p>常用的集合类有HashSet（基于HashMap实现）以及它的子类LinkedHashSet。</p><h2 id="参考资料">参考资料</h2><p>[1] <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Deque.html">Deque (Java Platform SE 8 ) (oracle.com)</a></p><p>[2] <a href="https://www.cnblogs.com/lchzls/p/6714335.html">JAVA中HashMap和Hashtable区别 - 知我者，足以 - 博客园 (cnblogs.com)</a></p><p>[3] <a href="https://www.cnblogs.com/crelle/p/13657214.html">HashMap中的Initial Capacity和Load Factory - 我要去巴萨 - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Java学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL问题:Temporary failure resolving &#39;&#39;archive.ubuntu.com&#39;&#39;</title>
      <link href="/hexo_zh/2021/06/29/bug/bugwsl-wen-ti-temporary-failure-resolving-archive-ubuntu-com/"/>
      <url>/hexo_zh/2021/06/29/bug/bugwsl-wen-ti-temporary-failure-resolving-archive-ubuntu-com/</url>
      
        <content type="html"><![CDATA[<p>今天在WSL进行操作的时候，发现从网络上下载东西无法成功，包括wget 、apt-get 等命令都无法正常使用，比如执行sudo apt-get update 的时候会提示</p><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Err:1 http://security.ubuntu.com/ubuntu bionic-security InRelease</span><br><span class="line">  Temporary failure resolving <span class="string">&#x27;security.ubuntu.com&#x27;</span></span><br><span class="line">Err:2 http://archive.ubuntu.com/ubuntu bionic InRelease</span><br><span class="line">  Temporary failure resolving <span class="string">&#x27;archive.ubuntu.com&#x27;</span></span><br><span class="line">Err:3 http://archive.ubuntu.com/ubuntu bionic-updates InRelease</span><br><span class="line">  Temporary failure resolving <span class="string">&#x27;archive.ubuntu.com&#x27;</span></span><br><span class="line">Err:4 http://archive.ubuntu.com/ubuntu bionic-backports InRelease</span><br><span class="line">  Temporary failure resolving <span class="string">&#x27;archive.ubuntu.com&#x27;</span></span><br><span class="line">Reading package lists... Done</span><br><span class="line">W: Failed to fetch http://archive.ubuntu.com/ubuntu/dists/bionic/InRelease  Temporary failure resolving <span class="string">&#x27;archive.ubuntu.com&#x27;</span></span><br><span class="line">W: Failed to fetch http://archive.ubuntu.com/ubuntu/dists/bionic-updates/InRelease  Temporary failure resolving <span class="string">&#x27;archive.ubuntu.com&#x27;</span></span><br><span class="line">W: Failed to fetch http://archive.ubuntu.com/ubuntu/dists/bionic-backports/InRelease  Temporary failure resolving <span class="string">&#x27;archive.ubuntu.com&#x27;</span></span><br><span class="line">W: Failed to fetch http://security.ubuntu.com/ubuntu/dists/bionic-security/InRelease  Temporary failure resolving <span class="string">&#x27;security.ubuntu.com&#x27;</span></span><br><span class="line">W: Some index files failed to download. They have been ignored, or old ones used instead.</span><br></pre></td></tr></table></figure><p>经过查询和搜索（解决bug真的痛苦😫），发现通过一下几行命令可以解决</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /etc/resolv.conf</span><br><span class="line">sudo bash -c <span class="string">&#x27;echo &quot;nameserver 8.8.8.8&quot; &gt; /etc/resolv.conf&#x27;</span></span><br><span class="line">sudo bash -c <span class="string">&#x27;echo &quot;[network]&quot; &gt; /etc/wsl.conf&#x27;</span></span><br><span class="line">sudo bash -c <span class="string">&#x27;echo &quot;generateResolvConf = false&quot; &gt;&gt; /etc/wsl.conf&#x27;</span></span><br><span class="line">sudo chattr +i /etc/resolv.conf</span><br></pre></td></tr></table></figure><p>接下来下载东西就都没有问题了。</p><blockquote><p>2021.11.20 补充：今天又碰到这个问题了，这次是ssh的时候无法解析hostname，</p><p>又get到了一种新的解决办法：</p><p>直接在/etc/resolv.conf中加入dns服务器地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 202.96.134.133</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure><p>然后重新启动wsl就可以了</p></blockquote><p>参考资料:</p><p><a href="https://github.com/microsoft/WSL/issues/5420#issuecomment-646479747">Github上的一个issue</a></p><p><a href="https://blog.csdn.net/weixin_38204723/article/details/78316940">ubuntu apt-get 错误 Temporary failure resolving 'us.archive.ubuntu.com' 解决</a></p>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug </tag>
            
            <tag> WSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS EC2上部署PostgreSQL + TimeScaleDB</title>
      <link href="/hexo_zh/2021/06/29/aws-ec2-shang-bu-shu-postgresql-timescaledb/"/>
      <url>/hexo_zh/2021/06/29/aws-ec2-shang-bu-shu-postgresql-timescaledb/</url>
      
        <content type="html"><![CDATA[<h4 id="在ec2上部署postgresqltimescaledb">在EC2上部署PostgreSQL+TimescaleDB</h4><p>首先，创建一个Ubuntu实例，使用ssh连接到这个服务器上（使用WSL进行连接可以看这一篇博文<a href="https://lucas-hao.github.io/2021/06/29/aws-ec2-shang-chuang-jian-yi-ge-ubuntu-instance-bing-shi-yong-wsl-lian-jie/">AWS EC2上创建一个Ubuntu Instance 并使用WSL连接)</a>）。连接好之后，就可以按照<a href="https://docs.timescale.com/timescaledb/latest/how-to-guides/install-timescaledb/self-hosted/ubuntu/installation-apt-ubuntu/#apt-installation-ubuntu">Timescale文档</a>，进行PostgreSQL+TimeScaleDB的安装和部署了。</p><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># `lsb_release -c -s` should return the correct codename of your OS</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb &lt;http://apt.postgresql.org/pub/repos/apt/&gt; <span class="subst">$(lsb_release -c -s)</span>-pgdg main&quot;</span> | sudo tee /etc/apt/sources.list.d/pgdg.list</span><br><span class="line">wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -</span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add our PPA</span></span><br><span class="line">sudo add-apt-repository ppa:timescale/timescaledb-ppa</span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now install appropriate package for PG version</span></span><br><span class="line">sudo apt install timescaledb-2-postgresql-13</span><br><span class="line"></span><br><span class="line">sudo timescaledb-tune (y/y/n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Restart PostgreSQL instance</span></span><br><span class="line">sudo service postgresql restart</span><br></pre></td></tr></table></figure><p>按照以上步骤操作完成之后，PostgreSQL就已经安装成功了。可以通过<code>psql --version</code>查看PostgreSQL版本信息。接下来，为了让我们的PostgreSQL被远程访问，我们需要对它进行配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/postgresql/13/main/postgresql.conf</span><br></pre></td></tr></table></figure><p>打开配置文件，找到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#listen_addresses = &#x27;localhost&#x27;</span></span><br></pre></td></tr></table></figure><p>去掉注释，修改为（这样修改允许数据库能够监听所有的地址）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen_addresses = &#x27;*&#x27;</span><br></pre></td></tr></table></figure><p>接下来打开另外一个配置文件进行修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/postgresql/13/main/pg_hba.conf</span><br></pre></td></tr></table></figure><p>找到最后几行，修改为如下样式，这样修改是为了能够远程访问到数据库。</p><figure><img src="https://i.loli.net/2021/07/16/LH8432jpWqN5GAh.png" alt="pg_hba-conf" /><figcaption aria-hidden="true">pg_hba-conf</figcaption></figure><p>然后重新启动PostgreSQL服务<code>sudo service postgresql restart</code>，配置完成之后，输入命令<code>sudo -u postgres psql postgres</code>使用postgreSQL默认的用户postgres进入数据库，使用<code>\password</code>设置密码，然后就可以正常使用数据库了。</p><h4 id="使用pgadmin连接">使用pgAdmin连接</h4><p>打开pgAdmin，右键Servers→Create→Server...，和正常连接到数据库一样，首先给一个命名，然后在Connection中，和在本地连接数据库一样，填写相关的信息，密码就是云端上数据库的密码。</p><figure><img src="https://i.loli.net/2021/07/16/zNyjnduafTb4cP8.png" alt="pgAdmin-connection" /><figcaption aria-hidden="true">pgAdmin-connection</figcaption></figure><p>然后，在SSH Tunnel中，在Tunnel host输入AWS EC2实例的public IPv4 DNS，Tunnel port填22，username就是服务器的用户名，Ubuntu服务器的默认用户名就是ubuntu。Authentication选择Identity file，然后Identity file一栏选中之前下载的密钥对</p><figure><img src="https://i.loli.net/2021/07/16/PMASp6fxsUlZNXw.png" alt="pgAdmin-SSH" /><figcaption aria-hidden="true">pgAdmin-SSH</figcaption></figure><p>点击Save按钮就可以成功连接。</p><h4 id="命令行远程连接数据库">命令行远程连接数据库</h4><p>默认情况下，AWS EC2开放的端口只有SSH默认的端口22，但是我们想要远程访问的是PostgreSQL的端口5432，所以在默认情况下，我们无法远程访问PostgreSQL数据库。在我们输入命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql postgres://username:password@hostname:port/dbname</span><br></pre></td></tr></table></figure><p>之后，就会得到报错信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">psql: 错误: 无法联接到服务器: Connection timed out (0x0000274C/10060)</span><br><span class="line">        服务器是否在主机 <span class="string">&quot;hostname&quot;</span> 上运行并且准备接受在端口</span><br><span class="line">5432 上的 TCP/IP 联接?</span><br></pre></td></tr></table></figure><p>这个错误信息就提示我们需要打开AWS EC2数据库中的5432端口，我们才可以对数据库进行远程访问。首先，我们需要打开EC2控制台，然后打开Security Groups (安全组)，选中一个安全组，然后进入Actions下的Edit inbound rules (编辑入站规则)。</p><figure><img src="https://i.loli.net/2021/07/16/1LodksGSKBmIMgt.png" alt="edit-bound-rules" /><figcaption aria-hidden="true">edit-bound-rules</figcaption></figure><p>默认情况下只有一个类型为SSH的规则，点击Add rule，类型选择PostgreSQL，点击Save rules保存即可。</p><figure><img src="https://i.loli.net/2021/07/16/7fHB4xqA51uR9lE.png" alt="inbound-rules" /><figcaption aria-hidden="true">inbound-rules</figcaption></figure><p>然后我们直接在命令行中使用命令就可以进行连接啦</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql postgres://postgres:yourpassword@ec2-34-200-222-92.compute-1.amazonaws.com:5432/postgres</span><br></pre></td></tr></table></figure><p>同样的，我们可以使用Java中的jdbc连接数据库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> String connUrl = <span class="string">&quot;jdbc:postgresql://ec2-34-200-222-92.compute-1.amazonaws.com:5432/postgres?user=postgres&amp;password=yourpassword&quot;</span>;</span><br><span class="line">      <span class="keyword">try</span> (Connection conn = DriverManager.getConnection(connUrl)) &#123;</span><br><span class="line">          System.out.println(conn.getClientInfo());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">          System.err.println(<span class="string">&quot;SQLState: &quot;</span> + ex.getSQLState() +  <span class="string">&quot;\\t&quot;</span> + ex.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>显示结果</p><blockquote><p>{ApplicationName=PostgreSQL JDBC Driver}</p></blockquote><p>成功连接！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS EC2上创建一个Ubuntu Instance 并使用WSL连接</title>
      <link href="/hexo_zh/2021/06/29/aws-ec2-shang-chuang-jian-yi-ge-ubuntu-instance-bing-shi-yong-wsl-lian-jie/"/>
      <url>/hexo_zh/2021/06/29/aws-ec2-shang-chuang-jian-yi-ge-ubuntu-instance-bing-shi-yong-wsl-lian-jie/</url>
      
        <content type="html"><![CDATA[<h4 id="在aws-ec2上部署ubuntu">在AWS EC2上部署Ubuntu</h4><ol type="1"><li><p>登录AWS，进入EC2 Dashboard，点击Launch instance来新建一个实例。 <img src="https://i.loli.net/2021/07/16/XOg3CIUzjirtlhw.png" alt="Ubuntu-lauch-instance" /></p><p><span id="more"></span></p></li><li><p>选择AMI，这里我选择了Ubuntu 20.04 <img src="https://i.loli.net/2021/07/16/ClQOwTNs6BJj13m.png" alt="choose-ami" /></p></li><li><p>选择想要的Instance Type，可以根据自己的实际需求进行选择，如果是进行学习的话，AWS对于第一次注册的用户在12个月内提供免费的套餐，如果我没有记错的话应该是t2.micro。选择好之后，默认情况下我们直接点击Review and Launch。 <img src="https://i.loli.net/2021/07/16/ObrBC8DadxVcq3e.png" /></p></li><li><p>之后页面上会显示创建的实例的一些信息，如果有需要改变的地方，可以这里进行改变。在这里，由于我的目的是为这一个实例上部署一个PostgreSQL数据库，然后从远程访问这个数据库，所以我需要对Security Groups进行一些设置和修改，详情可以看这一篇博文<a href="https://lucas-hao.github.io/2021/06/29/aws-ec2-shang-bu-shu-postgresql-timescaledb/#more">AWS EC2上部署PostgreSQL + TimeScaleDB)</a>。 <img src="https://i.loli.net/2021/07/16/GmKzbHiEfoO6CJs.png" alt="review-instance-launch" /></p></li><li><p>设置完成之后点击Launch，跳出如下页面，我们需要选择或者创建一个密钥对</p><p><img src="https://i.loli.net/2021/07/16/XZeKmCSxHiFzoTD.png" alt="key-pair" />输入密钥对的名字之后，我们将这个密钥对下载到我们的电脑里面，这个密钥对一定要保存好，因为我们需要这个密钥对远程通过SSH连接这个服务器。然后点击Launch Instances就成功在EC2上部署了一个Ubuntu的实例。</p></li></ol><h4 id="使用wsl进行服务器远程访问">使用WSL进行服务器远程访问</h4><p>首先要确保Windows上安装了WSL和Linux子系统。想要连接到EC2，首先要将下载到Windows中的密钥对文件复制到WSL中的路径中，有两种方式：</p><ol type="1"><li><p>使用命令行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /mnt/&lt;Windows drive letter&gt;/path/my-key-pair.pem ~/WSL-path/my-key-pair.pem</span><br></pre></td></tr></table></figure><p>注：Windows本地的文件夹可以在WSL下的mnt文件夹中进行访问</p></li><li><p>可以在Windows中的文件管理器中直接在地址栏中输入<code>\\wsl$</code>可以在网络中打开WSL的文件管理，然后直接将密钥对复制到对应的路径下就可以了。</p></li></ol><p>这个时候，还需要将密钥对的权限更改一下，否则的话由于我们没有对密钥对进行权限设置，直接连接的话就会报错。<img src="https://i.loli.net/2021/07/16/wB8JRmPL5ldi2AD.png" alt="wsl-warning" /></p><p>通过命令<code>chmod 400 filename.pem</code>更改文件权限，这个问题就能够解决了。接下来，我们就可以通过命令行命令连接到EC2上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i /path/my-key-pair.pem my-instance-user-name@my-instance-public-dns-name</span><br></pre></td></tr></table></figure><p>以下为参数的解释</p><ol type="1"><li><p>/path/my-key-pair.pem 当然就是密钥对所在的路径了</p></li><li><p>my-instance-user-name 就是所创建的EC2实例的用户名，下面是默认的用户名</p><p>对于 Amazon Linux 2 或 Amazon Linux AMI，用户名称是 ec2-user。</p><p>对于 CentOS AMI，用户名称是 centos。</p><p>对于 Debian AMI，用户名称是 admin。</p><p>对于 Fedora AMI，用户名为 ec2-user 或 fedora。</p><p>对于 RHEL AMI，用户名称是 ec2-user 或 root。</p><p>对于 SUSE AMI，用户名称是 ec2-user 或 root。</p><p>对于 Ubuntu AMI，用户名称是 ubuntu。</p></li><li><p>my-instance-public-dns-name 是创建的EC2实例的public IPv4 DNS，在AWS EC2 Dashboard中打开实例就可以找到，如果没有找到，那么在右上角的设置中打开显示即可。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android获取应用使用时长和次数-UsageStatsManager使用</title>
      <link href="/hexo_zh/2021/06/02/android/android-huo-qu-ying-yong-shi-yong-shi-chang-he-ci-shu-usagestatsmanager-shi-yong/"/>
      <url>/hexo_zh/2021/06/02/android/android-huo-qu-ying-yong-shi-yong-shi-chang-he-ci-shu-usagestatsmanager-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>最近在做暑研，要求是需要获取到Android手机中的应用使用情况，经过查找，发现Android提供了 <code>UsageStatsManager</code>类来帮助进行应用使用信息的统计（注明，Android5.0系统大部分手机不支持这个类，Android5.1系统之后完全支持[1], 显然现在大部分手机都是支持的），这篇文章主要记录一下这个类的使用方法。</p><span id="more"></span><h4 id="授权">授权</h4><p>想要使用这个类来获取应用使用信息，首先需要对app进行授权，我们需要在AndroidManifest.xml文件中加入<code>uses-permission</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;android.permission.PACKAGE_USAGE_STATS&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:ignore</span>=<span class="string">&quot;ProtectedPermissions&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>然后需要我们在设置-安全-更多安全设置-使用情况访问权限中给对应的app打开使用权限（华为p30 pro）。我们在代码中也可以进行判断，主动要求用户打开该设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先判断获取到的list是否为空 if (packageInfoList == null)</span></span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        startActivity(<span class="keyword">new</span> Intent(Settings.ACTION_USAGE_ACCESS_SETTINGS));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>,<span class="string">&quot;无法开启允许查看使用情况的应用界面&quot;</span>,Toast.LENGTH_LONG).show();</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对象初始化">对象初始化</h4><p>初始化<code>UsageStatsManager</code>类我们需要以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UsageStatsManager usm = (UsageStatsManager)getSystemService(Context.USAGE_STATS_SERVICE);</span><br></pre></td></tr></table></figure><h4 id="获取usagestats">获取UsageStats</h4><p><code>UsageStatsManager</code>提供了一些方法让我们获取应用的<code>UsageStats</code>，比如<code>Map&lt;String, UsageStats&gt; queryAndAggregateUsageStats(long beginTime, long endTime)</code>和<code>List&lt;EventsStats&gt; queryEventStats(int intervalType, long beginTime, long endTime)</code>，通过传入开始时间，结束时间和一个间隔类型(intervalType)来获取在一定时间范围内的<code>UsageStats</code>列表。其中，Android给了以下几种intervalType</p><table><colgroup><col style="width: 26%" /><col style="width: 73%" /></colgroup><thead><tr class="header"><th>Constants</th><th>Meaning</th></tr></thead><tbody><tr class="odd"><td><code>int INTERVAL_DAILY</code></td><td>An interval type that spans a day.</td></tr><tr class="even"><td><code>int INTERVAL_MONTHLY</code></td><td>An interval type that spans a month.</td></tr><tr class="odd"><td><code>int INTERVAL_WEEKLY</code></td><td>An interval type that spans a week.</td></tr><tr class="even"><td><code>int INTERVAL_YEARLY</code></td><td>An interval type that spans a year.</td></tr><tr class="odd"><td><code>int INTERVAL_BEST</code></td><td>An interval type that will use the best fit interval for the given time range.</td></tr></tbody></table><p><code>queryAndAggregateUsageStats</code>默认的间隔类型是<code>INTERVAL_BEST</code>。</p><p>下面的图片代表了我们传入的时间和我们的间隔类型结合应该得到的时间范围，需要注意的是，<strong>我们传入的beginTime和endTime不完全是系统获取app信息的开始和结束时间，beginTime和endTime是包含在开始和结束时间之中</strong>，也就是说，如果我们的间隔类型设置为<code>INTERVAL_DAILY</code>， 我们获取的使用信息的开始时间可能是beginTime的当天0时，结束时间可能是endTime的当天23:59，这个时间具体还和时区相关，所以具体情况需要视实际情况而定，更详细的解析可以看这一篇[2] <a href="https://blog.csdn.net/liuwan1992/article/details/83625520">关于 UsageStatsManager.queryUsageStats 的注意事项及 UsageStatsService 的简单原理_菜鸟的自我修养-CSDN博客</a>。</p><figure><img src="https://i.loli.net/2021/06/02/qDJ56Ld182YUrof.png" alt="image-20210602210207843" /><figcaption aria-hidden="true">image-20210602210207843</figcaption></figure><h4 id="获取应用名应用包名使用时长">获取应用名，应用包名，使用时长</h4><p>我们可以通过<code>UsageStats.getPackageName()</code>这个方法来获取应用的包名，通过<code>UsageStats.getTotalTimeInForeground()</code>这个方法获取应用在前台的使用时间。</p><p>获取应用的名字我们需要用到<code>PackageManger</code>中的<code>getApplcationLabel(ApplicationInfo info)</code>这个方法，获取<code>ApplicationInfo</code>可以使用<code>getApplicationInfo(String packageName, int flags)</code>这个方法，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getApplicationNameByPackageName</span><span class="params">(Context context, String packageName)</span> </span>&#123;</span><br><span class="line">    PackageManager pm = context.getPackageManager();</span><br><span class="line">    String Name;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Name = pm.getApplicationLabel(pm.getApplicationInfo(packageName, PackageManager.GET_META_DATA)).toString();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        Name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取应用使用次数">获取应用使用次数</h4><p>至于应用使用次数，通过查询发现<code>UsageStats</code>中有<code>mLauchCount</code>这个变量，但是Android没有提供对应的get方法，所以我们就需要用反射来获取使用次数 [3]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用反射，获取UsageStats中统计的应用使用次数</span></span><br><span class="line"><span class="meta">@RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLaunchCount</span><span class="params">(UsageStats usageStats)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">    Field field = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        field = usageStats.getClass().getDeclaredField(<span class="string">&quot;mLaunchCount&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;getLaunchCount: NoSuchFieldException&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(TAG, <span class="string">&quot;getLaunchCount: &quot;</span> + <span class="string">&quot;Package Name: &quot;</span> + usageStats.getPackageName() +</span><br><span class="line">          <span class="string">&quot;\t&quot;</span> + (<span class="keyword">int</span>) field.get(usageStats));</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) field.get(usageStats);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是实际使用下来的情况发现，得到的数据可能为0，原因不知道为什么，所以还可以通过一种较为复杂的方法进行实现。通过<code>UsageStatsManager.queryEvents(long beginTime, long endTime)</code>获取Android提供的另一个类<code>UsageEvents</code>，遍历可以获取到所有的events，通过<code>getEventType()</code>方法可以得到对应的event type，其中<code>ACTIVITY_PAUSED</code>和<code>ACTIVITY_RESUMED</code>分别代表了活动移动到了后台和移动到前台，可以通过这两个活动的次数来计算出应用使用次数。详细代码可以参考[3] <a href="https://blog.csdn.net/github_37271067/article/details/85292543">android统计手机应用使用时长以及开启次数_github_37271067的博客-CSDN博客</a>。</p><h4 id="参考资料">参考资料</h4><p>[1] <a href="https://mp.weixin.qq.com/s?__biz=MzI0NDYzMzg0OQ==&amp;mid=2247483683&amp;idx=1&amp;sn=1cceed0d62a5fbfcc373d5ec45370ed9&amp;chksm=e95b98b5de2c11a37c180d231633245e94c9ede239dbdfcca769afe09f1461e6d995c81241ec#rd作者：唐码农链接：https://www.jianshu.com/p/f88b6a9f7462来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。">Android 5.0以上通过UsageStatsManager类 获取应用使用情况（精品） (qq.com)</a></p><p>[2] <a href="https://blog.csdn.net/liuwan1992/article/details/83625520">关于 UsageStatsManager.queryUsageStats 的注意事项及 UsageStatsService 的简单原理_菜鸟的自我修养-CSDN博客</a></p><p>[3] <a href="https://blog.csdn.net/github_37271067/article/details/85292543">android统计手机应用使用时长以及开启次数_github_37271067的博客-CSDN博客</a></p><p>[4] <a href="https://developer.android.com/reference">Google Developers</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实用的搜索引擎技巧-写论文实用技巧</title>
      <link href="/hexo_zh/2021/05/20/other/shi-yong-de-sou-suo-yin-qing-ji-qiao-xie-lun-wen-shi-yong-ji-qiao/"/>
      <url>/hexo_zh/2021/05/20/other/shi-yong-de-sou-suo-yin-qing-ji-qiao-xie-lun-wen-shi-yong-ji-qiao/</url>
      
        <content type="html"><![CDATA[<p>我们平时在使用搜索引擎的时候，或许都是直接搜索我们想问的问题，比如：“为什么……？” ……是什么？“，这样子搜索出来的东西可能内容并不是我们想要的内容。实际上，有很多不为人知的搜索小技巧，利用这些小技巧，我们可以很容易的达到我们的搜索目的。</p><span id="more"></span><h4 id="技巧1排除关键词">技巧1：排除关键词</h4><p>减号 + 关键词： 排除不想要的关键词</p><p>这个技巧可以用在我们遇到了很多干扰项，比如说搜索“锤子”，我们搜索到的很大一部分都是锤子手机，但是我们只想要搜索原始的”敲敲敲“的锤子，那么我们可以搜索：<em>锤子 - 锤子手机</em>，这个时候搜索出来的结果就没有锤子手机的相关信息了。</p><h4 id="技巧2精确搜索">技巧2：精确搜索</h4><p>给关键词加引号，实现精确搜索，搜索出来的结果必须包含非常精确的引号里面的内容，多字，少字，拆开来都是不行的。</p><p>这个技巧和上面的技巧一样，同样是可以用来帮助我们排除掉很多干扰项。</p><h4 id="技巧3指定网站内搜索">技巧3：指定网站内搜索</h4><p>site: 域名 + 关键词：在指定网站内搜索。</p><p>比如说如果想在CSDN中搜索C/C++，那么就可以在搜索框中搜索<code>site: csdn.com C/C++</code>，搜索出来的就都是CSDN上的博客了。</p><h4 id="技巧4指定文件格式搜索">技巧4：指定文件格式搜索</h4><p>filetype: 文件格式 + 关键词。</p><p>利用这个技巧可以搜索到对应的文件格式的文件，非常方便。如果我们想要查找一些官方的文档（pdf）格式的，我们一般直接搜索很难找到对应的文件，如果我们直接指定文件格式为<code>pdf</code>，那么说不定就可以很轻而易举的搜索到了。</p><h4 id="技巧5指定标题搜索">技巧5：指定标题搜索</h4><p>intitle + 关键词：指定搜索的关键词必须出现在搜索结果的标题之中。</p><h4 id="其他技巧">其他技巧</h4><p>intext: 关键词：在正文中包含关键词。</p><p>allintext: 多个关键词：所有的关键词都必须包含在搜索结果的正文里。</p><p>inurl: 关键词：搜索结果的url中必须包含关键词字符串。</p><p>最后，以上技巧可以进行叠加使用，综合使用来达到自己想要的效果，搜索的效率会大大加倍。</p><h4 id="参考资料">参考资料</h4><p><a href="https://www.zhihu.com/zvideo/1347196958008889344">搜索效率提升200%！8个小技巧助你快速查资料，妈妈再也不担心我的学习了(蜡笔与小勋)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言哈希表uthash的使用</title>
      <link href="/hexo_zh/2021/05/16/algorithms/c-yu-yan-ha-xi-biao-uthash-de-shi-yong/"/>
      <url>/hexo_zh/2021/05/16/algorithms/c-yu-yan-ha-xi-biao-uthash-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>C语言的标准库中没有哈希表的函数可以使用，但是可以通过第三方头文件<code>uthash.h</code>这个包来实现哈希表的操作。首先，想要使用这个包，可以访问它的github网站 https://github.com/troydhanson/uthash 下载<code>uthash.h</code>文件。</p><span id="more"></span><h2 id="使用说明">使用说明</h2><p>在你的程序中，首先需要定义一个结构体 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;uthash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;                    <span class="comment">/* key */</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    UT_hash_handle hh;         <span class="comment">/* makes this structure hashable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 需要注意的是，当你添加一个结构体变量到哈希表中时，这个结构体不会被复制或者移动到其他地址，所以你还是可以在程序的生命周期中安全的指向这个结构体变量的地址。 每一个这样的结构体由一个id(被当作键值使用)，一个要储存的变量，和一个<code>UT_hash_handle</code>变量。<code>UT_hash_handle</code>是非常重要的变量，它是这个结构体能够实现哈希表操作的关键。</p><p>然后需要定义一个全局的<code>my_struct</code>变量 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">users</span> =</span> <span class="literal">NULL</span> <span class="comment">/* important! initialize to NULL */</span></span><br></pre></td></tr></table></figure></p><h4 id="添加元素">添加元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_user</span><span class="params">(<span class="keyword">int</span> user_id, <span class="keyword">char</span> *name)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">s</span>;</span></span><br><span class="line">    HASH_FIND_INT(users, &amp;user_id, s);  <span class="comment">/* id already in the hash? */</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      s = (struct my_struct *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *s);</span><br><span class="line">      s-&gt;id = user_id;</span><br><span class="line">      HASH_ADD_INT(users, id, s);  <span class="comment">/* id: name of key field */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(s-&gt;name, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过<code>HASH_FIND_INT</code>首先确定当前id的唯一性，然后再通过<code>HASH_ADD_INT</code>添加元素。如果当前元素已经存在，那么修改它储存的元素值。</p><h4 id="查找元素">查找元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct my_struct *<span class="title">find_user</span><span class="params">(<span class="keyword">int</span> user_id)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    HASH_FIND_INT(users, &amp;user_id, s);  <span class="comment">/* s: output pointer */</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除元素">删除元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_user</span><span class="params">(struct my_struct *user)</span> </span>&#123;</span><br><span class="line">    HASH_DEL(users, user);  <span class="comment">/* user: pointer to deletee */</span></span><br><span class="line">    <span class="built_in">free</span>(user);             <span class="comment">/* optional; it&#x27;s up to you! */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="清空表">清空表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_all</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">current_user</span>, *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">  HASH_ITER(hh, users, current_user, tmp) &#123;</span><br><span class="line">    HASH_DEL(users, current_user);  <span class="comment">/* delete; users advances to next */</span></span><br><span class="line">    <span class="built_in">free</span>(current_user);             <span class="comment">/* optional- if you want to free  */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算元素个数">计算元素个数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> num_users;</span><br><span class="line">num_users = HASH_COUNT(users);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;there are %u users\n&quot;</span>, num_users);</span><br></pre></td></tr></table></figure><h4 id="遍历打印所有元素">遍历打印所有元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_users</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (s = users; s != <span class="literal">NULL</span>; s = s-&gt;hh.next) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;user id %d: name %s\n&quot;</span>, s-&gt;id, s-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="排序">排序</h4><ol type="1"><li>通过id排序 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">name_sort</span><span class="params">(struct my_struct *a, struct my_struct *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(a-&gt;name, b-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_by_name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HASH_SORT(users, name_sort);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>通过键值排序 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id_sort</span><span class="params">(struct my_struct *a, struct my_struct *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a-&gt;id - b-&gt;id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_by_id</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HASH_SORT(users, id_sort);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="完整的例子">完整的例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>   <span class="comment">/* gets */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>  <span class="comment">/* atoi, malloc */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>  <span class="comment">/* strcpy */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;uthash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;                    <span class="comment">/* key */</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    UT_hash_handle hh;         <span class="comment">/* makes this structure hashable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">users</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_user</span><span class="params">(<span class="keyword">int</span> user_id, <span class="keyword">char</span> *name)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    HASH_FIND_INT(users, &amp;user_id, s);  <span class="comment">/* id already in the hash? */</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      s = (struct my_struct *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *s);</span><br><span class="line">      s-&gt;id = user_id;</span><br><span class="line">      HASH_ADD_INT(users, id, s);  <span class="comment">/* id: name of key field */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(s-&gt;name, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct my_struct *<span class="title">find_user</span><span class="params">(<span class="keyword">int</span> user_id)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    HASH_FIND_INT(users, &amp;user_id, s);  <span class="comment">/* s: output pointer */</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_user</span><span class="params">(struct my_struct *user)</span> </span>&#123;</span><br><span class="line">    HASH_DEL(users, user);  <span class="comment">/* user: pointer to deletee */</span></span><br><span class="line">    <span class="built_in">free</span>(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_all</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">current_user</span>, *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">  HASH_ITER(hh, users, current_user, tmp) &#123;</span><br><span class="line">    HASH_DEL(users, current_user);  <span class="comment">/* delete it (users advances to next) */</span></span><br><span class="line">    <span class="built_in">free</span>(current_user);             <span class="comment">/* free it */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_users</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (s = users; s != <span class="literal">NULL</span>; s = (struct my_struct*)(s-&gt;hh.next)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;user id %d: name %s\n&quot;</span>, s-&gt;id, s-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">name_sort</span><span class="params">(struct my_struct *a, struct my_struct *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(a-&gt;name, b-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id_sort</span><span class="params">(struct my_struct *a, struct my_struct *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a-&gt;id - b-&gt;id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_by_name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HASH_SORT(users, name_sort);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_by_id</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HASH_SORT(users, id_sort);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> in[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">1</span>, running = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">s</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> num_users;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 1. add user\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 2. add/rename user by id\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 3. find user\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 4. delete user\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 5. delete all users\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 6. sort items by name\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 7. sort items by id\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 8. print users\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 9. count users\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;10. quit\n&quot;</span>);</span><br><span class="line">        gets(in);</span><br><span class="line">        <span class="keyword">switch</span>(atoi(in)) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;name?\n&quot;</span>);</span><br><span class="line">                add_user(id++, gets(in));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;id?\n&quot;</span>);</span><br><span class="line">                gets(in); id = atoi(in);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;name?\n&quot;</span>);</span><br><span class="line">                add_user(id, gets(in));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;id?\n&quot;</span>);</span><br><span class="line">                s = find_user(atoi(gets(in)));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;user: %s\n&quot;</span>, s ? s-&gt;name : <span class="string">&quot;unknown&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;id?\n&quot;</span>);</span><br><span class="line">                s = find_user(atoi(gets(in)));</span><br><span class="line">                <span class="keyword">if</span> (s) delete_user(s);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;id unknown\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                delete_all();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                sort_by_name();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                sort_by_id();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                print_users();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                num_users = HASH_COUNT(users);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;there are %u users\n&quot;</span>, num_users);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">                running = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete_all();  <span class="comment">/* free any structures */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><p><a href="https://troydhanson.github.io/uthash/userguide.html">uthash用户使用指南</a> <a href="https://www.cnblogs.com/dongxb/p/14212531.html">uthash简介</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>421.数组中两个数的最大异或值</title>
      <link href="/hexo_zh/2021/05/16/leetcode/421-shu-zu-zhong-liang-ge-shu-de-zui-da-yi-huo-zhi/"/>
      <url>/hexo_zh/2021/05/16/leetcode/421-shu-zu-zhong-liang-ge-shu-de-zui-da-yi-huo-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>给你一个整数数组 <code>nums</code> ，返回 <code>nums[i]</code> XOR <code>nums[j]</code> 的最大运算结果，其中 <code>0 ≤ i ≤ j &lt; n</code> 。 - 要求在<code>O(n)</code>时间内解决这个问题 - 限制：<code>1 &lt;= nums.length &lt;= 2 * 10^4</code> <code>0 &lt;= nums[i] &lt;= 2^31 - 1</code></p><span id="more"></span><h2 id="题解">题解</h2><p>异或运算的真值表如下 (相同为0，不同为1)，又称为不进位加法：</p><figure><img src="https://i.loli.net/2021/05/16/EYtfh6gJrATMFIQ.png" alt="图" /><figcaption aria-hidden="true">图</figcaption></figure><p>要找到最大的数，我们要尽量选择高位异或结果为“1”的，所以我们可以将nums中的数加入一个Trie中，然后每次贪心的进行匹配，找到可以使得当前位为1的节点。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Node[] node = <span class="keyword">new</span> Node[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node node = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        Node p = node;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (p.node[u] == <span class="keyword">null</span>) p.node[u] = <span class="keyword">new</span> Node(); </span><br><span class="line">            p = p.node[u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getVal</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        Node p = node;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = (x &gt;&gt; i) &amp; <span class="number">1</span>, b = <span class="number">1</span> - a;</span><br><span class="line">            <span class="keyword">if</span> (p.node[b] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ans |= (b &lt;&lt; i);</span><br><span class="line">                p = p.node[b];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans |= (a &lt;&lt; i);</span><br><span class="line">                p = p.node[a];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            add(i);</span><br><span class="line">            <span class="keyword">int</span> j = getVal(i);</span><br><span class="line">            ans = Math.max(ans, i ^ j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考资料">参考资料</h3><p><a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-bmjdg/">【宫水三叶の相信科学系列】详解为何能用「贪心」&amp;「Trie」找「最大异或结果」 - 数组中两个数的最大异或值 - 力扣（LeetCode） (leetcode-cn.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题 17.21. 直方图的水量</title>
      <link href="/hexo_zh/2021/04/26/leetcode/mian-shi-ti-17-21-zhi-fang-tu-de-shui-liang/"/>
      <url>/hexo_zh/2021/04/26/leetcode/mian-shi-ti-17-21-zhi-fang-tu-de-shui-liang/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><blockquote><p>给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。<img src="https://i.loli.net/2021/04/06/Yyt1qnaTPRZAIhQ.png" alt="LeetCode: 面试题17.21" /></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="题解">题解</h2><p>思路：当前位置能储存的水量取决于左右两边遇到的最大值中的最小值(min(leftTop, rightTop))。</p><p>方法：双指针。一个左指针，一个右指针。左指针小于右指针，当前位置可以存水，大小为leftTop-left，然后右移左指针，更新leftTop。同理，右指针小于左指针，当前位置可以存储rightTop-right的水量，左移右指针，更新rightTop。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>* height, <span class="keyword">int</span> heightSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (heightSize &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// 大小不足3，必定不能存水</span></span><br><span class="line">    <span class="keyword">int</span> lefttop = <span class="number">0</span>, righttop = heightSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lefttop+<span class="number">1</span> &lt; heightSize &amp;&amp; height[lefttop+<span class="number">1</span>] &gt;= height[lefttop]) lefttop++;</span><br><span class="line">    <span class="keyword">while</span>(righttop - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; height[righttop<span class="number">-1</span>] &gt;= height[righttop]) righttop--;</span><br><span class="line">    <span class="keyword">int</span> left = lefttop, right = righttop, capacity = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt;= height[right]) &#123;</span><br><span class="line">            capacity += height[lefttop] - height[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span> (height[left] &gt; height[lefttop]) lefttop = left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (height[left] &gt; height[right]) &#123;</span><br><span class="line">            capacity += height[righttop] - height[right];</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">if</span> (height[right] &gt; height[righttop]) righttop = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> capacity;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>71. 简化路径</title>
      <link href="/hexo_zh/2021/04/08/leetcode/71-jian-hua-lu-jing/"/>
      <url>/hexo_zh/2021/04/08/leetcode/71-jian-hua-lu-jing/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><blockquote><p>给你一个字符串 path ，表示指向某一文件或目录的Unix 风格绝对路径（以 '/' 开头，请你将其转化为更加简洁的规范路径。</p><p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，'//'）都被视为单个斜杠 '/' 。 对于此问题，任何其他格式的点（例如，'...'）均被视为文件/目录名称。</p><p>请注意，返回的 规范路径 必须遵循下述格式：</p><p>始终以斜杠 '/' 开头。 两个目录名之间必须只有一个斜杠 '/' 。 最后一个目录名（如果存在）不能 以 '/' 结尾。 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 '.' 或 '..'）。 返回简化后得到的 规范路径 。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：path = &quot;/home/&quot;</span><br><span class="line">输出：&quot;/home&quot;</span><br><span class="line">解释：注意，最后一个目录名后面没有斜杠。 </span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：path = &quot;/../&quot;</span><br><span class="line">输出：&quot;/&quot;</span><br><span class="line">解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：path = &quot;/home//foo/&quot;</span><br><span class="line">输出：&quot;/home/foo&quot;</span><br><span class="line">解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：path = &quot;/a/./b/../../c/&quot;</span><br><span class="line">输出：&quot;/c&quot; </span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= path.length &lt;= 3000</p><ul><li>path 由英文字母，数字，'.'，'/' 或 '_' 组成。</li><li>path 是一个有效的 Unix 风格绝对路径。</li></ul></blockquote><h2 id="题解">题解</h2><p>利用栈，分各种情况讨论。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">simplifyPath</span><span class="params">(<span class="keyword">char</span> * path)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(path);</span><br><span class="line">    <span class="keyword">if</span> (path == <span class="literal">NULL</span> || len == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> * simPath = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (len + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (simPath == <span class="literal">NULL</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;Error\n&quot;</span>); <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>, numOfDots = <span class="number">0</span>, isDir = <span class="number">0</span>;      <span class="comment">// 栈顶下标，&#x27;.&#x27;的数量，当前输入字符是否为路径</span></span><br><span class="line">    <span class="keyword">if</span> (path[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;Invalid Input\n&quot;</span>); <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">    simPath[<span class="number">0</span>] = path[<span class="number">0</span>];                       <span class="comment">// 第一位为&#x27;/&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (path[i] == <span class="string">&#x27;.&#x27;</span>) &#123;                   <span class="comment">// 当前字符为&#x27;.&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> (!isDir) numOfDots++;            <span class="comment">// 若当前字符不是路径，&#x27;.&#x27;的数量增加1</span></span><br><span class="line">            simPath[++top] = <span class="string">&#x27;.&#x27;</span>;               <span class="comment">// &#x27;.&#x27;入栈</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                                <span class="comment">// 当前字符不为&#x27;.&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> (path[i] != <span class="string">&#x27;/&#x27;</span>) &#123;               <span class="comment">// 当前字符不为&#x27;/&#x27;</span></span><br><span class="line">                numOfDots = <span class="number">0</span>;                  <span class="comment">// 当前输入为路径，所以&#x27;.&#x27;的数量更新为0</span></span><br><span class="line">                isDir = <span class="number">1</span>;                      <span class="comment">// 当前输入为路径</span></span><br><span class="line">                simPath[++top] = path[i];       <span class="comment">// 当前路径字符入栈</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numOfDots == <span class="number">1</span>) &#123;        <span class="comment">// 栈顶为&#x27;.&#x27;</span></span><br><span class="line">                top -= <span class="number">2</span>;                       <span class="comment">// &#x27;/.&#x27;出栈</span></span><br><span class="line">                <span class="keyword">if</span>(top == <span class="number">-1</span>)                   <span class="comment">// 碰到根目录</span></span><br><span class="line">                    simPath[++top] = <span class="string">&#x27;/&#x27;</span>;       <span class="comment">// &#x27;/&#x27;入栈</span></span><br><span class="line">                numOfDots = <span class="number">0</span>;                  <span class="comment">// 重置&#x27;.&#x27;的数量</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numOfDots == <span class="number">2</span>) &#123;        <span class="comment">// 栈顶为&#x27;..&#x27;</span></span><br><span class="line">                top -= <span class="number">3</span>;                       <span class="comment">// 出栈&#x27;/..&#x27;</span></span><br><span class="line">                <span class="keyword">if</span>(top == <span class="number">-1</span>)                   <span class="comment">// 碰到根目录</span></span><br><span class="line">                    simPath[++top] = <span class="string">&#x27;/&#x27;</span>;       <span class="comment">// &#x27;/&#x27;入栈</span></span><br><span class="line">                <span class="keyword">while</span>(top &gt;= <span class="number">0</span> &amp;&amp; simPath[top] != <span class="string">&#x27;/&#x27;</span>) top--;   <span class="comment">// 出栈直到遇到下一个&#x27;/&#x27;</span></span><br><span class="line">                numOfDots = <span class="number">0</span>;                  <span class="comment">// 重置&#x27;.&#x27;的数量</span></span><br><span class="line">            &#125;                          </span><br><span class="line">            <span class="keyword">if</span> (path[i] ==<span class="string">&#x27;/&#x27;</span> &amp;&amp; simPath[top] != <span class="string">&#x27;/&#x27;</span>)&#123;<span class="comment">// 当前字符为&#x27;/&#x27;</span></span><br><span class="line">                simPath[++top] = path[i];       <span class="comment">// 栈顶不是&#x27;/&#x27;，入栈&#x27;/&#x27;</span></span><br><span class="line">                isDir = <span class="number">0</span>;                      <span class="comment">// 当前输入非路径文件名称</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (numOfDots == <span class="number">1</span>) top -= <span class="number">2</span>;               <span class="comment">// 处理&#x27;.&#x27;没有被处理的情况</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (numOfDots == <span class="number">2</span>) &#123;</span><br><span class="line">        top -= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span>(top &gt;= <span class="number">0</span> &amp;&amp; simPath[top] != <span class="string">&#x27;/&#x27;</span>) top--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">-1</span>) simPath[++top] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (top &gt; <span class="number">0</span> &amp;&amp; simPath[top] == <span class="string">&#x27;/&#x27;</span>)  top--; <span class="comment">// 最后一个字符为&#x27;/&#x27;      </span></span><br><span class="line">    simPath[++top] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> simPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>81. 搜索旋转排序数组II</title>
      <link href="/hexo_zh/2021/04/07/leetcode/81-sou-suo-xuan-zhuan-pai-xu-shu-zu-ii/"/>
      <url>/hexo_zh/2021/04/07/leetcode/81-sou-suo-xuan-zhuan-pai-xu-shu-zu-ii/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><blockquote><p>已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。</p><p>给你旋转后的数组nums和一个整数target，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target，则返回 true，否则返回 false。</p><span id="more"></span><p>示例 1：</p><p>输入：nums = [2,5,6,0,0,1,2], target = 0 输出：true 示例 2：</p><p>输入：nums = [2,5,6,0,0,1,2], target = 3 输出：false</p><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 5000</li><li>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></li><li>题目数据保证 nums 在预先未知的某个下标上进行了旋转</li><li>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></li></ul></blockquote><h2 id="题解">题解</h2><p>思路：利用到数组是排序过的性质，我们可以采用二分法。由于数组是进行旋转过的排序数组所以如果nums[i]&gt;nums[j]，那么i和j一定是处于旋转的下标的两侧的。定义左指针l，右指针r，中间指针mid。</p><ul><li>第一种情况：nums[l]&lt;=nums[mid]。说明l和mid都在旋转下标的左侧（这里有特殊情况待会讨论），如果此时tar在l和mid的中间，那么右指针更新为mid-1；否则，说明在mid和r中间，左指针更新为mid+1。</li><li>第二种情况：nums[l]&gt;nums[mid]。说明l和mid在旋转下标的不同侧，也就是mid和r都在旋转下标的右侧，如果此时tar在mid和r中间，那么左指针更新为mid+1；否则，右指针更新为mid-1。</li><li>特殊情况：考虑相等的情况，如果nums[l]=nums[mid]，我们不一定能保证l和mid在同一侧，因为如果l和r不能保证不相等，如果三者都相等，那么完全可能mid和r都在右侧。对于这种情况，我们排除掉当前l和r，同时向中间移动一位。</li><li>分析：在最坏情况下，数组的所有元素都相同，那么就完全没有用到二分法，时间复杂度为O(n)，空间复杂度为O(1)。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">0</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = numsSize - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[l] == nums[mid] &amp;&amp; nums[mid] == nums[r]) &#123;</span><br><span class="line">            ++l;</span><br><span class="line">            --r;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[l] &lt;= nums[mid]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[numsSize - <span class="number">1</span>]) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说来滑稽，由于这个数组的大小不大，如果采用暴力解法，直接遍历搜索简单明了，得出的结果也还不错,甚至比采用二分法的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) <span class="keyword">if</span> (nums[i] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>二分法：</p><p>执行用时：8 ms, 在所有 C 提交中击败了55.63%的用户</p><p>内存消耗：5.7 MB, 在所有 C 提交中击败了99.68%的用户</p><p>暴力法：</p><p>执行用时：4 ms, 在所有 C 提交中击败了93.57%的用户</p><p>内存消耗：5.8 MB, 在所有 C 提交中击败了84.89%的用户</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>80. 删除有序数组中的重复项II</title>
      <link href="/hexo_zh/2021/04/06/leetcode/80-shan-chu-you-xu-shu-zu-zhong-de-chong-fu-xiang-ii/"/>
      <url>/hexo_zh/2021/04/06/leetcode/80-shan-chu-you-xu-shu-zu-zhong-de-chong-fu-xiang-ii/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><blockquote><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><span id="more"></span><p>说明：</p><p>为什么返回数值是整数，但输出的答案是数组呢？</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><p>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums);</p><p>// 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i &lt; len; i++) { print(nums[i]); }</p><p>示例 1：</p><p>输入：nums = [1,1,1,2,2,3] 输出：5, nums = [1,1,2,2,3] 解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。 示例 2：</p><p>输入：nums = [0,0,1,1,1,1,2,3,3] 输出：7, nums = [0,0,1,1,2,3,3] 解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。</p><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 3 * 104</li><li>-104 &lt;= nums[i] &lt;= 104</li><li>nums 已按升序排列</li></ul></blockquote><h2 id="题解">题解</h2><p>由于这道题数组已经是有序数组，所以很容易想到使用双指针。一个指针从头到尾遍历数组，另一个指针指向当前需要修改的位置。当前数字出现次数如果超过2，那么当前位置不需要修改；未超过2，更改当前需要更改的位置；若当前数字发生变化，更新出现次数和当前位置。时间复杂度O(n)，空间复杂度O(1)，和题目要求一致。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> currNum = nums[<span class="number">0</span>], freq = <span class="number">1</span>, i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (currNum == nums[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++freq &lt;= <span class="number">2</span>) nums[++len] = nums[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currNum = nums[i];</span><br><span class="line">            freq = <span class="number">1</span>;</span><br><span class="line">            nums[++len] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上方法还可以进行改进。如果原本的数组长度小于等于2，最多就两个元素，不需要更改。此外，这种方法我们需要一个额外的变量来计算元素出现的次数，实际上我们已经知道一个数字最多出现两次，所以如果当前访问位置和需要修改的当前位置前两个位置相同的话，那么说明当前的数字已经出现了多次，则直接移动到下一位置即可；否则需要修改的位置修改为当前遍历到的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt;= <span class="number">2</span>) <span class="keyword">return</span> numsSize;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">2</span>, curr = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (; curr &lt; numsSize; curr++)</span><br><span class="line">        <span class="keyword">if</span> (nums[len<span class="number">-2</span>] != nums[curr])</span><br><span class="line">            nums[len++] = nums[curr];</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5706. 句子相似性III（第49场双周赛）</title>
      <link href="/hexo_zh/2021/04/04/leetcode/5706-ju-zi-xiang-si-xing-iii/"/>
      <url>/hexo_zh/2021/04/04/leetcode/5706-ju-zi-xiang-si-xing-iii/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><blockquote><p>一个句子是由一些单词与它们之间的单个空格组成，且句子的开头和结尾没有多余空格。比方说，<code>"Hello World"</code> ，<code>"HELLO"</code> ，<code>"hello world hello world"</code> 都是句子。每个单词都 <strong>只</strong> 包含大写和小写英文字母。</p><p>如果两个句子 <code>sentence1</code> 和 <code>sentence2</code> ，可以通过往其中一个句子插入一个任意的句子（<strong>可以是空句子</strong>）而得到另一个句子，那么我们称这两个句子是 <strong>相似的</strong> 。比方说，<code>sentence1 = "Hello my name is Jane"</code> 且 <code>sentence2 = "Hello Jane"</code> ，我们可以往 <code>sentence2</code> 中 <code>"Hello"</code> 和 <code>"Jane"</code> 之间插入 <code>"my name is"</code> 得到 <code>sentence1</code> 。</p><p>给你两个句子 <code>sentence1</code> 和 <code>sentence2</code> ，如果 <code>sentence1</code> 和 <code>sentence2</code> 是相似的，请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：sentence1 = &quot;My name is Haley&quot;, sentence2 = &quot;My Haley&quot;</span><br><span class="line">&gt;输出：true</span><br><span class="line">&gt;解释：可以往 sentence2 中 &quot;My&quot; 和 &quot;Haley&quot; 之间插入 &quot;name is&quot; ，得到 sentence1 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：sentence1 = &quot;of&quot;, sentence2 = &quot;A lot of words&quot;</span><br><span class="line">&gt;输出：false</span><br><span class="line">&gt;解释：没法往这两个句子中的一个句子只插入一个句子就得到另一个句子。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：sentence1 = &quot;Eating right now&quot;, sentence2 = &quot;Eating&quot;</span><br><span class="line">&gt;输出：true</span><br><span class="line">&gt;解释：可以往 sentence2 的结尾插入 &quot;right now&quot; 得到 sentence1 。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：sentence1 = &quot;Luky&quot;, sentence2 = &quot;Lucccky&quot;</span><br><span class="line">&gt;输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= sentence1.length, sentence2.length &lt;= 100</code></li><li><code>sentence1</code> 和 <code>sentence2</code> 都只包含大小写英文字母和空格。</li><li><code>sentence1</code> 和 <code>sentence2</code> 中的单词都只由单个空格隔开。</li></ul></blockquote><h2 id="题解">题解</h2><p>本题我采用了动态规划的思路。果然还是很不熟练，找状态转移方程想了好久，想出来的还是感觉很笨的办法，果然还是得加强练习。</p><p>思路：<code>dp[i, j]</code>表示sentence1的前i个和sentence2的前j个word能否经过一次插入获得。分别考虑两个句子当前的word是否是可以插入另一个sentence获得相同的sentence。情况如下：</p><ol type="1"><li>如果sentence1前<code>i-1</code>个word和sentence2前j个word可以通过一次插入相等，并且之前插入的word在sentence1中并且还可以继续插入，那么就可以继续在sentence1中插入，我们记为1。</li><li>如果sentence1前i个word和sentence2前j-1个word可以通过一次插入相等，并且之前插入的word在sentence2中并且还可以继续插入，那么就可以继续在sentence2中插入，我们记为2。</li><li>以上两种情况都不符合，如果sentence1第i个word和sentence2第j个word一致，那么我们只需要考虑sentence1前i-1个word和sentence2前j-1个word是否可以通过一次插入相等。如果之前是在继续插入的，那么我们现在就要终止插入，记为3，否则dp[i, j]=dp[i-1, j-1]。（这里我们已经排除了虽然当前word相等但是可以把当前的word当成插入的情况：比如sentence1=”a b c“, sentence2="a b g b c"中sentence2中的"g b"是插入的，而sentence1 中也存在b）</li><li>剩下的情况就是我们无法插入一个sentence使两组sentence相等，记为4</li></ol><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先将sentence转化为word数组</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>** <span class="title">sentenceToWord</span><span class="params">(<span class="keyword">char</span> * sentence, <span class="keyword">int</span> *wordlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sen_len = <span class="built_in">strlen</span>(sentence);</span><br><span class="line">    <span class="keyword">if</span> (sen_len == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span>** word = (<span class="keyword">char</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*) * sen_len);</span><br><span class="line">    <span class="keyword">int</span> wordIdx = <span class="number">0</span>, i = <span class="number">0</span>, charIdx = <span class="number">0</span>;</span><br><span class="line">    word[wordIdx] = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (sen_len+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; sen_len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sentence[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            word[wordIdx][charIdx] = <span class="string">&#x27;\0&#x27;</span>; </span><br><span class="line">            word[++wordIdx] = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * sen_len);</span><br><span class="line">            charIdx = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            word[wordIdx][charIdx++] = sentence[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    word[wordIdx][charIdx] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    *wordlen = wordIdx + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> word;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">areSentencesSimilar</span><span class="params">(<span class="keyword">char</span> * sentence1, <span class="keyword">char</span> * sentence2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1, len2;</span><br><span class="line">    <span class="keyword">char</span>** word1 = sentenceToWord(sentence1, &amp;len1);</span><br><span class="line">    <span class="keyword">char</span>** word2 = sentenceToWord(sentence2, &amp;len2);</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> ** dp = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * (len1+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= len1; i++) dp[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (len2 + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 0代表还没有插入</span></span><br><span class="line">    <span class="comment">// 1代表i正在插入</span></span><br><span class="line">    <span class="comment">// 2代表j正在插入</span></span><br><span class="line">    <span class="comment">// 3代表已经插入</span></span><br><span class="line">    <span class="comment">// 4代表无法插入</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= len1; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= len2; i++) dp[<span class="number">0</span>][i] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= len1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= len2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i<span class="number">-1</span>][j] == <span class="number">1</span> || dp[i<span class="number">-1</span>][j] == <span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dp[i][j<span class="number">-1</span>] == <span class="number">2</span> || dp[i][j<span class="number">-1</span>] == <span class="number">0</span>) dp[i][j] = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(word1[i<span class="number">-1</span>], word2[j<span class="number">-1</span>])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i<span class="number">-1</span>][j<span class="number">-1</span>] == <span class="number">1</span> || dp[i<span class="number">-1</span>][j<span class="number">-1</span>] == <span class="number">2</span>) dp[i][j] = <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2] != <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11. 盛最多水的容器</title>
      <link href="/hexo_zh/2021/04/03/leetcode/11-sheng-zui-duo-shui-de-rong-qi/"/>
      <url>/hexo_zh/2021/04/03/leetcode/11-sheng-zui-duo-shui-de-rong-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><blockquote><p>给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器。</p><span id="more"></span><p>示例 1：</p><figure><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>输入：[1,8,6,2,5,4,8,3,7] 输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p>示例 2：</p><p>输入：height = [1,1] 输出：1</p><p>示例 3：</p><p>输入：height = [4,3,2,1,4] 输出：16</p><p>示例 4：</p><p>输入：height = [1,2,1] 输出：2</p><p>提示：</p><ul><li>n = height.length</li><li>2 &lt;= n &lt;= 3 * 104</li><li>0 &lt;= height[i] &lt;= 3 * 104</li></ul></blockquote><h2 id="解法双指针">解法：双指针</h2><p>定义两个左右指针，获取其中较小的指针，将较小指针向中间移动，重新获取两个指针中的较小者，然后比较当前区域大小与移动后区域大小并进行赋值。重复以上操作直到两个指针相遇。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span> *height, <span class="keyword">int</span> heightSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (heightSize == <span class="number">0</span> &amp;&amp; heightSize == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = heightSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> min = height[left] &lt; height[right] ? left : right;</span><br><span class="line">    <span class="keyword">int</span> area = height[min] * (right - left);</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (min &lt;= left ) left++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (min &gt;= right ) right--;</span><br><span class="line">        min = height[left] &lt; height[right] ? left : right;</span><br><span class="line">        <span class="keyword">if</span> (area &lt; height[min] * (right - left))</span><br><span class="line">            area = height[min] * (right - left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器 - 力扣（LeetCode） (leetcode-cn.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1143. 最长公共子序列</title>
      <link href="/hexo_zh/2021/04/03/leetcode/1143-zui-chang-gong-gong-zi-xu-lie/"/>
      <url>/hexo_zh/2021/04/03/leetcode/1143-zui-chang-gong-gong-zi-xu-lie/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><blockquote><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列 的长度。如果不存在公共子序列 ，返回 0 。</p><p>一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><span id="more"></span><p>示例 1：</p><p>输入：text1 = "abcde", text2 = "ace" 输出：3<br />解释：最长公共子序列是 "ace" ，它的长度为 3 。 示例 2：</p><p>输入：text1 = "abc", text2 = "abc" 输出：3 解释：最长公共子序列是 "abc" ，它的长度为 3 。 示例 3：</p><p>输入：text1 = "abc", text2 = "def" 输出：0 解释：两个字符串没有公共子序列，返回 0 。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li><li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li></ul></blockquote><h2 id="题解">题解</h2><p>经典的动态规划。dp[i][j]表示text1的前i个字符和text2的前j个字符的最长公共子序列个数。当我们移动到(i, j)这个位置的时候，分为以下两种情况：</p><ul><li>text1[i] == text2[j]。此时dp[i][j]=dp[i-1][j-1]+1;</li><li>text1[i] != text2[j]。此时dp[i][j]=max(dp[i-1][j], dp[i][j-1])</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 动态规划 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="keyword">char</span> * text1, <span class="keyword">char</span> * text2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(text1), len2 = <span class="built_in">strlen</span>(text2);</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= len1; i++) dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= len2; i++) dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= len1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= len2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] &gt; dp[i][j<span class="number">-1</span>] ? dp[i<span class="number">-1</span>][j] : dp[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意">注意</h2><ul><li>在代码中尽量不要使用分配内存的方法，内存消耗明显增加。</li><li>调用函数也会增加运行的时间，如果定义max函数，运行时间会变长。</li><li>初始化dp表的时候，可以简单通过<code>int dp[1000][1000] = &#123;0&#125;;</code>来进行初始化，但是这样会初始化一些不需要初始化的位置，运行时间会增加。所以只需要通过遍历初始化第一行和第一列即可。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10. 正则表达式匹配</title>
      <link href="/hexo_zh/2021/04/01/leetcode/10-zheng-ze-biao-da-shi-pi-pei/"/>
      <url>/hexo_zh/2021/04/01/leetcode/10-zheng-ze-biao-da-shi-pi-pei/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。</p><ul><li>'.' 匹配任意单个字符</li><li>'*' 匹配零个或多个前面的那一个元素。所谓匹配，是要涵盖整个字符串 s的，而不是部分字符串。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;aab&quot; p = &quot;c*a*b&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：因为 &#x27;*&#x27; 表示零个或多个，这里 &#x27;c&#x27;为 0 个, &#x27;a&#x27;被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="题解">题解</h2><blockquote><h3 id="解析">解析</h3><p>使用动态规划的方法进行解题，分为两种情况：首先是非*的情况，这种情况下我们需要考虑s和p当前字符是否匹配，很容易得出状态转移方程。然后是p为*，也可以分为两种情况，一种是s的当前字符与p的前一个字符不匹配，那么*就匹配一个字符，另一种是s的当前字符可以和p的前一个字符进行匹配，说明*可以匹配多个字符，两种情况</p><ul><li>匹配 s 末尾的一个字符，将该字符扔掉，而该组合还可以继续进行匹配；</li><li>不匹配字符，将该组合扔掉，不再进行匹配。</li></ul><figure><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/image-20220227143444739.png" alt="image-20220227143444739" /><figcaption aria-hidden="true">image-20220227143444739</figcaption></figure></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">charMatch</span><span class="params">(<span class="keyword">char</span> s, <span class="keyword">char</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="string">&#x27;.&#x27;</span> || s == p) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用方法：动态规划 */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="keyword">char</span> * s, <span class="keyword">char</span> * p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> height = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> width = <span class="built_in">strlen</span>(p);</span><br><span class="line">    <span class="keyword">bool</span>** table = (<span class="keyword">bool</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">bool</span>*) * (height+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (table == <span class="literal">NULL</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;Error\n&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= height; i++) &#123;</span><br><span class="line">        table[i] = (<span class="keyword">bool</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">bool</span>) * (width+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (table[i] == <span class="literal">NULL</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;Error\n&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    table[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= height; i++) table[i][<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= width; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; i &gt;= <span class="number">2</span>) table[<span class="number">0</span>][i] = table[<span class="number">0</span>][i<span class="number">-2</span>];</span><br><span class="line">        <span class="keyword">else</span> table[<span class="number">0</span>][i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= height; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= width; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= <span class="number">2</span> &amp;&amp; p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span> ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (charMatch(s[i<span class="number">-1</span>], p[j<span class="number">-2</span>]))</span><br><span class="line">                    table[i][j] = table[i<span class="number">-1</span>][j] || table[i][j<span class="number">-2</span>];</span><br><span class="line">                <span class="keyword">else</span> table[i][j] = table[i][j<span class="number">-2</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (charMatch(s[i<span class="number">-1</span>], p[j<span class="number">-1</span>])) &#123;</span><br><span class="line">                table[i][j] = table[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                table[i][j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table[height][width];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来源：<a href="https://leetcode-cn.com/problems/regular-expression-matching/">LeetCode-10</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python绘制正态分布图像</title>
      <link href="/hexo_zh/2021/03/31/computervision/python-hui-zhi-zheng-tai-fen-bu-tu-xiang/"/>
      <url>/hexo_zh/2021/03/31/computervision/python-hui-zhi-zheng-tai-fen-bu-tu-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="正态分布">正态分布</h2><p>公式：<span class="math inline">\(f(x)=\frac{1}{\sqrt{2\pi \sigma^2}}e^{-\frac{(x-\mu)^2}{2\sigma^2}}\)</span></p><span id="more"></span><h2 id="python代码">Python代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义正态分布函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normal_distribution</span>(<span class="params">x, mu, sigma</span>):</span></span><br><span class="line">    <span class="keyword">return</span> np.exp( -<span class="number">1</span> * ( (x-mu) ** <span class="number">2</span>) / ( <span class="number">2</span> * (sigma ** <span class="number">2</span>)) ) / (math.sqrt( <span class="number">2</span> * np.pi ) * sigma)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化mu, sigma</span></span><br><span class="line">mu, sigma = <span class="number">160</span>, <span class="number">8.65</span></span><br><span class="line">x = np.linspace( mu - <span class="number">6</span> * sigma, mu + <span class="number">6</span> * sigma, <span class="number">100</span>)</span><br><span class="line">y = normal_distribution(x, mu, sigma)</span><br><span class="line">plt.plot(x, y, <span class="string">&#x27;r&#x27;</span>, label=<span class="string">&#x27;mu = &#123;0&#125;,sigma = &#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(mu, sigma))</span><br><span class="line">plt.legend()</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="结果">结果</h2><figure><img src="https://i.loli.net/2021/03/31/2jYGPoVcq7Rh9AQ.png" alt="Figure_5" /><figcaption aria-hidden="true">Figure_5</figcaption></figure><h2 id="参考资料">参考资料</h2><p><a href="https://blog.csdn.net/lujianfeiccie2009/article/details/104213156">python绘制正态分布（高斯分布）</a></p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 概率论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>61. 旋转链表</title>
      <link href="/hexo_zh/2021/03/27/leetcode/61-xuan-zhuan-lian-biao/"/>
      <url>/hexo_zh/2021/03/27/leetcode/61-xuan-zhuan-lian-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动 <code>k</code> 个位置。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：head = [1,2,3,4,5], k = 2</span><br><span class="line">输出：[4,5,1,2,3]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：head = [0,1,2], k = 4</span><br><span class="line">输出：[2,0,1]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">链表中节点的数目在范围 [0, 500] 内</span><br><span class="line">-100 &lt;= Node.val &lt;= 100</span><br><span class="line">0 &lt;= k &lt;= 2 * 109</span><br></pre></td></tr></table></figure><h2 id="题解">题解</h2><p>本题不难，只需要找到newHead和newTail的位置，将原来的tail和原来的head连接，返回newHead就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">rotateRight</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// Exception: empty list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">preHead</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newHead</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newTail</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">preTail</span> =</span> head;</span><br><span class="line">    <span class="keyword">int</span> ListSize = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// get the total size of the list as well as the previous tail of the list</span></span><br><span class="line">    <span class="keyword">for</span> (; preTail-&gt;next != <span class="literal">NULL</span>; preTail = preTail-&gt;next, ListSize++);</span><br><span class="line">    k %= ListSize;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// get the new tail of the new list</span></span><br><span class="line">    <span class="comment">// new head of the list is the successor of the new tail</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ListSize - k - <span class="number">1</span>; i++, newTail = newTail-&gt;next);</span><br><span class="line">    newHead = newTail-&gt;next;</span><br><span class="line">    newTail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// connect the previous tail to the previous head;</span></span><br><span class="line">    preTail-&gt;next = preHead;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏概率模型</title>
      <link href="/hexo_zh/2020/12/26/other/you-xi-chou-qia-mo-xing-fen-xi/"/>
      <url>/hexo_zh/2020/12/26/other/you-xi-chou-qia-mo-xing-fen-xi/</url>
      
        <content type="html"><![CDATA[<p>目前的中国游戏市场，最热门的莫过于免费抽卡手游。游戏厂商为了盈利，设计出有不同规则的卡池，让玩家抽卡获取稀有的人物和武器。这一机制吸引了很多玩家，首先因为手游是免费的，入手门槛较低，其次很多人喜欢抽卡获取角色和武器的成就感。为了更吸引玩家，游戏策划就得设计出能够让大部分玩家，无论是欧皇还是非酋满意的抽卡机制。本文将简要分析目前游戏厂商可能使用的抽卡机制（仅属于个人猜想加一些网上的资料）。</p><span id="more"></span><h3 id="抽卡机制的大致分类">抽卡机制的大致分类</h3><ol type="1"><li>最简单的抽卡模型就是每次抽卡的概率都是固定的，也就是说每次抽卡的概率都是<span class="math inline">\(p\)</span>,我们可以称之为纯随机。那么玩家第<span class="math inline">\(n\)</span>次抽中的随机变量分布就是一个几何分布。这种抽卡模型很明显对于非酋非常不友好，理论上可能存在抽了很多很多次仍然没有抽中的人存在。所以纯随机模型在抽卡游戏中是不会使用的。</li><li>对应于纯随机的，我们可以称之为伪随机（注意这里的伪随机和计算机随机数概念中的伪随机不是一个东西）。伪随机就是说每次抽卡的概率都是是会进行改变的。下面就重点介绍几种可能的伪随机模型。</li></ol><h3 id="伪随机模型">伪随机模型</h3><ul><li><h4 id="十连保底">十连保底</h4><p>十连保底应该是我们在游戏中最常见到的概率模型。如果连抽十次，前九次都没有抽中的话，那么第十次就必定会抽中。这种概率模型会导致很多玩家都是依靠十连保底，并且概率质量函数图像会在第十次突然上升，显得不均匀。</p><p>例如，如果我们设定抽到A卡的概率为0.1，那么我们得出的该概率质量函数和累积分布函数的图像就是下图。可以算出数学期望为6.5，并且大约60%的玩家在前9次抽到，而所谓的非酋也就是触发保底的玩家占到了40%。</p><p><img src="https://i.loli.net/2021/03/27/i13cMAZSkxavU24.png" /></p><p>如果我们用程序模拟10000次在这种概率模型下的抽卡，我们可以得出下面的分布。从图中可以看出，大部分玩家抽100次会得到16-20个想要得到的。</p><p><img src="https://i.loli.net/2021/03/27/MW9EINoerzX2lyO.png" /></p><p>这种十连保底的模型一般用于四星角色或者武器。四星虽然没有五星稀有，但是也是需要一定的保障以确保玩家甚至连四星都抽不到。</p></li><li><h4 id="概率增加模型">概率增加模型</h4><p>那么对于更加稀有的五星角色和武器来说，十连保底肯定就显得太过容易了。这个时候策划一般希望玩家差不多抽几十发可以抽中一个，所以就需要比如100抽保底这样的机制。但是如果这个时候继续采用以上的前面的概率都不变，那么很容易想到这样子的话大部分玩家都会是100发保底...所以就需要调整该概率。</p><p>首先，我们设定一个初始概率<span class="math inline">\(p\)</span>，然后如果没有抽中，那么下一次抽卡概率就给他一个增量 <span class="math inline">\(\alpha\)</span>，如果抽中，那么就回归初始概率。所以，第X次抽中的概率就是<span class="math inline">\(p(x)=p+\alpha\times (x-1)\)</span>，概率质量函数</p><p><span class="math display">\[P(x) =\Pi^{x-1}_{i=1}\lbrack(1-p(i))\rbrack\times p(x)=\Pi^{x-1}_{i=1}[(1-p-\alpha\times(i-1))]\times(p+\alpha\times(x-1))\]</span></p><p>我们设定<span class="math inline">\(p=0.01, \alpha=0.01\)</span>，然后画出图像之后发现，这个图像居然很像是一个正态分布的图像，所以顺便把正态分布的图像画了出来对比，虽然也不知道为什么这两张图这么像。</p><p><img src="https://i.loli.net/2021/03/27/3mABlhKoPTYfWyQ.png" /></p><p>在这个概率模型下，由于100次的时候<span class="math inline">\(p(100)=0.01+99\times0.1=1\)</span>，所以实现了一个100抽保底的效果。但是策划希望的是100抽保底，并且大部分人应该是在五六十抽的时候抽到的，而在这个模型中，超过90%的人在前二十抽就抽到了，这显然不符合预期。所以在这个模型的基础上，我们需要进行相应的调整，让模型的最高点向右偏移。我们由此可以使用一下模型：前50次抽卡概率固定，后50次抽卡使用上面的模型，每次抽卡概率增加。这样我们得出的该概率质量函数就是 <span class="math display">\[p(x)=  \begin{cases}  p, &amp; x&lt;50 \\\\  p+\alpha(x-50), &amp;x&gt;=50  \end{cases}\]</span></p></li></ul><p>和上面一样，如果需要满足100抽保底的话，让<span class="math inline">\(p=0.02,\alpha=0.02\)</span>。其概率质量函数和累积分布函数图像如下：</p><figure><img src="https://i.loli.net/2021/03/27/uxRhTpL34nm21GC.png" alt="拓展模型模拟结果" /><figcaption aria-hidden="true">拓展模型模拟结果</figcaption></figure><p>这张图我认为说可以用作五星的概率模型了。70发之前大部分人都能够抽到，并且集中在40发到70发，占了43.69%。这也可以视作游戏玩家口中的“低保”。</p><p>我们使用上面的模型模拟10000次100连抽，得到的结果如下：</p><figure><img src="https://i.loli.net/2021/03/27/uxRhTpL34nm21GC.png" alt="拓展模型模拟结果" /><figcaption aria-hidden="true">拓展模型模拟结果</figcaption></figure><p>​ 这个结果个人认为就非常像真实游戏中的结果了，大部分人都只能够抽到1-2发，并且很多人都是依靠低保的（这很真实）</p><hr /><h3 id="参考资料">参考资料</h3><p><a href="https://www.40407.com/zixun/7986.html">明日方舟抽卡概率和保底机制研</a> <a href="https://www.jianshu.com/p/031e53e8553c">游戏抽奖概率模型</a></p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> 概率论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现全排列</title>
      <link href="/hexo_zh/2020/12/25/algorithms/permutation/"/>
      <url>/hexo_zh/2020/12/25/algorithms/permutation/</url>
      
        <content type="html"><![CDATA[<p>使用方法：回溯法</p><blockquote><p>回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯<a href="https://baike.baidu.com/item/条件/1783021">条件</a>的某个<a href="https://baike.baidu.com/item/状态/33204">状态</a>的点称为“回溯点”。 ——百度百科</p></blockquote><span id="more"></span><p>全排列回溯的基本思想：对当前位置依次进行与后面所有位置的一个交换，然后对交换后的当前位置之后的元素进行一个全排列，全排列完毕后，进行回溯：将当前位置与之前交换的位置重新调换，形成原来的排列，然后继续进行下一次交换。</p><p>比如我们想要对<code>[1, 2, 3, 4, 5]</code>进行排列，首先确定第一位数，可以是1， 2， 3 ， 4 ，5中任意一个，下图中我们与3进行交换，那么交换后的后四个数就是<code>[2, 1, 4, 5]</code>，然后对这个数组进行全排列(递归)，最后回溯之后就会回到<code>[1, 2, 3, 4, 5]</code>（每次排列都会回溯，所以最外层回溯的时候的排列和起初一定是一样的），接下来把4作为首位，需要排列的数就是<code>[2, 3, 1, 5]</code>，依次类推。</p><figure><img src="https://i.loli.net/2021/04/06/hsI6Vv9DzgGatBM.png" alt="image-20210406142817183" /><figcaption aria-hidden="true">image-20210406142817183</figcaption></figure><p>全部代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permute</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">list</span>, <span class="keyword">int</span> begin, <span class="keyword">int</span> size)</span></span>; <span class="comment">// 实现全排列的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>; <span class="comment">// 交换数组中两个数的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">// 记录全排列的次数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">list</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input the size of the number list: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">list</span> = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>(n, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">// 动态数组</span></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input the number list:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;<span class="built_in">list</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    permute(<span class="built_in">list</span>, <span class="number">0</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The total number of permutation is %d&quot;</span>, num);</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>); <span class="comment">// 释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permute</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">list</span>, <span class="keyword">int</span> begin, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &gt;= size) &#123;</span><br><span class="line">        <span class="comment">// a permutation is found</span></span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">list</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = begin; k &lt; size; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k != begin) swap(&amp;<span class="built_in">list</span>[begin], &amp;<span class="built_in">list</span>[k]);</span><br><span class="line">        permute(<span class="built_in">list</span>, begin+<span class="number">1</span>, size);</span><br><span class="line">        <span class="keyword">if</span> (k != begin) swap(&amp;<span class="built_in">list</span>[begin], &amp;<span class="built_in">list</span>[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯法 </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
